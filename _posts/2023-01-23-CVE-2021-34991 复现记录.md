---
title: CVE-2021-34991 复现记录
date: 2023-01-23 12:54:59 +0800
categories:
  - IOT
tags:
  - pwn
  - ctf
permalink: /posts/id=52/
pin: false
published:
---

因为比较忙，最近才拿起来做这个事

## CVE-2021-34991

This vulnerability allows network-adjacent attackers to execute arbitrary code on affected installations of NETGEAR R6400v2 1.0.4.106_10.0.80 routers. Authentication is not required to exploit this vulnerability. The specific flaw exists within the UPnP service, which listens on TCP port 5000 by default. When parsing the uuid request header, the process does not properly validate the length of user-supplied data prior to copying it to a fixed-length stack-based buffer. An attacker can leverage this vulnerability to execute code in the context of root. Was ZDI-CAN-14110.

漏洞的固件版本是1.0.4.106_10.0.80，在解析 uuid 请求标头时，进程在将用户提供的数据复制到固定长度的基于堆栈的缓冲区之前未正确验证其长度。

关于UPnP的基本原理

https://www.h3c.com/cn/d_201206/922127_30005_0.htm

GENA协议：https://juejin.cn/post/7053763532025757732

本质上是建立一个订阅关系，这部分涉及到exp的构造。

## 漏洞环境复现

首先可以通过qemu-system模拟，但要进行修复

漏洞固件下载：https://www.netgear.com/support/product/r6400v2.aspx#download

qemu-system 模拟过程

```bash
# host主机与qemu互通
sudo tunctl -t tap0 -u `whoami` # -t指定设备名 -u指定访问用户
sudo ifconfig tap0 192.168.110.100/24 # 设定网卡ip
qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 -append "root=/dev/mmcblk0p2" -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic # 启动虚拟机

ifconfig eth0 192.168.110.101/24 # 为虚拟机分配IP
# 在虚拟机中挂载文件系统
python3 -m http.server 9999 # 本机上开启http下载
wget -r http://192.168.110.100:9999/squashfs-root/
mv squashfs-root/ .. & rm 192.168.110.100:9999
or
scp -r squashfs-root/ root@192.168.110.101:~/ # 直接scp本机上传输

mount -t proc /proc ./squashfs-root/proc # 挂载 proc、dev
mount -o bind /dev ./squashfs-root/dev
chroot ./squashfs-root/ sh

# 如需开辟新的终端运行服务等
ssh root@192.168.232.101
```

由于修复过程比较繁琐，后来用了FirmAE

FirmAE模拟硬件

```bash
sudo ./run.sh -d netgear ./firmwares/R6400v2-V1.0.4.118_10.0.90.chk # 调试模式
# 等待出现Starting emulation of firmware... 192.168.1.1 true true 40.816549436 47.928199433
# 2个true标识时即模拟成功


1. connect to socat
2. connect to shell # 开shell
3. tcpdump 
4. run gdbserver # 运行gdbserver
5. file transfer # 传输本机文件到 /firmadyne
6. exit
```

![image-20230222100824169](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230222100824169.png)

这里记录一下模拟过程中出现的问题

```bash
umount: /home/iot/tools/FirmAE/scratch/3/image: target is busy.
# 手动umount: umount /home/iot/tools/FirmAE/scratch/3/image


```

## 漏洞点分析

通过对CVE的查询，发现R6400v2 fixed in firmware version 1.0.4.120 ，用bindiff去找一下漏洞点

通过比较差异大的函数会发现这样一个部分，这里提一下strcpy和strncpy和strlcpy

```
strcpy 是依据 /0 作为结束判断的，如果目标的空间不够，则会引起buffer overflow
strncpy是strcpy的安全版本，它限定了读入个数，但它不考虑目标空间的大小，而是控制读入内容的多少，并且也没有/0作为截断，容易导致非必要输出

strlcpy就不需要我们去手动负责 /0 了，仅需要把sizeof(dst)告之strlcpy即可
它最多拷贝（dstsize-1）个字符,拷贝结束后在dst末尾添加/0结束符，返回值是src的长度
是一个更为安全的选择
```



![image-20230222103048215](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230222103048215.png)



RSB是逆向减法指令R10-R4赋值给R2，这里cmp比较值变成了一个栈变量，该函数内又没有对该栈变量赋值的指令，大概率就是函数参数

STR  r1, [r0] 是将r1寄存器的值，传送到地址值为r0的（存储器）内存中

这里SP作为第五个参数，值为0x40，相较于之前的固定值0x400缩小了很多，也说明了漏洞点就在此处，存在一个栈溢出

![image-20230222111318094](https://e4l4pic.oss-cn-beijing.aliyuncs.com/img/image-20230222111318094.png)



## 构造EXP

这里V14是报文中uuid的部分，而V15是uuid部分后边\r\n的部分









